<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ðŸ¤ </title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg: #0e1020;
    --panel: #141424;
    --panel-border: #2a2a45;
    --panel-shadow: #0b0b12;
    --text: #e0e0e0;
    --muted: #7b8096;
    --accent: #f0c040;
    --pixel-border: #2a2a3f;
  }
  body {
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    min-height: 100vh;
    padding: 18px 12px 32px;
    font-family: 'Courier New', monospace;
    color: var(--text);
  }
  #app {
    width: min(96vw, 980px);
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
  }
  .canvas-shell {
    position: relative;
    width: 100%;
    background: #0b0b12;
    border: 2px solid var(--pixel-border);
    box-shadow: 0 0 0 2px var(--panel-shadow), 6px 6px 0 var(--panel-shadow);
  }
  canvas {
    width: 100%;
    height: auto;
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    cursor: default;
  }
  .canvas-title {
    position: absolute;
    top: 6px;
    left: 8px;
    font-size: 12px;
    color: var(--accent);
    letter-spacing: 0.3px;
    text-shadow: 1px 1px 0 #0b0b12;
    pointer-events: none;
  }
  .canvas-hud {
    position: absolute;
    top: 6px;
    right: 8px;
    display: flex;
    gap: 6px;
    align-items: center;
  }
  button.icon-btn {
    background: #1b1b2b;
    color: var(--text);
    border: 1px solid #3a3a5c;
    padding: 2px 6px;
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    box-shadow: 0 0 0 1px var(--panel-shadow);
  }
  button.icon-btn:hover { background: #24243a; }
  button.icon-btn.active { background: #2b2b45; border-color: #6d6d8f; color: var(--accent); }
  button.icon-btn:disabled { opacity: 0.6; cursor: default; }
  .connection-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    border: 1px solid #0b0b12;
    box-shadow: 0 0 0 1px #0b0b12;
  }
  .connection-dot.connected { background: #2f9a3d; }
  .connection-dot.connecting { background: #d1a128; }
  .connection-dot.disconnected { background: #6c6c6c; }
  .action-bar { display: flex; gap: 8px; }
  button {
    background: #1b1b2b;
    color: var(--text);
    border: 1px solid #3a3a5c;
    padding: 4px 10px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    box-shadow: 0 0 0 1px var(--panel-shadow);
  }
  button:hover { background: #24243a; }
  button.active { background: #2b2b45; border-color: #6d6d8f; color: var(--accent); }
  button:disabled { opacity: 0.6; cursor: default; }
  #usage-panel {
    width: 100%;
    background: var(--panel);
    border: 1px solid var(--panel-border);
    box-shadow: 0 0 0 2px var(--panel-shadow), 4px 4px 0 var(--panel-shadow);
    padding: 8px 10px;
    font-size: 11px;
  }
  #usage-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    color: #f0c040;
    font-weight: bold;
  }
  #usage-updated { color: #7b8096; font-weight: normal; font-size: 10px; }
  #usage-cards { display: flex; flex-wrap: wrap; gap: 8px; }
  .usage-card {
    flex: 1 1 300px;
    min-width: 260px;
    background: #0f0f1a;
    border: 1px solid #2a2a3f;
    padding: 8px;
  }
  .usage-card.warn { border-color: #d1a128; }
  .usage-card.alert { border-color: #c13c3c; }
  .usage-card.exhausted { border-color: #c13c3c; background: #1a0a0a; }
  .usage-title { display: flex; justify-content: space-between; align-items: center; color: #e6e6e6; font-weight: bold; }
  .usage-pill { font-size: 9px; padding: 1px 6px; border-radius: 10px; border: 1px solid #2a2a3f; color: #c9cedf; text-transform: uppercase; letter-spacing: 0.3px; }
  .usage-pill.ok { border-color: #2f9a3d; color: #bfe6c7; }
  .usage-pill.warn { border-color: #d1a128; color: #f3e2a2; }
  .usage-pill.alert { border-color: #c13c3c; color: #f5b3b3; }
  .usage-pill.error { border-color: #7b8096; color: #b1b6c9; }
  .usage-pill.exhausted { border-color: #c13c3c; color: #f5b3b3; background: #3a1010; }
  .usage-metric { margin-top: 6px; }
  .usage-row { display: flex; justify-content: space-between; color: #c9cedf; font-size: 10px; }
  .usage-bar { height: 6px; background: #1b1b2b; border: 1px solid #2a2a3f; margin-top: 3px; }
  .usage-fill { height: 100%; width: 0%; background: #2f9a3d; }
  .usage-fill.warn { background: #d1a128; }
  .usage-fill.alert { background: #c13c3c; }
  .usage-fill.unknown { background: #4a4a62; }
  .usage-meta { margin-top: 6px; color: #7b8096; font-size: 10px; }
  .usage-note { margin-top: 4px; color: #8b8fa3; font-size: 10px; }
  #tooltip {
    position: fixed;
    z-index: 10;
    display: none;
    max-width: 320px;
    padding: 8px 10px;
    font-size: 11px;
    line-height: 1.35;
    color: #e6e6e6;
    background: #15151f;
    border: 2px solid #4a4a62;
    box-shadow: 0 0 0 2px #0b0b12, 4px 4px 0 #0b0b12;
    pointer-events: none;
  }
  .tooltip-title { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; font-weight: bold; color: #f0c040; }
  .tooltip-row { display: flex; gap: 6px; margin: 2px 0; }
  .tooltip-label { min-width: 70px; color: #9aa0b5; }
  .tooltip-value { color: #e6e6e6; word-break: break-word; }
  .tooltip-muted { color: #8b8fa3; }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; box-shadow: 0 0 0 1px #0b0b12; }
  .status-active { background: #2f9a3d; }
  .status-waiting { background: #d1a128; }
  .status-ci { background: #c13c3c; }
  .status-merged { background: #d1a128; }
  .status-pr_closed { background: #8855aa; }
  .status-exited { background: #6c6c6c; }
  .status-dead { background: #6c6c6c; }
  #agents-panel {
    background: #121222;
    border: 1px solid var(--panel-border);
    box-shadow: 0 0 0 2px var(--panel-shadow), 4px 4px 0 var(--panel-shadow);
    padding: 6px 8px;
    font-size: 11px;
  }
  #agents-panel summary {
    list-style: none;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: var(--accent);
    font-weight: bold;
    margin-bottom: 6px;
  }
  #agents-panel summary::-webkit-details-marker { display: none; }
  #agents-panel summary::before {
    content: 'â–¾';
    margin-right: 6px;
    color: var(--muted);
  }
  #agents-panel:not([open]) summary::before { content: 'â–¸'; }
  #agents-summary {
    color: var(--muted);
    font-weight: normal;
    font-size: 10px;
  }
  #agents-list,
  #queue-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  #queue-list { margin-top: 6px; }
  .queue-title {
    width: 100%;
    color: var(--accent);
    font-weight: bold;
  }
  .agent-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 3px 6px;
    background: #0f0f1a;
    border: 1px solid var(--pixel-border);
    font-size: 10px;
    white-space: nowrap;
  }
  .agent-pill-name { color: var(--accent); }
  .agent-pill-repo { color: #88f; }
  .agent-pill-state { color: #9aa0b5; }
  .agent-pill.state-coding { border-color: #2f9a3d; }
  .agent-pill.state-waiting { border-color: #d1a128; }
  .agent-pill.state-review_waiting { border-color: #d1a128; }
  .agent-pill.state-reading { border-color: #3b7cff; }
  .agent-pill.state-merged { border-color: #d1a128; opacity: 0.8; }
  .agent-pill.state-pr_closed { border-color: #8855aa; opacity: 0.8; }
  .agent-pill.state-exited,
  .agent-pill.state-dead { border-color: #6c6c6c; opacity: 0.7; }
  .agent-pill.state-idle { border-color: #4a4a62; }
  .agent-pill.queued { border-style: dashed; }
  .agents-empty {
    color: var(--muted);
    font-size: 10px;
    padding: 2px 0;
  }
</style>
</head>
<body>
<div id="app">
  <div class="canvas-shell">
    <canvas id="office" width="640" height="400"></canvas>
    <div class="canvas-title">ðŸ¤  Corral</div>
    <div class="canvas-hud">
      <div id="connectionIndicator" class="connection-dot connecting" title="Connecting"></div>
      <button id="soundToggle" class="icon-btn" type="button" onclick="toggleSound()" aria-label="Sound off">ðŸ”‡</button>
    </div>
  </div>
  <div class="action-bar">
    <button id="cleanButton" type="button" onclick="cleanCompleted()">ðŸ§¹ Clean</button>
    <button id="completedToggle" type="button" onclick="toggleCompleted()">âœ… Show completed</button>
  </div>
  <div id="usage-panel" aria-live="polite">
    <div id="usage-header">
      <span>Subscription Usage</span>
      <span id="usage-updated">â€”</span>
    </div>
    <div id="usage-cards"></div>
  </div>
  <details id="agents-panel" open>
    <summary>
      <span>Agents</span>
      <span id="agents-summary">0</span>
    </summary>
    <div id="agents-list"></div>
    <div id="queue-list"></div>
  </details>
</div>
<div id="tooltip" role="tooltip" aria-hidden="true"></div>

<script>
// === CONSTANTS ===
const TILE = 16;
const SCALE = 2;
const S = TILE * SCALE; // rendered tile size
const COLS = 20;
const ROWS = 12; // 640x384 at scale 2
const DESK_COLS = 4;
const DESK_ROWS = 3;
const DESK_START_X = 2;
const DESK_START_Y = 2;
const DESK_GAP_X = 5;
const DESK_GAP_Y = 3;
const CANVAS_W = COLS * S;
const OFFICE_H = ROWS * S;
const TIMELINE_MAX_ROWS = 20;
const TIMELINE_ROW_HEIGHT = 18;
const TIMELINE_BAR_HEIGHT = 8;
const TIMELINE_LEGEND_HEIGHT = 14;
const TIMELINE_AXIS_HEIGHT = 14;
const TIMELINE_HEADER_HEIGHT = TIMELINE_LEGEND_HEIGHT + TIMELINE_AXIS_HEIGHT;
const TIMELINE_PADDING = 8;
const TIMELINE_LABEL_WIDTH = 150;
const TIMELINE_HEIGHT = TIMELINE_HEADER_HEIGHT + TIMELINE_PADDING * 2 + TIMELINE_ROW_HEIGHT * TIMELINE_MAX_ROWS;
const TIMELINE_Y = OFFICE_H;
const USAGE_PANEL_HEIGHT = 48;
const USAGE_PANEL_Y = OFFICE_H + TIMELINE_HEIGHT;
const CANVAS_H = OFFICE_H + TIMELINE_HEIGHT + USAGE_PANEL_HEIGHT + S; // office + timeline + usage + status bar
const USAGE_BAR_WIDTH = 120;
const USAGE_BAR_HEIGHT = 8;
const USAGE_FETCH_INTERVAL = 5 * 60 * 1000; // 5 minutes
const DOOR_TILE = { x: 0, y: 6 };
const WALK_SPEED = 2; // tiles per second
const ENTER_STAGGER = 0.5; // seconds
const TOMBSTONE_FADE_MS = 30 * 60 * 1000;
const CONFETTI_COUNT_MIN = 20;
const CONFETTI_COUNT_MAX = 30;
const CONFETTI_SIZE = 2; // base pixels
const CONFETTI_LIFE = 2.0; // seconds
const CONFETTI_GRAVITY = 70; // px/s^2
const CONFETTI_COLORS = ['#f0c040', '#4ae04a', '#ffffff', '#d1a128'];
const CELEBRATION_TEXT_DURATION = 900; // ms
const CELEBRATION_FLASH_DURATION = 450; // ms
const CELEBRATION_TOTAL_DURATION = 2000; // ms

const canvas = document.getElementById('office');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const tooltip = document.getElementById('tooltip');

// === COLORS (pixel art palette) ===
const BASE_PAL = {
  floor: '#3a3a5c',
  floorAlt: '#33334f',
  wall: '#5c5c8a',
  wallTop: '#7a7ab0',
  desk: '#8b6914',
  deskTop: '#c49b2a',
  monitor: '#222',
  monitorScreen: '#0f380f',
  monitorScreenActive: '#4ae04a',
  monitorScreenCi: '#ff3b3b',
  monitorScreenCiDark: '#7a1111',
  chair: '#444',
  plant: '#2d5a1e',
  plantPot: '#8b5e3c',
  divider: '#26263b',
  badgeGreen: '#2f9a3d',
  badgeGold: '#d1a128',
  badgeText: '#111',
  cup: '#d9d9d9',
  coffee: '#5a3a1a',
  steam: '#e5e5e5',
  fire1: '#f04',
  fire2: '#f80',
  fire3: '#ff0',
  tokenGreen: '#2f9a3d',
  tokenYellow: '#d1a128',
  tokenRed: '#c13c3c',
  tokenBg: '#0b0b12',
  tombstone: '#6c6c6c',
  tombstoneDark: '#4a4a4a',
  tombstoneLight: '#8b8b8b',
  tombstoneText: '#e0dfd8',
};
let PAL = { ...BASE_PAL };

const TIMELINE_COLORS = {
  working: '#3b7cff',
  pr: '#3adf7a',
  ciFailed: '#ff5c5c',
  merged: '#f0c040',
  prClosed: '#8855aa',
  dead: '#6c6c6c',
  axis: '#2a2a3f',
  grid: '#242438',
  label: '#c9cedf',
  muted: '#7b8096',
  now: '#f7e28a',
};

// === CHARACTER COLORS ===
const CHAR_COLORS = [
  { skin: '#f5c6a0', hair: '#4a2800', shirt: '#e04040', pants: '#3050a0' }, // red
  { skin: '#d4a373', hair: '#1a1a2e', shirt: '#4080e0', pants: '#2a2a4e' }, // blue
  { skin: '#f5deb3', hair: '#c04000', shirt: '#40c040', pants: '#404040' }, // green
  { skin: '#c49b6a', hair: '#222', shirt: '#e0a040', pants: '#3a3a5c' },   // gold
  { skin: '#f0d0b0', hair: '#604020', shirt: '#a040c0', pants: '#333' },    // purple
  { skin: '#e8c090', hair: '#802020', shirt: '#40c0c0', pants: '#2a2a4e' }, // teal
];

const MONITOR = {
  w: 8,
  h: 6,
  screenX: 1,
  screenY: 1,
  screenW: 6,
  screenH: 4,
  standW: 4,
  standH: 2,
};

// === DESK POSITIONS ===
const DESKS = [];
for (let row = 0; row < DESK_ROWS; row++) {
  for (let col = 0; col < DESK_COLS; col++) {
    DESKS.push({ x: DESK_START_X + col * DESK_GAP_X, y: DESK_START_Y + row * DESK_GAP_Y });
  }
}

// === TIME + WINDOW SETTINGS ===
const WINDOW = { x: Math.floor(COLS / 2) - 2, y: 0, w: 4, h: 1 };
const TIME_TRANSITION_MINUTES = 30;
const TIME_PHASES = {
  day: {
    brightness: 1.05,
    tint: { r: 1.02, g: 1.04, b: 1.08 },
    sky: '#7ec8ff',
    sun: '#ffe39a',
    sunAlpha: 1,
    starAlpha: 0,
    lamp: 0,
    monitorGlow: 0.05,
    monitorBoost: 1.0,
  },
  sunset: {
    brightness: 0.9,
    tint: { r: 1.08, g: 0.98, b: 0.9 },
    sky: '#f7a062',
    sun: '#ffd08a',
    sunAlpha: 0.6,
    starAlpha: 0.2,
    lamp: 0.55,
    monitorGlow: 0.3,
    monitorBoost: 1.1,
  },
  night: {
    brightness: 0.55,
    tint: { r: 0.8, g: 0.85, b: 1.0 },
    sky: '#0a1029',
    sun: '#ffe39a',
    sunAlpha: 0,
    starAlpha: 1,
    lamp: 1,
    monitorGlow: 0.9,
    monitorBoost: 1.5,
  },
  sunrise: {
    brightness: 0.85,
    tint: { r: 1.05, g: 0.98, b: 0.95 },
    sky: '#f6b4a0',
    sun: '#ffd7a0',
    sunAlpha: 0.6,
    starAlpha: 0.35,
    lamp: 0.35,
    monitorGlow: 0.35,
    monitorBoost: 1.15,
  },
};

// === AGENT STATE ===
let agents = [];
let currentLayout = null;
let hoveredDeskIndex = null;
let hoveredAgent = null;
let hoveredSignature = '';
let transitions = [];
let hasInitialized = false;
let lastRenderTime = null;
let timeState = null;
let windowStars = [];
let windowStarSeed = null;
let previousAgentsByKey = new Map();
let tombstones = [];
const tombstonesByKey = new Map();
const tombstonesByDesk = new Map();
let historyEntries = [];
let timelineEntries = [];
let timelineLayout = null;
let timelineScroll = 0;
let timelineHover = null;
let usageData = null;
const mergedAgents = new Set();
const confettiPool = [];
const confettiActive = [];
const celebrations = [];
const celebrationByKey = new Map();
let soundEnabled = false;
let audioCtx = null;
let usageLastFetch = 0;
let showCompleted = true;
let cleaning = false;
let connectionState = 'connecting';
let connectionNote = '';
let lastUpdateAt = null;
let statusMessage = '';
let statusMessageUntil = 0;

// === DRAWING HELPERS ===
function fillTile(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * S, y * S, S, S);
}

function drawRect(px, py, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(px * SCALE, py * SCALE, w * SCALE, h * SCALE);
}

// === TIME + COLOR HELPERS ===
function clampByte(value) {
  return Math.max(0, Math.min(255, Math.round(value)));
}

function hexToRgb(hex) {
  const clean = hex.replace('#', '').trim();
  if (clean.length === 3) {
    const r = parseInt(clean[0] + clean[0], 16);
    const g = parseInt(clean[1] + clean[1], 16);
    const b = parseInt(clean[2] + clean[2], 16);
    return { r, g, b };
  }
  const num = parseInt(clean, 16);
  return {
    r: (num >> 16) & 255,
    g: (num >> 8) & 255,
    b: num & 255,
  };
}

function rgbToHex({ r, g, b }) {
  const rr = clampByte(r).toString(16).padStart(2, '0');
  const gg = clampByte(g).toString(16).padStart(2, '0');
  const bb = clampByte(b).toString(16).padStart(2, '0');
  return `#${rr}${gg}${bb}`;
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function lerpHex(a, b, t) {
  const ar = hexToRgb(a);
  const br = hexToRgb(b);
  return rgbToHex({
    r: lerp(ar.r, br.r, t),
    g: lerp(ar.g, br.g, t),
    b: lerp(ar.b, br.b, t),
  });
}

function applyTone(hex, brightness, tint) {
  const rgb = hexToRgb(hex);
  return rgbToHex({
    r: rgb.r * brightness * tint.r,
    g: rgb.g * brightness * tint.g,
    b: rgb.b * brightness * tint.b,
  });
}

function boostColor(hex, boost) {
  if (boost === 1) return hex;
  const rgb = hexToRgb(hex);
  return rgbToHex({
    r: rgb.r * boost,
    g: rgb.g * boost,
    b: rgb.b * boost,
  });
}

function hashString(input) {
  let hash = 2166136261;
  for (let i = 0; i < input.length; i++) {
    hash ^= input.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

function mulberry32(seed) {
  return function() {
    let t = seed += 0x6d2b79f5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function ensureWindowStars(seed, width, height) {
  if (windowStarSeed === seed && windowStars.length) return;
  windowStarSeed = seed;
  const rng = mulberry32(hashString(seed));
  const count = Math.max(6, Math.floor((width * height) / 36));
  windowStars = [];
  for (let i = 0; i < count; i++) {
    windowStars.push({
      x: Math.floor(rng() * width),
      y: Math.floor(rng() * height),
      twinkle: rng() * Math.PI * 2,
    });
  }
}

function getTimeBlend(minutes) {
  const transitions = [
    { at: 6 * 60, from: 'night', to: 'sunrise' },
    { at: 8 * 60, from: 'sunrise', to: 'day' },
    { at: 17 * 60, from: 'day', to: 'sunset' },
    { at: 19 * 60, from: 'sunset', to: 'night' },
  ];
  for (const transition of transitions) {
    const start = transition.at - TIME_TRANSITION_MINUTES;
    if (minutes >= start && minutes < transition.at) {
      const blend = (minutes - start) / TIME_TRANSITION_MINUTES;
      return { from: transition.from, to: transition.to, blend };
    }
  }
  let phase = 'day';
  if (minutes >= 8 * 60 && minutes < 17 * 60) phase = 'day';
  else if (minutes >= 17 * 60 && minutes < 19 * 60) phase = 'sunset';
  else if (minutes >= 19 * 60 || minutes < 6 * 60) phase = 'night';
  else phase = 'sunrise';
  return { from: phase, to: phase, blend: 0 };
}

function blendPhaseSettings(fromKey, toKey, blend) {
  const from = TIME_PHASES[fromKey];
  const to = TIME_PHASES[toKey];
  return {
    phase: fromKey,
    nextPhase: toKey,
    blend,
    brightness: lerp(from.brightness, to.brightness, blend),
    tint: {
      r: lerp(from.tint.r, to.tint.r, blend),
      g: lerp(from.tint.g, to.tint.g, blend),
      b: lerp(from.tint.b, to.tint.b, blend),
    },
    sky: lerpHex(from.sky, to.sky, blend),
    sun: lerpHex(from.sun, to.sun, blend),
    sunAlpha: lerp(from.sunAlpha, to.sunAlpha, blend),
    starAlpha: lerp(from.starAlpha, to.starAlpha, blend),
    lamp: lerp(from.lamp, to.lamp, blend),
    monitorGlow: lerp(from.monitorGlow, to.monitorGlow, blend),
    monitorBoost: lerp(from.monitorBoost, to.monitorBoost, blend),
  };
}

function getTimeSettings(hour, minute) {
  const minutes = ((hour * 60) + minute) % 1440;
  const dayFactor = minutes / 1440;
  const blendInfo = getTimeBlend(minutes);
  const settings = blendPhaseSettings(blendInfo.from, blendInfo.to, blendInfo.blend);
  return { ...settings, dayFactor };
}

function getTimeColors(hour, minute, settings) {
  const state = settings || getTimeSettings(hour, minute);
  const palette = {};
  Object.keys(BASE_PAL).forEach((key) => {
    palette[key] = applyTone(BASE_PAL[key], state.brightness, state.tint);
  });
  const boost = state.monitorBoost;
  palette.monitorScreen = boostColor(palette.monitorScreen, boost);
  palette.monitorScreenActive = boostColor(palette.monitorScreenActive, boost);
  palette.monitorScreenCi = boostColor(palette.monitorScreenCi, boost);
  palette.monitorScreenCiDark = boostColor(palette.monitorScreenCiDark, boost);
  palette.windowSky = state.sky;
  palette.windowSun = state.sun;
  palette.star = '#f8f8ff';
  palette.lampGlow = '#ffd27a';
  return palette;
}

function getTimeState(hour, minute) {
  const settings = getTimeSettings(hour, minute);
  const palette = getTimeColors(hour, minute, settings);
  return { ...settings, palette };
}

function updateSoundButton() {
  const btn = document.getElementById('soundToggle');
  if (!btn) return;
  btn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
  btn.setAttribute('aria-label', soundEnabled ? 'Sound on' : 'Sound off');
  btn.title = soundEnabled ? 'Sound on (S)' : 'Sound off (S)';
  btn.classList.toggle('active', soundEnabled);
}

function updateConnectionIndicator() {
  const el = document.getElementById('connectionIndicator');
  if (!el) return;
  el.classList.remove('connected', 'connecting', 'disconnected');
  el.classList.add(connectionState);
  const label = connectionState === 'connected'
    ? 'Connected'
    : connectionState === 'connecting'
      ? 'Connecting'
      : 'Disconnected';
  el.title = connectionNote ? `${label} â€” ${connectionNote}` : label;
}

function setConnectionState(state, note = '') {
  connectionState = state;
  connectionNote = note;
  updateConnectionIndicator();
}

function setStatusMessage(message, durationMs = 4000) {
  statusMessage = message;
  statusMessageUntil = Date.now() + durationMs;
}

function getStatusMessage() {
  if (!statusMessage) return '';
  if (Date.now() > statusMessageUntil) {
    statusMessage = '';
    return '';
  }
  return statusMessage;
}

function updateCompletedToggle() {
  const btn = document.getElementById('completedToggle');
  if (!btn) return;
  btn.textContent = showCompleted ? 'âœ… Show completed' : 'â¬œ Show completed';
  btn.classList.toggle('active', showCompleted);
}

function toggleCompleted() {
  showCompleted = !showCompleted;
  updateCompletedToggle();
  updateAgentsList();
}

function setCleanButtonState(isCleaning) {
  const btn = document.getElementById('cleanButton');
  if (!btn) return;
  btn.disabled = isCleaning;
  btn.textContent = isCleaning ? 'ðŸ§¹ Cleaning...' : 'ðŸ§¹ Clean';
}

function initAudio() {
  if (!audioCtx) {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = AudioContext ? new AudioContext() : null;
  }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  updateSoundButton();
  if (soundEnabled) {
    initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }
}

function toggleFullscreen() {
  const shell = document.querySelector('.canvas-shell');
  if (!shell) return;
  if (document.fullscreenElement) {
    document.exitFullscreen().catch(() => {});
  } else if (shell.requestFullscreen) {
    shell.requestFullscreen().catch(() => {});
  }
}

function playDing() {
  if (!soundEnabled) return;
  initAudio();
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(880, t);
  osc.frequency.exponentialRampToValueAtTime(440, t + 0.12);
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.08, t + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.3);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + 0.32);
}

async function cleanCompleted() {
  if (cleaning) return;
  cleaning = true;
  setCleanButtonState(true);
  showCompleted = false;
  updateCompletedToggle();
  updateAgentsList();
  try {
    const resp = await fetch('/api/clean', { method: 'POST' });
    if (!resp.ok) throw new Error(`Clean failed (${resp.status})`);
    await refreshFromLasso();
  } catch (err) {
    setStatusMessage(`Clean failed â€” ${err.message}`);
  } finally {
    cleaning = false;
    setCleanButtonState(false);
  }
}

// === DATA HELPERS ===
function getRepoName(agent) {
  if (!agent) return '';
  return (agent.repo || '').split('/').pop() || '';
}

function getIssueId(agent) {
  if (!agent) return '';
  return agent.issueId ?? agent.issue ?? agent.issueID ?? '';
}

function resolveAgentType(agent) {
  if (!agent) return '';
  return (agent.agentType || agent.agent || agent.type || '').toLowerCase();
}

function getMonitorText(agent) {
  if (!agent) return '';
  const issueTitle = (agent.issueTitle || '').toString().trim();
  if (issueTitle) return issueTitle;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  if (repo && issueId) return `${repo}#${issueId}`;
  return repo || agent.id || '';
}

function getReaction(agent) {
  return agent && agent.reactionState ? agent.reactionState : {};
}

function getTokensUsed(agent) {
  if (!agent) return null;
  const value = agent.tokensUsed ?? agent.tokens_used ?? agent.tokenUsage ?? agent.token_usage;
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string' && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return null;
}

function isMergedStatus(agent) {
  if (!agent) return false;
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  return status.includes('merged') || activity.includes('merged');
}

function completionCategory(agent) {
  if (!agent) return null;
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  if (status.includes('merged') || activity.includes('merged')) return 'merged';
  if (status.includes('pr_closed') || activity.includes('pr_closed')) return 'pr_closed';
  if (
    status.includes('exited') ||
    activity.includes('exited') ||
    status.includes('archived') ||
    activity.includes('archived') ||
    status.includes('dead') ||
    activity.includes('dead')
  ) {
    return 'exited';
  }
  if (agent.endedAt || agent.ended_at) return 'exited';
  return null;
}


function getAgentUrl(agent) {
  if (!agent) return '';
  const prUrl = agent.prUrl || agent.prURL || agent.pullRequestUrl || agent.pull_request_url;
  if (typeof prUrl === 'string' && prUrl.trim()) return prUrl.trim();
  const repo = typeof agent.repo === 'string' ? agent.repo.trim() : '';
  const issueId = getIssueId(agent);
  const issueIdStr = issueId !== null && issueId !== undefined ? String(issueId).trim() : '';
  if (repo && issueIdStr) return `https://github.com/${repo}/issues/${issueIdStr}`;
  return '';
}

function escapeHtml(value) {
  return String(value ?? '').replace(/[&<>"']/g, char => {
    switch (char) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return char;
    }
  });
}

function formatDuration(ms) {
  const totalMins = Math.max(0, Math.floor(ms / 60000));
  const hours = Math.floor(totalMins / 60);
  const mins = totalMins % 60;
  if (hours > 0) return `${hours}h ${mins}m`;
  return `${mins}m`;
}

function tombstoneLabel(agent) {
  if (!agent) return 'unknown';
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  if (repo && issueId) return `${repo}#${issueId}`;
  return repo || agent.id || agent.label || 'unknown';
}

function tombstoneDuration(agent, deadAt, nowMs) {
  if (!agent) return '0m';
  const createdAt = coerceMs(agent.createdAt) || deadAt || nowMs;
  const endAt = deadAt || nowMs;
  return formatDuration(Math.max(0, endAt - createdAt));
}

function tombstoneAlpha(tombstone, nowMs) {
  const age = nowMs - tombstone.deadAt;
  if (age <= 0) return 1;
  return clamp(1 - age / TOMBSTONE_FADE_MS, 0, 1);
}

function buildTombstone(agent, slot, nowMs) {
  if (!agent || !slot) return null;
  const deadAt = coerceMs(agent.endedAt || agent.ended_at) || nowMs;
  if (nowMs - deadAt >= TOMBSTONE_FADE_MS) return null;
  return {
    key: agentKey(agent, slot.idx),
    deskIndex: slot.idx,
    desk: slot.desk,
    label: tombstoneLabel(agent),
    duration: tombstoneDuration(agent, deadAt, nowMs),
    deadAt,
  };
}

function addTombstone(tombstone, nowMs) {
  if (!tombstone) return;
  if (tombstonesByKey.has(tombstone.key)) return;
  if (nowMs - tombstone.deadAt >= TOMBSTONE_FADE_MS) return;
  const existing = tombstonesByDesk.get(tombstone.deskIndex);
  if (existing) removeTombstoneByKey(existing.key);
  tombstones.push(tombstone);
  tombstonesByKey.set(tombstone.key, tombstone);
  tombstonesByDesk.set(tombstone.deskIndex, tombstone);
}

function removeTombstoneByKey(key) {
  const existing = tombstonesByKey.get(key);
  if (!existing) return;
  tombstonesByKey.delete(key);
  if (tombstonesByDesk.get(existing.deskIndex) === existing) {
    tombstonesByDesk.delete(existing.deskIndex);
  }
  tombstones = tombstones.filter(tombstone => tombstone.key !== key);
}

function removeTombstoneAtDesk(deskIndex) {
  const existing = tombstonesByDesk.get(deskIndex);
  if (existing) removeTombstoneByKey(existing.key);
}

function pruneTombstones(nowMs) {
  if (!tombstones.length) return;
  tombstones = tombstones.filter(tombstone => {
    const alive = nowMs - tombstone.deadAt < TOMBSTONE_FADE_MS;
    if (!alive) {
      tombstonesByKey.delete(tombstone.key);
      if (tombstonesByDesk.get(tombstone.deskIndex) === tombstone) {
        tombstonesByDesk.delete(tombstone.deskIndex);
      }
    }
    return alive;
  });
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function coerceMs(value) {
  if (typeof value === 'number' && Number.isFinite(value)) {
    if (value > 1e12) return value;
    if (value > 1e9) return value * 1000;
  }
  if (typeof value === 'string' && value.trim()) {
    const num = Number(value);
    if (Number.isFinite(num)) return coerceMs(num);
    const parsed = Date.parse(value);
    if (!Number.isNaN(parsed)) return parsed;
  }
  return null;
}

function pickTimestamp(agent, keys) {
  if (!agent) return null;
  for (const key of keys) {
    if (!Object.prototype.hasOwnProperty.call(agent, key)) continue;
    const ts = coerceMs(agent[key]);
    if (ts) return ts;
  }
  return null;
}

const COMPLETED_TIME_KEYS = [
  'endedAt',
  'ended_at',
  'mergedAt',
  'merged_at',
  'completedAt',
  'completed_at',
  'finishedAt',
  'finished_at',
  'closedAt',
  'closed_at',
];
const COMPLETED_FALLBACK_KEYS = [
  'lastUpdatedAt',
  'updatedAt',
  'updated_at',
  'lastSeenAlive',
  'last_seen_alive',
  'lastHeartbeat',
  'last_heartbeat',
  'createdAt',
  'created_at',
];

function completionTimestamp(agent) {
  return pickTimestamp(agent, COMPLETED_TIME_KEYS)
    || pickTimestamp(agent, COMPLETED_FALLBACK_KEYS)
    || 0;
}

function normalizeHistoryEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const next = { ...entry };
  if (!Array.isArray(next.statusHistory)) next.statusHistory = [];
  return next;
}

function entryId(entry, fallbackIndex) {
  if (!entry) return `agent-${fallbackIndex}`;
  const id = (entry.id || entry.agentId || entry.sessionId || entry.name || '').toString().trim();
  if (id) return id;
  return agentKey(entry, fallbackIndex);
}

function mergeTimelineEntries(activeAgents, historyList) {
  const historyMap = new Map();
  historyList.map(normalizeHistoryEntry).forEach((entry) => {
    if (entry && entry.id) historyMap.set(entry.id, entry);
  });

  const merged = [];
  activeAgents.forEach((agent, index) => {
    const id = entryId(agent, index);
    const historyEntry = historyMap.get(id);
    const createdAt = coerceMs(agent.createdAt) || coerceMs(historyEntry && historyEntry.createdAt) || Date.now();
    const entry = {
      id,
      repo: agent.repo || (historyEntry && historyEntry.repo),
      issueId: agent.issueId || agent.issue_id || (historyEntry && historyEntry.issueId),
      issueTitle: agent.issueTitle || agent.issue_title || (historyEntry && historyEntry.issueTitle),
      status: agent.status || (historyEntry && historyEntry.status) || '',
      activity: agent.activity || (historyEntry && historyEntry.activity) || '',
      agentType: agent.agentType || agent.agent_type || (historyEntry && historyEntry.agentType),
      createdAt: new Date(createdAt).toISOString(),
      endedAt: null,
      prNumber: agent.prNumber || agent.pr_number || (historyEntry && historyEntry.prNumber),
      statusHistory: (historyEntry && historyEntry.statusHistory) ? historyEntry.statusHistory.slice() : [],
      isActive: true,
      source: agent,
    };
    merged.push(entry);
    historyMap.delete(id);
  });

  historyMap.forEach((entry) => {
    const createdAt = coerceMs(entry.createdAt) || Date.now();
    merged.push({
      ...entry,
      createdAt: new Date(createdAt).toISOString(),
      endedAt: entry.endedAt || null,
      status: entry.status || '',
      activity: entry.activity || '',
      statusHistory: Array.isArray(entry.statusHistory) ? entry.statusHistory.slice() : [],
      isActive: false,
      source: entry,
    });
  });

  merged.sort((a, b) => {
    if (a.isActive !== b.isActive) return a.isActive ? -1 : 1;
    const aTime = a.isActive ? coerceMs(a.createdAt) : (coerceMs(a.endedAt) || coerceMs(a.createdAt));
    const bTime = b.isActive ? coerceMs(b.createdAt) : (coerceMs(b.endedAt) || coerceMs(b.createdAt));
    return (bTime || 0) - (aTime || 0);
  });

  return merged;
}

function updateTimelineEntries() {
  timelineEntries = mergeTimelineEntries(agents, historyEntries);
  const maxScroll = Math.max(0, timelineEntries.length - TIMELINE_MAX_ROWS);
  timelineScroll = clamp(timelineScroll, 0, maxScroll);
}

function agentKey(agent, fallbackIndex) {
  if (!agent) return `agent-${fallbackIndex}`;
  const id = (agent.id || agent.label || agent.agentId || agent.name || '').toString().trim();
  if (id) return id;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  const created = (agent.createdAt || '').toString().trim();
  if (repo || issueId || created) return `${repo}#${issueId}-${created}`;
  return `agent-${fallbackIndex}`;
}

function buildPath(start, end) {
  const mid = { x: end.x, y: start.y };
  const seg1 = Math.abs(mid.x - start.x) + Math.abs(mid.y - start.y);
  const seg2 = Math.abs(end.x - mid.x) + Math.abs(end.y - mid.y);
  return {
    start: { ...start },
    mid,
    end: { ...end },
    seg1,
    seg2,
    total: seg1 + seg2,
  };
}

function positionAlongPath(path, dist) {
  if (path.total === 0) return { x: path.end.x, y: path.end.y };
  if (dist <= path.seg1) {
    const dx = path.mid.x - path.start.x;
    const dy = path.mid.y - path.start.y;
    const stepX = dx === 0 ? 0 : Math.sign(dx) * dist;
    const stepY = dy === 0 ? 0 : Math.sign(dy) * dist;
    return { x: path.start.x + stepX, y: path.start.y + stepY };
  }
  const remaining = dist - path.seg1;
  const dx = path.end.x - path.mid.x;
  const dy = path.end.y - path.mid.y;
  const stepX = dx === 0 ? 0 : Math.sign(dx) * remaining;
  const stepY = dy === 0 ? 0 : Math.sign(dy) * remaining;
  return { x: path.mid.x + stepX, y: path.mid.y + stepY };
}

function transitionPosition(transition, now) {
  const progress = now < transition.startAt ? 0 : Math.min(transition.progress, transition.path.total);
  return positionAlongPath(transition.path, progress);
}

function makeTransition({ key, agent, type, start, end, startAt, colorIdx, tombstone = null }) {
  return {
    key,
    agent,
    type,
    path: buildPath(start, end),
    progress: 0,
    startAt,
    colorIdx,
    tombstone,
  };
}

function reverseTransition(transition, type, end, now, tombstone = null) {
  const start = transitionPosition(transition, now);
  transition.type = type;
  transition.path = buildPath(start, end);
  transition.progress = 0;
  transition.startAt = now;
  transition.tombstone = tombstone;
}

function mapSlotsByKey(layout) {
  const map = new Map();
  layout.slots.forEach(slot => {
    map.set(slot.key, slot);
  });
  return map;
}

function storePreviousAgents(list) {
  const map = new Map();
  list.forEach((agent, index) => {
    map.set(agentKey(agent, index), agent);
  });
  previousAgentsByKey = map;
}

function updateTransitions(now, dt) {
  if (!transitions.length) return;
  const nowMs = Date.now();
  const next = [];
  transitions.forEach(transition => {
    if (now < transition.startAt) {
      next.push(transition);
      return;
    }
    if (transition.path.total === 0) {
      if (transition.tombstone) addTombstone(transition.tombstone, nowMs);
      return;
    }
    if (dt > 0) {
      transition.progress = Math.min(transition.path.total, transition.progress + dt * WALK_SPEED);
    }
    if (transition.progress >= transition.path.total) {
      if (transition.tombstone) addTombstone(transition.tombstone, nowMs);
      return;
    }
    next.push(transition);
  });
  transitions = next;
}

function setAgents(nextAgents, { skipAnimation = false } = {}) {
  const prevAgents = agents;
  const prevLayout = buildLayout(prevAgents);
  const nextLayout = buildLayout(nextAgents);
  const prevSlotsByKey = mapSlotsByKey(prevLayout);
  const nextSlotsByKey = mapSlotsByKey(nextLayout);
  const now = performance.now();
  const nowMs = Date.now();
  if (hasInitialized && previousAgentsByKey.size > 0) {
    nextLayout.slots.forEach(slot => {
      const key = slot.key;
      const prevAgent = previousAgentsByKey.get(key);
      if (!prevAgent) return;
      if (mergedAgents.has(key)) return;
      if (!isMergedStatus(prevAgent) && isMergedStatus(slot.agent)) {
        mergedAgents.add(key);
        startCelebration(slot, now);
      }
    });
  }

  if (!hasInitialized || skipAnimation) {
    agents = nextAgents;
    transitions = [];
    hasInitialized = true;
    nextLayout.slots.forEach(slot => {
      if (mapState(slot.agent) === 'dead') {
        addTombstone(buildTombstone(slot.agent, slot, nowMs), nowMs);
      }
    });
    updateAgentsList();
    storePreviousAgents(nextAgents);
    updateTimelineEntries();
    return;
  }

  transitions.forEach(transition => {
    const nextSlot = nextSlotsByKey.get(transition.key);
    if (transition.type === 'enter') {
      const nextState = nextSlot ? mapState(nextSlot.agent) : null;
      const shouldExit = !nextSlot || nextState === 'dead';
      if (shouldExit) {
        const tombstone = (nextSlot && nextState === 'dead') ? buildTombstone(nextSlot.agent, nextSlot, nowMs) : null;
        reverseTransition(transition, 'exit', DOOR_TILE, now, tombstone);
      } else {
        transition.agent = nextSlot.agent;
      }
      return;
    }
    if (transition.type === 'exit') {
      if (nextSlot && mapState(nextSlot.agent) !== 'dead') {
        reverseTransition(transition, 'enter', { x: nextSlot.desk.x, y: nextSlot.desk.y + 1 }, now, null);
        transition.agent = nextSlot.agent;
      } else if (nextSlot) {
        transition.agent = nextSlot.agent;
      }
    }
  });

  const transitionKeys = new Set(transitions.map(transition => transition.key));
  const deathSlots = [];
  nextSlotsByKey.forEach(slot => {
    const prevSlot = prevSlotsByKey.get(slot.key);
    if (!prevSlot) return;
    if (mapState(prevSlot.agent) === 'dead') return;
    if (mapState(slot.agent) === 'dead') {
      deathSlots.push({ slot, prevSlot });
    }
  });
  const enteringSlots = [];
  nextSlotsByKey.forEach(slot => {
    if (!prevSlotsByKey.has(slot.key)) enteringSlots.push(slot);
  });
  const exitingSlots = [];
  prevSlotsByKey.forEach(slot => {
    if (!nextSlotsByKey.has(slot.key)) exitingSlots.push(slot);
  });

  deathSlots.forEach(({ slot, prevSlot }) => {
    if (transitionKeys.has(slot.key)) return;
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'exit',
      start: { x: prevSlot.desk.x, y: prevSlot.desk.y + 1 },
      end: DOOR_TILE,
      startAt: now,
      colorIdx: prevSlot.idx,
      tombstone: buildTombstone(slot.agent, prevSlot, nowMs),
    }));
    transitionKeys.add(slot.key);
  });

  enteringSlots.forEach((slot, index) => {
    if (transitionKeys.has(slot.key)) return;
    if (mapState(slot.agent) === 'dead') {
      // Agent arrived already dead â€” place tombstone, no walking
      addTombstone(buildTombstone(slot.agent, slot, nowMs), nowMs);
      return;
    }
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'enter',
      start: DOOR_TILE,
      end: { x: slot.desk.x, y: slot.desk.y + 1 },
      startAt: now + index * ENTER_STAGGER * 1000,
      colorIdx: slot.idx,
    }));
  });

  exitingSlots.forEach(slot => {
    if (transitionKeys.has(slot.key)) return;
    const tombstone = mapState(slot.agent) === 'dead' ? buildTombstone(slot.agent, slot, nowMs) : null;
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'exit',
      start: { x: slot.desk.x, y: slot.desk.y + 1 },
      end: DOOR_TILE,
      startAt: now,
      colorIdx: slot.idx,
      tombstone,
    }));
  });

  agents = nextAgents;
  hasInitialized = true;
  updateAgentsList();
  storePreviousAgents(nextAgents);
  updateTimelineEntries();
}

function runtimeLabel(agent) {
  if (!agent || !agent.createdAt) return 'Unknown';
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 'Unknown';
  const diff = Math.max(0, Date.now() - ts);
  const isDone = isDoneState(mapState(agent));
  const verb = isDone ? 'Ran for' : 'Running for';
  return `${verb} ${formatDuration(diff)}`;
}

function formatRepoIssue(agent) {
  if (!agent) return 'Unknown';
  const repo = agent.repo || '';
  const issueId = getIssueId(agent);
  const title = (agent.issueTitle || '').toString().trim();
  if (repo && issueId) {
    return title ? `${repo} #${issueId} â€” ${title}` : `${repo} #${issueId}`;
  }
  if (repo) return title ? `${repo} â€” ${title}` : repo;
  return title || agent.id || 'Unknown';
}

function formatStatus(agent) {
  if (!agent) return 'unknown';
  const status = (agent.status || '').toString().trim();
  const activity = (agent.activity || '').toString().trim();
  if (status && activity && status !== activity) return `${status} (${activity})`;
  return status || activity || 'unknown';
}

function formatTokenCount(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return 'â€”';
  if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1).replace(/\.0$/, '')}m`;
  if (value >= 1_000) return `${(value / 1_000).toFixed(1).replace(/\.0$/, '')}k`;
  return `${Math.round(value)}`;
}

function formatTokenDetail(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return 'â€”';
  return Math.round(value).toLocaleString();
}

function formatUsageValue(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return 'â€”';
  return Math.round(value).toLocaleString();
}

function formatUsageRange(metric) {
  if (!metric) return 'â€”';
  // Anthropic format: utilization is a percentage directly
  if (metric.utilization !== null && metric.utilization !== undefined) {
    return `${Number(metric.utilization).toFixed(1)}%`;
  }
  const used = formatUsageValue(metric.used);
  const limit = formatUsageValue(metric.limit);
  const unit = metric.unit ? ` ${metric.unit}` : '';
  if (metric.unit === '%' && metric.limit === 100 && metric.used !== null && metric.used !== undefined) {
    return `${used}%`;
  }
  if (metric.limit !== null && metric.limit !== undefined) {
    return `${used} / ${limit}${unit}`;
  }
  if (metric.used !== null && metric.used !== undefined) {
    return `${used}${unit}`;
  }
  return 'â€”';
}

function usagePercent(metric) {
  if (!metric) return null;
  // Anthropic format: utilization is already a percentage (0-100)
  if (metric.utilization !== null && metric.utilization !== undefined) {
    return clamp(Number(metric.utilization) / 100, 0, 1);
  }
  if (metric.used === null || metric.used === undefined) return null;
  if (metric.limit === null || metric.limit === undefined || metric.limit === 0) return null;
  return clamp(metric.used / metric.limit, 0, 1);
}

function usageLevelFromPercent(percent) {
  if (percent === null || percent === undefined) return 'unknown';
  if (percent >= 0.95) return 'alert';
  if (percent >= 0.8) return 'warn';
  return 'ok';
}

function formatResetAt(value) {
  if (!value) return 'â€”';
  const ts = Date.parse(value);
  if (Number.isNaN(ts)) return 'â€”';
  return new Date(ts).toLocaleString();
}

function renderUsagePanel() {
  const panel = document.getElementById('usage-panel');
  const cards = document.getElementById('usage-cards');
  const updatedEl = document.getElementById('usage-updated');
  if (!panel || !cards || !updatedEl) return;

  if (!usageData || (!Array.isArray(usageData.providers) && !Array.isArray(usageData.usage))) {
    cards.innerHTML = '<div class="usage-meta">Usage unavailable.</div>';
    updatedEl.textContent = 'â€”';
    return;
  }

  const providers = Array.isArray(usageData.providers) ? usageData.providers : usageData.usage;
  if (!providers || providers.length === 0) {
    const errorText = usageData.error ? `Usage unavailable â€” ${usageData.error}` : 'Usage unavailable.';
    cards.innerHTML = `<div class="usage-meta">${escapeHtml(errorText)}</div>`;
    updatedEl.textContent = usageData.fetchedAt ? `Updated ${formatResetAt(usageData.fetchedAt)}` : 'â€”';
    return;
  }

  const updatedLabel = usageData.fetchedAt ? `Updated ${formatResetAt(usageData.fetchedAt)}` : 'â€”';
  updatedEl.textContent = updatedLabel;

  cards.innerHTML = providers.map((provider) => {
    const name = escapeHtml(provider.name || provider.id || 'Usage');
    const status = (provider.status || 'ok').toLowerCase();
    const isExhausted = provider.quotaStatus && provider.quotaStatus.exhausted;

    if (isExhausted) {
      const resetLabel = provider.quotaStatus.resetAt
        ? `Resets ${formatResetAt(provider.quotaStatus.resetAt)}`
        : 'Reset time unknown';
      return `
        <div class="usage-card exhausted">
          <div class="usage-title">
            <span>${name}</span>
            <span class="usage-pill exhausted">exhausted</span>
          </div>
          <div class="usage-metric">
            <div class="usage-row" style="color:#f5b3b3">\u26D4 Quota exhausted</div>
            <div class="usage-bar"><div class="usage-fill alert" style="width:100%"></div></div>
          </div>
          <div class="usage-meta">${escapeHtml(resetLabel)}</div>
        </div>
      `;
    }

    const metrics = Array.isArray(provider.metrics) ? provider.metrics : [];
    const percents = metrics.map(usagePercent).filter(p => p !== null);
    const highest = percents.length ? Math.max(...percents) : null;
    const level = usageLevelFromPercent(highest);
    const cardClass = level === 'warn' ? 'usage-card warn' : level === 'alert' ? 'usage-card alert' : 'usage-card';
    const pillClass = status === 'ok' ? (level === 'alert' ? 'usage-pill alert' : level === 'warn' ? 'usage-pill warn' : 'usage-pill ok') : 'usage-pill error';
    const pillLabel = status === 'ok' ? (level === 'alert' ? 'alert' : level === 'warn' ? 'warn' : 'ok') : 'error';
    const resetLabel = provider.resetAt ? `Reset ${formatResetAt(provider.resetAt)}` : 'Reset \u2014';
    const note = provider.note ? `<div class="usage-note">${escapeHtml(provider.note)}</div>` : '';
    const error = provider.error ? `<div class="usage-note">${escapeHtml(provider.error)}</div>` : '';

    const metricsHtml = metrics.map((metric) => {
      const percent = usagePercent(metric);
      const levelClass = usageLevelFromPercent(percent);
      const fillWidth = percent === null ? 100 : Math.round(percent * 100);
      const fillClass = percent === null ? 'usage-fill unknown' : levelClass === 'alert' ? 'usage-fill alert' : levelClass === 'warn' ? 'usage-fill warn' : 'usage-fill';
      const label = escapeHtml(metric.label || metric.id || 'Metric');
      const valueLabel = escapeHtml(formatUsageRange(metric) + (metric.estimated ? ' (est.)' : ''));
      return `
        <div class="usage-metric">
          <div class="usage-row"><span>${label}</span><span>${valueLabel}</span></div>
          <div class="usage-bar"><div class="${fillClass}" style="width:${fillWidth}%"></div></div>
        </div>
      `;
    }).join('');

    return `
      <div class="${cardClass}">
        <div class="usage-title">
          <span>${name}</span>
          <span class="${pillClass}">${pillLabel}</span>
        </div>
        ${metricsHtml || '<div class="usage-meta">No usage data available.</div>'}
        <div class="usage-meta">${escapeHtml(resetLabel)}</div>
        ${note || error}
      </div>
    `;
  }).join('');
}

function setUsageData(data) {
  usageData = data;
  renderUsagePanel();
}

async function refreshUsage() {
  try {
    const resp = await fetch('/api/usage');
    if (!resp.ok) throw new Error(`Usage fetch failed (${resp.status})`);
    const data = await resp.json();
    setUsageData(data);
  } catch (err) {
    setUsageData({ error: err.message, providers: [] });
  }
}

function formatCiState(agent) {
  const reaction = getReaction(agent);
  const retries = Number(reaction.ciRetries || 0);
  const status = (agent && agent.status ? agent.status : '').toLowerCase();
  const failing = !!reaction.ciEscalated || status.includes('ci_failed') || status.includes('failed');
  const state = failing ? 'failing' : 'passing';
  return `${state} (retries: ${retries})`;
}

function statusDotClass(agent) {
  if (!agent) return 'status-dead';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  const reaction = getReaction(agent);
  const state = mapState(agent);
  if (state === 'merged') return 'status-merged';
  if (state === 'pr_closed') return 'status-pr_closed';
  if (state === 'exited') return 'status-exited';
  if (state === 'dead') return 'status-dead';
  if (reaction.ciEscalated || status.includes('ci_failed') || status.includes('failed')) return 'status-ci';
  if (status.includes('pr_open') || status.includes('merged') || status.includes('ci') || activity.includes('stale') || state === 'waiting') {
    return 'status-waiting';
  }
  return 'status-active';
}

function buildTooltip(agent) {
  if (!agent) return '';
  const agentId = escapeHtml(agent.id || agent.label || 'agent');
  const agentType = escapeHtml(resolveAgentType(agent) || 'unknown');
  const repoIssue = escapeHtml(formatRepoIssue(agent));
  const status = escapeHtml(formatStatus(agent));
  const runtime = escapeHtml(runtimeLabel(agent));
  const branch = escapeHtml(agent.branch || 'unknown');
  const tokensUsed = getTokensUsed(agent);
  const tokensLabel = escapeHtml(formatTokenDetail(tokensUsed));
  const prNumber = agent.prNumber ?? '';
  const prUrl = agent.prUrl || '';
  const prLabel = prNumber !== '' && prNumber !== null ? `PR #${prNumber}` : (prUrl ? 'PR link' : 'â€”');
  const prValue = escapeHtml(prLabel + (prUrl ? ` â€” ${prUrl}` : ''));
  const ciState = escapeHtml(formatCiState(agent));
  return `
    <div class="tooltip-title">
      <span class="status-dot ${statusDotClass(agent)}"></span>
      <span>${agentId}</span>
    </div>
    <div class="tooltip-row"><span class="tooltip-label">Type</span><span class="tooltip-value">${agentType}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Repo/Issue</span><span class="tooltip-value">${repoIssue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Status</span><span class="tooltip-value">${status}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Runtime</span><span class="tooltip-value">${runtime}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Tokens</span><span class="tooltip-value">${tokensLabel}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">PR</span><span class="tooltip-value">${prValue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">CI</span><span class="tooltip-value">${ciState}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Branch</span><span class="tooltip-value">${branch}</span></div>
  `;
}

function hoursRunning(agent) {
  if (!agent || !agent.createdAt) return 0;
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 0;
  return Math.max(0, (Date.now() - ts) / 3600000);
}

function coffeeCount(agent) {
  const hours = hoursRunning(agent);
  if (hours < 1) return 0;
  if (hours < 2) return 1;
  if (hours < 4) return 2;
  return 3;
}

function buildLayout(list) {
  const items = list.map((agent, index) => {
    const repo = getRepoName(agent) || 'unknown';
    const state = mapState(agent);
    const category = completionCategory(agent);
    return {
      agent,
      repo,
      index,
      state,
      category,
      completedAt: completionTimestamp(agent),
      key: agentKey(agent, index),
    };
  });

  const activeItems = items.filter(item => !isDoneState(item.state));
  const mergedItems = items.filter(item => item.category === 'merged');
  const prClosedItems = items.filter(item => item.category === 'pr_closed');
  const exitedItems = items.filter(item => item.category === 'exited');
  const completedItems = items.filter(item => item.category);

  const includeKeys = new Set(activeItems.map(item => item.key));
  if (showCompleted) {
    const capacityLeft = Math.max(0, DESKS.length - activeItems.length);
    if (capacityLeft > 0 && completedItems.length > 0) {
      if (completedItems.length <= capacityLeft) {
        completedItems.forEach(item => includeKeys.add(item.key));
      } else {
        const evictCount = completedItems.length - capacityLeft;
        const prClosedOldest = prClosedItems.slice().sort((a, b) => a.completedAt - b.completedAt);
        const mergedOldest = mergedItems.slice().sort((a, b) => a.completedAt - b.completedAt);
        const exitedOldest = exitedItems.slice().sort((a, b) => a.completedAt - b.completedAt);
        const evictOrder = prClosedOldest.concat(mergedOldest).concat(exitedOldest);
        const evictSet = new Set(evictOrder.slice(0, evictCount).map(item => item.key));
        completedItems.forEach(item => {
          if (!evictSet.has(item.key)) includeKeys.add(item.key);
        });
      }
    }
  }

  const displayItems = items.filter(item => includeKeys.has(item.key));

  const groups = [];
  const byRepo = new Map();
  displayItems.forEach((item) => {
    const repo = item.repo || 'unknown';
    if (!byRepo.has(repo)) {
      const g = { repo, agents: [] };
      byRepo.set(repo, g);
      groups.push(g);
    }
    byRepo.get(repo).agents.push(item);
  });

  const ordered = [];
  groups.forEach(group => group.agents.forEach(item => ordered.push(item)));

  const slots = [];
  const deskAgents = new Array(DESKS.length).fill(null);
  const firstIndex = new Map();
  const maxCount = Math.min(ordered.length, DESKS.length);
  for (let i = 0; i < maxCount; i++) {
    const item = ordered[i];
    const desk = DESKS[i];
    const row = Math.floor(i / DESK_COLS);
    const col = i % DESK_COLS;
    const key = item.key;
    const slot = { ...item, idx: i, desk, row, col, key };
    slots.push(slot);
    deskAgents[i] = slot;
    if (!firstIndex.has(item.repo)) firstIndex.set(item.repo, i);
  }

  const labels = [];
  for (const [repo, idx] of firstIndex.entries()) {
    const slot = slots[idx];
    if (slot) labels.push({ repo, desk: slot.desk, row: slot.row, col: slot.col });
  }

  const dividers = [];
  for (let i = 1; i < slots.length; i++) {
    if (slots[i].repo !== slots[i - 1].repo && slots[i].row === slots[i - 1].row) {
      dividers.push({ left: slots[i - 1], right: slots[i] });
    }
  }

  const overflow = ordered.slice(DESKS.length);

  return { slots, deskAgents, labels, dividers, overflow };
}

// === DRAW OFFICE ===
function drawFloor() {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      fillTile(x, y, (x + y) % 2 === 0 ? PAL.floor : PAL.floorAlt);
    }
  }
  // top wall
  for (let x = 0; x < COLS; x++) {
    fillTile(x, 0, PAL.wall);
    drawRect(x * TILE, 0, TILE, 4, PAL.wallTop);
  }
  drawWindow();
}

function drawWindow() {
  if (!timeState) return;
  const px = WINDOW.x * TILE;
  const py = WINDOW.y * TILE + 2;
  const w = WINDOW.w * TILE;
  const h = 10;
  const innerX = px + 1;
  const innerY = py + 1;
  const innerW = w - 2;
  const innerH = h - 2;

  drawRect(px, py, w, h, PAL.wallTop);
  drawRect(innerX, innerY, innerW, innerH, PAL.windowSky);
  drawRect(px + Math.floor(w / 2) - 1, innerY, 2, innerH, PAL.wall);

  if (timeState.starAlpha > 0.05) {
    const now = new Date();
    const starSeed = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
    ensureWindowStars(starSeed, innerW, innerH);
    ctx.save();
    ctx.globalAlpha = timeState.starAlpha;
    windowStars.forEach(star => {
      drawRect(innerX + star.x, innerY + star.y, 1, 1, PAL.star);
    });
    ctx.restore();
  }

  if (timeState.sunAlpha > 0.05) {
    ctx.save();
    ctx.globalAlpha = timeState.sunAlpha;
    drawRect(innerX + innerW - 5, innerY + 2, 3, 3, PAL.windowSun);
    ctx.restore();
  }
}

function drawDoor() {
  const px = DOOR_TILE.x * TILE;
  const py = DOOR_TILE.y * TILE;
  drawRect(px + 1, py + 1, 14, 14, '#7a4b1f');
  drawRect(px + 11, py + 8, 2, 2, '#d8c28a');
}

function drawLampGlow(tileX, tileY, intensity) {
  if (intensity <= 0) return;
  const cx = (tileX * TILE + 9) * SCALE;
  const cy = (tileY * TILE + 7) * SCALE;
  const radius = 7 * SCALE;
  ctx.save();
  ctx.globalAlpha = 0.18 * intensity;
  ctx.fillStyle = PAL.lampGlow;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawMonitorGlow(tileX, tileY, intensity) {
  if (intensity <= 0) return;
  const cx = (tileX * TILE + 4 + MONITOR.screenX + MONITOR.screenW / 2) * SCALE;
  const cy = (tileY * TILE + MONITOR.screenY + MONITOR.screenH / 2) * SCALE;
  const radius = 6 * SCALE;
  ctx.save();
  ctx.globalAlpha = 0.16 * intensity;
  ctx.fillStyle = PAL.monitorScreenActive;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawMonitorCheck(screenX, screenY, color) {
  drawRect(screenX + 1, screenY + 2, 1, 1, color);
  drawRect(screenX + 2, screenY + 3, 1, 1, color);
  drawRect(screenX + 3, screenY + 2, 1, 1, color);
  drawRect(screenX + 4, screenY + 1, 1, 1, color);
}

function drawMonitorX(screenX, screenY, color) {
  drawRect(screenX + 1, screenY + 1, 1, 1, color);
  drawRect(screenX + 4, screenY + 1, 1, 1, color);
  drawRect(screenX + 2, screenY + 2, 2, 1, color);
  drawRect(screenX + 1, screenY + 3, 1, 1, color);
  drawRect(screenX + 4, screenY + 3, 1, 1, color);
}

function drawMonitor(dx, dy, agent, state, frame) {
  const baseX = dx * TILE + 4;
  const baseY = dy * TILE;
  const reaction = getReaction(agent);
  const ciRetries = Number(reaction.ciRetries || 0);
  const ciEscalated = !!reaction.ciEscalated;
  const reviewWaiting = state === 'review_waiting';
  const active = state === 'coding' || reviewWaiting;
  const merged = state === 'merged';
  const prClosed = state === 'pr_closed';
  const exited = state === 'exited';
  const screenColor = merged
    ? PAL.badgeGold
    : (prClosed
      ? '#2a1535'
      : (exited
        ? PAL.monitorScreenCiDark
        : (reviewWaiting
          ? PAL.monitorScreenActive
          : (ciEscalated
            ? (frame % 20 < 10 ? PAL.monitorScreenCi : PAL.monitorScreenCiDark)
            : (active ? PAL.monitorScreenActive : PAL.monitorScreen)))));

  if (timeState && timeState.monitorGlow > 0 && agent && state !== 'dead') {
    drawMonitorGlow(dx, dy, timeState.monitorGlow);
  }

  drawRect(baseX, baseY, MONITOR.w, MONITOR.h, PAL.monitor);
  drawRect(baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, screenColor);
  drawRect(baseX + (MONITOR.w - MONITOR.standW) / 2, baseY + MONITOR.h, MONITOR.standW, MONITOR.standH, PAL.monitor);

  if (merged) {
    drawMonitorCheck(baseX + MONITOR.screenX, baseY + MONITOR.screenY, PAL.badgeGreen);
  } else if (prClosed) {
    drawMonitorX(baseX + MONITOR.screenX, baseY + MONITOR.screenY, '#9966aa');
  } else if (!exited) {
    const textColor = ciEscalated ? '#ffe6e6' : (active ? '#0b2' : '#5fbf6a');
    drawMonitorText(getMonitorText(agent), baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, frame, textColor);
  }

  if (ciRetries > 0 && !merged && !prClosed && !exited) {
    drawFire(baseX + MONITOR.screenX, baseY + MONITOR.screenY, frame);
  }
}

function drawDeskFlash(dx, dy, intensity) {
  const alpha = Math.min(0.6, 0.15 + intensity * 0.45);
  const baseX = dx * TILE + 4;
  const baseY = dy * TILE;
  ctx.save();
  ctx.globalAlpha = alpha;
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.badgeGold);
  drawRect(baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, PAL.badgeGold);
  ctx.restore();
}

function drawDeskTint(dx, dy, alpha = 0.35) {
  ctx.save();
  ctx.globalAlpha = alpha;
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.badgeGold);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.badgeGold);
  ctx.restore();
}

function drawDesk(dx, dy, agent, state, frame, flash = 0) {
  if (timeState && timeState.lamp > 0 && agent && state !== 'dead') {
    drawLampGlow(dx, dy, timeState.lamp);
  }
  // desk surface
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.desk);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.deskTop);
  if (state === 'merged') {
    drawDeskTint(dx, dy);
  }
  // monitor
  drawMonitor(dx, dy, agent, state, frame);
  // chair (below desk)
  drawRect(dx * TILE + 5, (dy + 1) * TILE + 2, 6, 5, PAL.chair);

  const count = coffeeCount(agent);
  if (count > 0) {
    drawCoffeeCups(dx, dy, count, frame);
  }

  if (flash > 0) {
    drawDeskFlash(dx, dy, flash);
  }
}

function drawTombstoneLabel(dx, dy, tombstone, alpha) {
  if (!tombstone) return;
  const lines = [tombstone.label, tombstone.duration];
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.font = '9px Courier New';
  const padding = 4;
  const lineHeight = 10;
  let textWidth = 0;
  lines.forEach(line => {
    textWidth = Math.max(textWidth, ctx.measureText(line).width);
  });
  const w = textWidth + padding * 2;
  const h = lines.length * lineHeight + 4;
  const x = (dx * TILE + 8) * SCALE - w / 2;
  const y = (dy * TILE - 6) * SCALE - h;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = PAL.tombstoneText;
  ctx.textAlign = 'center';
  lines.forEach((line, idx) => {
    ctx.fillText(line, x + w / 2, y + 10 + idx * lineHeight);
  });
  ctx.textAlign = 'left';
  ctx.restore();
}

function drawTombstone(dx, dy, tombstone, nowMs) {
  if (!tombstone) return;
  const alpha = tombstoneAlpha(tombstone, nowMs);
  if (alpha <= 0) return;
  const baseX = dx * TILE + 5;
  const baseY = (dy + 1) * TILE + 1;
  ctx.save();
  ctx.globalAlpha = alpha;
  drawRect(baseX + 1, baseY, 4, 1, PAL.tombstoneLight);
  drawRect(baseX, baseY + 1, 6, 5, PAL.tombstone);
  drawRect(baseX, baseY + 1, 1, 5, PAL.tombstoneDark);
  drawRect(baseX + 5, baseY + 1, 1, 5, PAL.tombstoneDark);
  drawRect(baseX + 1, baseY + 6, 4, 1, PAL.tombstoneDark);
  drawRect(baseX + 2, baseY + 3, 2, 1, PAL.tombstoneLight);
  drawRect(baseX + 2, baseY + 4, 2, 1, PAL.tombstoneLight);
  ctx.restore();
  drawTombstoneLabel(dx, dy, tombstone, alpha);
}

function drawCoffeeCups(dx, dy, count, frame) {
  const baseX = dx * TILE + 3;
  const baseY = dy * TILE + 5;
  for (let i = 0; i < count; i++) {
    const cupX = baseX + i * 4;
    drawRect(cupX, baseY, 3, 2, PAL.cup);
    drawRect(cupX + 1, baseY + 1, 1, 1, PAL.coffee);
    drawRect(cupX + 3, baseY + 1, 1, 1, PAL.cup);
  }

  if (count >= 3) {
    const steamX = baseX + (count - 1) * 4 + 1;
    const phase = frame % 20 < 10 ? 0 : 1;
    drawRect(steamX, baseY - 2 - phase, 1, 1, PAL.steam);
    drawRect(steamX + 1, baseY - 4 + phase, 1, 1, PAL.steam);
  }
}

function drawFire(screenX, screenY, frame) {
  const frames = [
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 2, c: PAL.fire2 }, { x: 3, y: 3, c: PAL.fire3 },
      { x: 4, y: 2, c: PAL.fire2 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 2, c: PAL.fire2 }, { x: 2, y: 3, c: PAL.fire1 }, { x: 3, y: 1, c: PAL.fire3 },
      { x: 4, y: 3, c: PAL.fire2 }, { x: 5, y: 2, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 1, c: PAL.fire3 }, { x: 3, y: 2, c: PAL.fire2 },
      { x: 4, y: 1, c: PAL.fire3 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
  ];
  const idx = frame % frames.length;
  frames[idx].forEach(p => drawRect(screenX + p.x, screenY + p.y, 1, 1, p.c));
}

function tokenBarColor(tokens) {
  if (tokens >= 100000) return PAL.tokenRed;
  if (tokens >= 50000) return PAL.tokenYellow;
  return PAL.tokenGreen;
}

function drawTokenBar(tileX, tileY, tokensUsed) {
  if (tokensUsed === null || tokensUsed === undefined) return;
  const tokens = Number(tokensUsed);
  if (!Number.isFinite(tokens)) return;
  const maxTokens = 100000;
  const barWidth = 12;
  const barHeight = 2;
  const px = tileX * TILE + 2;
  const py = tileY * TILE - 4;
  drawRect(px, py, barWidth, barHeight, PAL.tokenBg);
  const fill = Math.max(1, Math.round(barWidth * Math.min(tokens / maxTokens, 1)));
  drawRect(px, py, fill, barHeight, tokenBarColor(tokens));
}

function drawMonitorText(text, screenX, screenY, screenW, screenH, frame, color) {
  if (!text) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenX * SCALE, screenY * SCALE, screenW * SCALE, screenH * SCALE);
  ctx.clip();
  ctx.fillStyle = color;
  ctx.font = `${4 * SCALE}px Courier New`;
  ctx.textBaseline = 'top';
  const textWidth = ctx.measureText(text).width;
  const pad = 4 * SCALE;
  const scroll = (frame * 0.6) % (textWidth + screenW * SCALE + pad);
  const x = screenX * SCALE + screenW * SCALE - scroll;
  const y = screenY * SCALE + 1 * SCALE;
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawGroupDivider(leftDesk, rightDesk) {
  const midTileX = leftDesk.x + Math.floor((rightDesk.x - leftDesk.x) / 2);
  drawRect(midTileX * TILE + 7, leftDesk.y * TILE + 2, 2, 12, PAL.divider);
}

function drawGroupLabel(dx, dy, text) {
  if (!text) return;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(text).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 8) * SCALE - w / 2;
  const y = (dy * TILE - 14) * SCALE;
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = '#f0c040';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPrBadge(dx, dy, prNumber, merged) {
  const label = `PR #${prNumber}${merged ? ' âœ“' : ''}`;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(label).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 12) * SCALE - w / 2;
  const y = (dy * TILE - 12) * SCALE;
  ctx.fillStyle = merged ? PAL.badgeGold : PAL.badgeGreen;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = PAL.badgeText;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPlant(px, py) {
  drawRect(px * TILE + 6, py * TILE + 4, 4, 6, PAL.plantPot);
  drawRect(px * TILE + 3, py * TILE, 10, 5, PAL.plant);
  drawRect(px * TILE + 5, py * TILE - 2, 6, 3, PAL.plant);
}

// === DRAW CHARACTER ===
function drawCharacter(tileX, tileY, colorIdx, state, frame, agentType) {
  const base = CHAR_COLORS[colorIdx % CHAR_COLORS.length];
  const shirt = agentType === 'codex' ? '#3fbf3f' : (agentType === 'claude' ? '#f08b2e' : base.shirt);
  const c = { ...base, shirt };
  const px = tileX * TILE;
  const py = tileY * TILE;
  const bob = Math.sin(frame * 0.15) > 0 ? 0 : 1;
  const celebrating = state === 'merged';
  const prClosed = state === 'pr_closed';
  const slumped = state === 'exited';

  // body offset (sitting = higher up to align with chair)
  const sitting = state === 'coding' || state === 'reading' || state === 'waiting' || state === 'review_waiting' || celebrating || prClosed || slumped;
  const oy = sitting ? (celebrating ? -3 : (slumped ? -1 : -2)) : bob;
  const ox = celebrating ? -1 : 0;
  const headDrop = slumped ? 1 : 0;

  // legs
  if (!sitting) {
    const walk = state === 'walking';
    const legOff = walk ? (Math.sin(frame * 0.3) > 0 ? 1 : -1) : 0;
    drawRect(px + 5 + ox, py + 11 + oy, 2, 4, c.pants);
    drawRect(px + 9 + ox, py + 11 + oy + legOff, 2, 4, c.pants);
  } else {
    // seated legs forward
    drawRect(px + 4 + ox, py + 11 + oy, 8, 2, c.pants);
  }

  // torso
  drawRect(px + 4 + ox, py + 6 + oy, 8, 5, c.shirt);

  // head
  drawRect(px + 5 + ox, py + 1 + oy + headDrop, 6, 5, c.skin);
  // hair
  drawRect(px + 5 + ox, py + oy + headDrop, 6, 2, c.hair);
  // hoodie hints
  drawRect(px + 4 + ox, py + 3 + oy + headDrop, 1, 2, c.shirt);
  drawRect(px + 11 + ox, py + 3 + oy + headDrop, 1, 2, c.shirt);

  // arms
  if (state === 'coding') {
    // arms forward (typing)
    const armBob = frame % 6 < 3 ? 0 : 1;
    drawRect(px + 2 + ox, py + 7 + oy, 2, 3, c.shirt);
    drawRect(px + 12 + ox, py + 7 + oy + armBob, 2, 3, c.shirt);
    // hands on desk
    drawRect(px + 2 + ox, py + 10 + oy, 2, 1, c.skin);
    drawRect(px + 12 + ox, py + 10 + oy + armBob, 2, 1, c.skin);
  } else if (state === 'reading') {
    // hand on chin
    drawRect(px + 2 + ox, py + 7 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 7 + oy, 2, 2, c.shirt);
    drawRect(px + 12 + ox, py + 5 + oy, 2, 2, c.skin); // hand near face
  } else if (state === 'review_waiting') {
    // one arm raised with a slow wave
    const wave = frame % 40 < 20 ? 0 : 1;
    drawRect(px + 2 + ox, py + 6 + oy, 2, 4, c.shirt);
    const armY = py + oy - 1 + wave;
    drawRect(px + 12 + ox, armY, 2, 6, c.shirt);
    drawRect(px + 12 + ox, armY - 1, 2, 1, c.skin);
  } else if (celebrating) {
    // arms up (celebration pose)
    drawRect(px + 2 + ox, py + 1 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 1 + oy, 2, 4, c.shirt);
    drawRect(px + 2 + ox, py + oy, 2, 1, c.skin);
    drawRect(px + 12 + ox, py + oy, 2, 1, c.skin);
  } else if (slumped) {
    // arms droop (exited)
    drawRect(px + 2 + ox, py + 8 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 8 + oy, 2, 4, c.shirt);
    drawRect(px + 2 + ox, py + 11 + oy, 2, 1, c.skin);
    drawRect(px + 12 + ox, py + 11 + oy, 2, 1, c.skin);
  } else {
    // arms at sides
    drawRect(px + 2 + ox, py + 6 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 6 + oy, 2, 4, c.shirt);
  }

  // eyes
  const blinking = frame % 60 < 3;
  if (slumped) {
    drawRect(px + 6 + ox, py + 4 + oy + headDrop, 2, 1, '#222');
    drawRect(px + 9 + ox, py + 4 + oy + headDrop, 2, 1, '#222');
  } else if (!blinking) {
    drawRect(px + 6 + ox, py + 3 + oy + headDrop, 1, 1, '#222');
    drawRect(px + 9 + ox, py + 3 + oy + headDrop, 1, 1, '#222');
  }
}

// === SPEECH BUBBLE ===
function drawBubble(tileX, tileY, text, color = '#fff') {
  const px = tileX * TILE * SCALE;
  const py = (tileY * TILE - 10) * SCALE;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  const w = Math.max(text.length * 6 + 8, 30);
  ctx.fillRect(px - w/2 + S/2, py - 14, w, 14);
  ctx.fillStyle = color;
  ctx.font = '10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(text, px + S/2, py - 4);
  ctx.textAlign = 'left';
}

function getCelebrationOrigin(slot) {
  if (!slot) return { x: 0, y: 0 };
  const x = slot.desk.x * TILE + 8;
  const y = (slot.desk.y + 1) * TILE + 6;
  return { x, y };
}

function getConfettiParticle() {
  return confettiPool.pop() || {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    color: '#fff',
    life: 0,
    maxLife: 0,
    size: CONFETTI_SIZE,
  };
}

function emitConfetti(x, y) {
  const count = CONFETTI_COUNT_MIN + Math.floor(Math.random() * (CONFETTI_COUNT_MAX - CONFETTI_COUNT_MIN + 1));
  for (let i = 0; i < count; i++) {
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 2);
    const speed = 30 + Math.random() * 50;
    const particle = getConfettiParticle();
    particle.x = x + (Math.random() - 0.5) * 6;
    particle.y = y + (Math.random() - 0.5) * 4;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.color = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
    particle.life = CONFETTI_LIFE;
    particle.maxLife = CONFETTI_LIFE;
    particle.size = CONFETTI_SIZE;
    confettiActive.push(particle);
  }
}

function updateConfetti(dt) {
  for (let i = confettiActive.length - 1; i >= 0; i--) {
    const p = confettiActive[i];
    p.life -= dt;
    if (p.life <= 0) {
      confettiActive[i] = confettiActive[confettiActive.length - 1];
      confettiActive.pop();
      confettiPool.push(p);
      continue;
    }
    p.vy += CONFETTI_GRAVITY * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
}

function drawConfetti() {
  if (!confettiActive.length) return;
  ctx.save();
  for (const p of confettiActive) {
    const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));
    ctx.globalAlpha = alpha;
    drawRect(p.x, p.y, p.size, p.size, p.color);
  }
  ctx.restore();
}

function startCelebration(slot, now) {
  if (!slot) return;
  const origin = getCelebrationOrigin(slot);
  emitConfetti(origin.x, origin.y);
  const text = Math.random() < 0.5 ? 'ðŸŽ‰' : 'âœ“';
  const celebration = {
    key: slot.key,
    x: origin.x,
    y: origin.y,
    text,
    startAt: now,
  };
  celebrations.push(celebration);
  celebrationByKey.set(slot.key, celebration);
  playDing();
}

function updateCelebrations(now, dt) {
  updateConfetti(dt);
  for (let i = celebrations.length - 1; i >= 0; i--) {
    const c = celebrations[i];
    if (now - c.startAt > CELEBRATION_TOTAL_DURATION) {
      celebrations[i] = celebrations[celebrations.length - 1];
      celebrations.pop();
      if (celebrationByKey.get(c.key) === c) celebrationByKey.delete(c.key);
    }
  }
}

function celebrationFlashIntensity(key, now) {
  const c = celebrationByKey.get(key);
  if (!c) return 0;
  const elapsed = now - c.startAt;
  if (elapsed < 0 || elapsed > CELEBRATION_FLASH_DURATION) return 0;
  return 1 - elapsed / CELEBRATION_FLASH_DURATION;
}

function drawCelebrationText(now) {
  if (!celebrations.length) return;
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.font = `${8 * SCALE}px Courier New`;
  ctx.fillStyle = '#f0c040';
  for (const c of celebrations) {
    const elapsed = now - c.startAt;
    if (elapsed < 0) continue;
    const progress = Math.min(1, elapsed / CELEBRATION_TEXT_DURATION);
    const alpha = progress < 0.2 ? progress / 0.2 : (progress > 0.8 ? (1 - progress) / 0.2 : 1);
    const rise = 10 * progress;
    ctx.globalAlpha = Math.max(0, alpha);
    ctx.fillText(c.text, c.x * SCALE, (c.y - 6 - rise) * SCALE);
  }
  ctx.restore();
}

// === TIMELINE ===
function timelineStatusLabel(status, activity) {
  const s = (status || '').toLowerCase();
  const a = (activity || '').toLowerCase();
  if (s.includes('merged') || a.includes('merged')) return 'Merged';
  if (s.includes('ci_failed') || s.includes('failed')) return 'CI Failed';
  if (s.includes('ci_passed') || s.includes('passed')) return 'CI Passed';
  if (s.includes('pr_open') || s.includes('pr_review') || s.includes('changes_requested')) return 'PR Open';
  if (s.includes('pr_closed') || a.includes('pr_closed')) return 'PR Closed';
  if (s.includes('dead') || s.includes('exited') || s.includes('archived')) return 'Exited';
  if (s.includes('working') || s.includes('running') || a.includes('active')) return 'Working';
  return status || activity || 'Unknown';
}

function timelineColorForStatus(status, activity) {
  const s = (status || '').toLowerCase();
  const a = (activity || '').toLowerCase();
  if (s.includes('merged') || a.includes('merged')) return TIMELINE_COLORS.merged;
  if (s.includes('pr_closed') || a.includes('pr_closed')) return TIMELINE_COLORS.prClosed;
  if (
    s.includes('dead') ||
    s.includes('exited') ||
    s.includes('archived') ||
    a.includes('dead') ||
    a.includes('exited')
  ) return TIMELINE_COLORS.dead;
  if (s.includes('ci_failed') || s.includes('failed')) return TIMELINE_COLORS.ciFailed;
  if (s.includes('pr_open') || s.includes('pr_review') || s.includes('changes_requested') || s.includes('ci')) return TIMELINE_COLORS.pr;
  if (s.includes('working') || s.includes('running') || a.includes('active')) return TIMELINE_COLORS.working;
  return TIMELINE_COLORS.working;
}

function fitText(ctx, text, maxWidth) {
  if (ctx.measureText(text).width <= maxWidth) return text;
  let clipped = text;
  while (clipped.length > 3 && ctx.measureText(`${clipped}...`).width > maxWidth) {
    clipped = clipped.slice(0, -1);
  }
  return `${clipped}...`;
}

function buildTimelineEvents(entry, now) {
  const events = [];
  if (entry && Array.isArray(entry.statusHistory)) {
    entry.statusHistory.forEach((item) => {
      const at = coerceMs(item.at);
      if (at) events.push({ at, status: item.status || '', activity: item.activity || '' });
    });
  }
  if (!events.length) {
    const createdAt = coerceMs(entry.createdAt) || now;
    events.push({ at: createdAt, status: entry.status || '', activity: entry.activity || '' });
  }
  events.sort((a, b) => a.at - b.at);
  return events;
}

function buildTimelineSegments(entry, now) {
  const events = buildTimelineEvents(entry, now);
  const endedAt = coerceMs(entry.endedAt);
  const endTs = endedAt || now;
  const segments = [];
  for (let i = 0; i < events.length; i++) {
    const current = events[i];
    const next = events[i + 1];
    const start = current.at;
    const end = next ? next.at : endTs;
    if (!start || !end || end <= start) continue;
    segments.push({
      start,
      end,
      status: current.status,
      activity: current.activity,
    });
  }
  return segments;
}

function buildTimelineMarkers(entry, events, now) {
  const markers = [];
  const createdAt = coerceMs(entry.createdAt) || (events[0] && events[0].at) || now;
  markers.push({ at: createdAt, type: 'spawn', label: 'Spawned', color: '#ffffff' });
  let sawPr = false;
  let sawCiFail = false;
  let sawCiPass = false;
  let sawMerge = false;
  events.forEach((event) => {
    const status = (event.status || '').toLowerCase();
    if (!sawPr && status.includes('pr_open')) {
      sawPr = true;
      markers.push({ at: event.at, type: 'pr', label: 'PR Opened', color: TIMELINE_COLORS.pr });
    }
    if (!sawCiFail && (status.includes('ci_failed') || status.includes('failed'))) {
      sawCiFail = true;
      markers.push({ at: event.at, type: 'ci_failed', label: 'CI Failed', color: TIMELINE_COLORS.ciFailed });
    }
    if (!sawCiPass && status.includes('ci_pass')) {
      sawCiPass = true;
      markers.push({ at: event.at, type: 'ci_passed', label: 'CI Passed', color: TIMELINE_COLORS.pr });
    }
    if (!sawMerge && status.includes('merged')) {
      sawMerge = true;
      markers.push({ at: event.at, type: 'merged', label: 'Merged', color: TIMELINE_COLORS.merged });
    }
  });
  const endedAt = coerceMs(entry.endedAt);
  if (endedAt && !sawMerge) {
    markers.push({ at: endedAt, type: 'ended', label: 'Ended', color: TIMELINE_COLORS.dead });
  }
  return markers;
}

function computeTimelineWindow(entries, now) {
  const oneHour = 60 * 60 * 1000;
  const day = 24 * 60 * 60 * 1000;
  let earliest = now - oneHour;
  entries.forEach((entry) => {
    const createdAt = coerceMs(entry.createdAt);
    if (createdAt) earliest = Math.min(earliest, createdAt);
    if (Array.isArray(entry.statusHistory)) {
      entry.statusHistory.forEach((item) => {
        const at = coerceMs(item.at);
        if (at) earliest = Math.min(earliest, at);
      });
    }
  });
  let range = clamp(now - earliest, oneHour, day);
  return { start: now - range, end: now, range };
}

function chooseTickMs(rangeMs) {
  const minute = 60 * 1000;
  const hour = 60 * minute;
  if (rangeMs <= 2 * hour) return 15 * minute;
  if (rangeMs <= 6 * hour) return 30 * minute;
  if (rangeMs <= 12 * hour) return hour;
  return 2 * hour;
}

function formatTimelineTime(ts) {
  return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatTimelineLabel(entry, now) {
  const repo = entry.repo || '';
  const issueId = entry.issueId || '';
  const base = (repo && issueId) ? `${repo}#${issueId}` : (entry.id || 'agent');
  const createdAt = coerceMs(entry.createdAt);
  if (createdAt) {
    const endTs = coerceMs(entry.endedAt) || now || Date.now();
    return `${base} (${formatDuration(endTs - createdAt)})`;
  }
  return base;
}

function buildTimelineTooltip(entry, marker) {
  const title = escapeHtml(formatTimelineLabel(entry, Date.now()));
  const repoIssue = escapeHtml(formatRepoIssue(entry));
  const status = escapeHtml(timelineStatusLabel(entry.status, entry.activity));
  const createdAt = coerceMs(entry.createdAt);
  const endedAt = coerceMs(entry.endedAt);
  const createdLabel = createdAt ? new Date(createdAt).toLocaleString() : 'â€”';
  const endedLabel = endedAt ? new Date(endedAt).toLocaleString() : 'â€”';
  const eventLabel = marker ? `${marker.label} â€” ${new Date(marker.at).toLocaleString()}` : 'â€”';
  return `
    <div class="tooltip-title">
      <span class="status-dot ${statusDotClass(entry)}"></span>
      <span>${title}</span>
    </div>
    <div class="tooltip-row"><span class="tooltip-label">Repo/Issue</span><span class="tooltip-value">${repoIssue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Status</span><span class="tooltip-value">${status}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Created</span><span class="tooltip-value">${escapeHtml(createdLabel)}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Ended</span><span class="tooltip-value">${escapeHtml(endedLabel)}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Event</span><span class="tooltip-value">${escapeHtml(eventLabel)}</span></div>
  `;
}

function drawTimelineLegend(x, y) {
  const items = [
    { label: 'Working', color: TIMELINE_COLORS.working },
    { label: 'PR Open', color: TIMELINE_COLORS.pr },
    { label: 'CI Failed', color: TIMELINE_COLORS.ciFailed },
    { label: 'Merged', color: TIMELINE_COLORS.merged },
    { label: 'PR Closed', color: TIMELINE_COLORS.prClosed },
    { label: 'Dead', color: TIMELINE_COLORS.dead },
  ];
  let cursor = x;
  ctx.font = '10px Courier New';
  ctx.textBaseline = 'middle';
  items.forEach((item) => {
    ctx.fillStyle = item.color;
    ctx.fillRect(cursor, y - 4, 10, 6);
    ctx.fillStyle = TIMELINE_COLORS.label;
    ctx.fillText(item.label, cursor + 14, y + 1);
    cursor += 14 + ctx.measureText(item.label).width + 12;
  });
}

function drawTimeline(now) {
  const entries = timelineEntries;
  const y = TIMELINE_Y;
  ctx.fillStyle = '#12121c';
  ctx.fillRect(0, y, CANVAS_W, TIMELINE_HEIGHT);
  ctx.fillStyle = '#0b0b12';
  ctx.fillRect(0, y, CANVAS_W, TIMELINE_HEADER_HEIGHT);

  drawTimelineLegend(12, y + Math.floor(TIMELINE_LEGEND_HEIGHT / 2));

  const { start, end, range } = computeTimelineWindow(entries, now);
  const tickMs = chooseTickMs(range);
  const barX = TIMELINE_LABEL_WIDTH;
  const barW = CANVAS_W - TIMELINE_LABEL_WIDTH - TIMELINE_PADDING;
  const contentTop = y + TIMELINE_HEADER_HEIGHT + TIMELINE_PADDING;
  const contentHeight = TIMELINE_HEIGHT - TIMELINE_HEADER_HEIGHT - TIMELINE_PADDING * 2;
  const axisTop = y + TIMELINE_LEGEND_HEIGHT;
  const axisLabelY = axisTop + TIMELINE_AXIS_HEIGHT - 4;
  const axisLineY = axisTop + TIMELINE_AXIS_HEIGHT - 2;

  ctx.save();
  ctx.beginPath();
  ctx.rect(barX, contentTop, barW, contentHeight);
  ctx.clip();

  ctx.strokeStyle = TIMELINE_COLORS.grid;
  ctx.lineWidth = 1;
  for (let t = Math.ceil(start / tickMs) * tickMs; t <= end; t += tickMs) {
    const x = barX + ((t - start) / range) * barW;
    ctx.beginPath();
    ctx.moveTo(x, contentTop);
    ctx.lineTo(x, contentTop + contentHeight);
    ctx.stroke();
  }

  const nowX = barX + ((end - start) / range) * barW;
  ctx.strokeStyle = TIMELINE_COLORS.now;
  ctx.beginPath();
  ctx.moveTo(nowX, contentTop);
  ctx.lineTo(nowX, contentTop + contentHeight);
  ctx.stroke();

  ctx.restore();

  ctx.fillStyle = TIMELINE_COLORS.axis;
  ctx.fillRect(barX, axisLineY, barW, 2);
  ctx.fillRect(barX - 1, contentTop, 1, contentHeight);

  ctx.fillStyle = TIMELINE_COLORS.label;
  ctx.font = '10px Courier New';
  ctx.textBaseline = 'bottom';
  for (let t = Math.ceil(start / tickMs) * tickMs; t <= end; t += tickMs) {
    const x = barX + ((t - start) / range) * barW;
    const label = formatTimelineTime(t);
    ctx.fillText(label, x - ctx.measureText(label).width / 2, axisLabelY);
  }

  const visibleEntries = entries.slice(timelineScroll, timelineScroll + TIMELINE_MAX_ROWS);
  const rows = [];

  ctx.font = '10px Courier New';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = TIMELINE_COLORS.label;
  visibleEntries.forEach((entry, rowIndex) => {
    const rowY = contentTop + rowIndex * TIMELINE_ROW_HEIGHT;
    const barY = rowY + Math.floor((TIMELINE_ROW_HEIGHT - TIMELINE_BAR_HEIGHT) / 2);
    const label = fitText(ctx, formatTimelineLabel(entry, now), TIMELINE_LABEL_WIDTH - 14);
    ctx.fillStyle = TIMELINE_COLORS.label;
    ctx.fillText(label, 8, rowY + TIMELINE_ROW_HEIGHT / 2);

    const segments = buildTimelineSegments(entry, now);
    segments.forEach((segment) => {
      const segStart = Math.max(segment.start, start);
      const segEnd = Math.min(segment.end, end);
      if (segEnd <= segStart) return;
      const segX = barX + ((segStart - start) / range) * barW;
      const segW = Math.max(1, ((segEnd - segStart) / range) * barW);
      ctx.fillStyle = timelineColorForStatus(segment.status, segment.activity);
      ctx.fillRect(segX, barY, segW, TIMELINE_BAR_HEIGHT);

      // Status segment labels for wide segments
      if (segW > 60) {
        const segLabel = timelineStatusLabel(segment.status, segment.activity);
        ctx.font = '8px Courier New';
        ctx.fillStyle = '#ffffff';
        ctx.textBaseline = 'middle';
        const labelW = ctx.measureText(segLabel).width;
        if (labelW < segW - 4) {
          ctx.fillText(segLabel, segX + (segW - labelW) / 2, barY + TIMELINE_BAR_HEIGHT / 2);
        }
        ctx.font = '10px Courier New';
      }
    });

    // End marker for finished agents
    const endedAt = coerceMs(entry.endedAt);
    if (endedAt && endedAt >= start && endedAt <= end) {
      const endX = barX + ((endedAt - start) / range) * barW;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(endX - 1, barY - 1, 2, TIMELINE_BAR_HEIGHT + 2);
    }

    // Start/end time labels on bars
    const entryStart = coerceMs(entry.createdAt) || (segments[0] && segments[0].start);
    if (entryStart && segments.length > 0) {
      const firstSegStart = Math.max(entryStart, start);
      const lastSegEnd = Math.min(segments[segments.length - 1].end, end);
      const totalBarX = barX + ((firstSegStart - start) / range) * barW;
      const totalBarEndX = barX + ((lastSegEnd - start) / range) * barW;
      const totalBarW = totalBarEndX - totalBarX;
      ctx.font = '8px Courier New';
      ctx.textBaseline = 'top';
      const timeY = barY + TIMELINE_BAR_HEIGHT + 1;
      // Start time
      if (totalBarW > 40 && firstSegStart >= start) {
        ctx.fillStyle = TIMELINE_COLORS.muted;
        ctx.fillText(formatTimelineTime(firstSegStart), totalBarX, timeY);
      }
      // End time (only for finished agents, and only if bar is wide enough)
      if (endedAt && totalBarW > 80) {
        const endLabel = formatTimelineTime(endedAt);
        ctx.fillStyle = TIMELINE_COLORS.muted;
        ctx.fillText(endLabel, totalBarEndX - ctx.measureText(endLabel).width, timeY);
      }
      ctx.font = '10px Courier New';
      ctx.textBaseline = 'middle';
    }

    const events = buildTimelineEvents(entry, now);
    const markers = buildTimelineMarkers(entry, events, now).map((marker) => {
      const mx = barX + ((marker.at - start) / range) * barW;
      const my = barY + Math.floor(TIMELINE_BAR_HEIGHT / 2);
      return { ...marker, x: mx, y: my };
    }).filter(marker => marker.x >= barX && marker.x <= barX + barW);

    markers.forEach((marker) => {
      ctx.fillStyle = marker.color;
      ctx.beginPath();
      ctx.arc(marker.x, marker.y + 1, 3, 0, Math.PI * 2);
      ctx.fill();
    });

    rows.push({
      entry,
      rowY,
      barY,
      barHeight: TIMELINE_BAR_HEIGHT,
      markers,
    });
  });

  timelineLayout = {
    start,
    end,
    range,
    barX,
    barW,
    contentTop,
    contentHeight,
    rows,
  };

  if (entries.length > TIMELINE_MAX_ROWS) {
    const scrollHint = `${timelineScroll + 1}-${Math.min(timelineScroll + TIMELINE_MAX_ROWS, entries.length)} of ${entries.length}`;
    ctx.fillStyle = TIMELINE_COLORS.muted;
    ctx.font = '10px Courier New';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`Scroll ${scrollHint}`, CANVAS_W - ctx.measureText(scrollHint).width - 8, y + TIMELINE_HEIGHT - 4);
  }
}

function isWorkingState(agent) {
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  return (
    status.includes('working') ||
    status.includes('running') ||
    status.includes('cloning') ||
    activity.includes('active')
  );
}

function isAgentActive(agent) {
  if (!agent) return false;
  if (typeof agent.alive === 'boolean') {
    return agent.alive && isWorkingState(agent);
  }
  return isWorkingState(agent);
}

// === USAGE PANEL ===
function usageBarColor(pct) {
  if (pct >= 95) return PAL.tokenRed;
  if (pct >= 80) return PAL.tokenYellow;
  return PAL.tokenGreen;
}

function formatResetTime(isoString) {
  if (!isoString) return '';
  try {
    const d = new Date(isoString);
    if (isNaN(d.getTime())) return '';
    const now = new Date();
    const diffMs = d.getTime() - now.getTime();
    if (diffMs <= 0) return 'now';
    const diffH = Math.floor(diffMs / 3600000);
    const diffM = Math.floor((diffMs % 3600000) / 60000);
    if (diffH >= 24) {
      const days = Math.floor(diffH / 24);
      return `${days}d ${diffH % 24}h`;
    }
    if (diffH > 0) return `${diffH}h ${diffM}m`;
    return `${diffM}m`;
  } catch (e) {
    return '';
  }
}

function drawUsageBar(x, y, width, height, pct, flashing) {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(x, y, width, height);
  const fillW = Math.max(0, Math.min(width, Math.round(width * pct / 100)));
  const color = usageBarColor(pct);
  if (flashing && pct >= 95 && frame % 30 < 15) {
    ctx.fillStyle = '#ff1a1a';
  } else {
    ctx.fillStyle = color;
  }
  ctx.fillRect(x, y, fillW, height);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, width, height);
}

function findProvider(data, id) {
  if (!data || !Array.isArray(data.providers)) return null;
  return data.providers.find(p => p.id === id) || null;
}

function getAnthropicMetrics(provider) {
  if (!provider || provider.status !== 'ok' || !Array.isArray(provider.metrics)) return [];
  if (provider.format === 'anthropic') {
    return provider.metrics.map(m => ({
      id: m.id, label: m.label,
      pct: Number(m.utilization) || 0,
      resetAt: m.resetAt,
    }));
  }
  return provider.metrics.map(m => {
    const pct = usagePercent(m);
    return { id: m.id, label: m.label || m.id, pct: pct !== null ? pct * 100 : null, resetAt: provider.resetAt };
  }).filter(m => m.pct !== null);
}

function drawUsagePanel() {
  const y = USAGE_PANEL_Y;
  ctx.fillStyle = '#0d0d18';
  ctx.fillRect(0, y, CANVAS_W, USAGE_PANEL_HEIGHT);
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, y, CANVAS_W, 1);

  const providers = usageData && Array.isArray(usageData.providers) ? usageData.providers : [];
  if (!usageData || (providers.length === 0 && !usageData.error)) {
    ctx.fillStyle = '#555';
    ctx.font = '10px Courier New';
    ctx.textBaseline = 'middle';
    ctx.fillText('Usage: waiting for data...', 10, y + USAGE_PANEL_HEIGHT / 2);
    return;
  }
  if (providers.length === 0 && usageData.error) {
    ctx.fillStyle = '#555';
    ctx.font = '10px Courier New';
    ctx.textBaseline = 'middle';
    ctx.fillText('Usage: ' + usageData.error, 10, y + USAGE_PANEL_HEIGHT / 2);
    return;
  }

  const leftX = 10;
  const barX = 80;
  const row1Y = y + 12;
  const row2Y = y + 30;
  ctx.font = '10px Courier New';
  ctx.textBaseline = 'middle';

  const claude = findProvider(usageData, 'claude-max');
  const claudeMetrics = claude ? getAnthropicMetrics(claude) : [];
  const fiveHour = claudeMetrics.find(m => m.id === 'five_hour');
  const sevenDay = claudeMetrics.find(m => m.id === 'seven_day');

  // Row 1: 5h window or first metric
  const m1 = fiveHour || claudeMetrics[0];
  if (m1) {
    const pct = m1.pct;
    const resetLabel = formatResetTime(m1.resetAt);
    ctx.fillStyle = pct >= 95 ? '#ff5c5c' : (pct >= 80 ? '#d1a128' : '#9aa0b5');
    ctx.fillText(m1.label || 'Claude', leftX, row1Y);
    drawUsageBar(barX, row1Y - USAGE_BAR_HEIGHT / 2, USAGE_BAR_WIDTH, USAGE_BAR_HEIGHT, pct, true);
    ctx.fillStyle = pct >= 95 ? '#ff5c5c' : (pct >= 80 ? '#d1a128' : '#c9cedf');
    ctx.fillText(pct.toFixed(1) + '%', barX + USAGE_BAR_WIDTH + 6, row1Y);
    if (resetLabel) {
      ctx.fillStyle = '#7b8096';
      ctx.fillText('resets ' + resetLabel, barX + USAGE_BAR_WIDTH + 50, row1Y);
    }
  } else if (claude && claude.error) {
    ctx.fillStyle = '#666';
    ctx.fillText('Claude: ' + claude.error, leftX, row1Y);
  }

  // Row 2: 7d window or second metric
  const m2 = sevenDay || (claudeMetrics.length > 1 ? claudeMetrics[1] : null);
  if (m2 && m2 !== m1) {
    const pct = m2.pct;
    const resetLabel = formatResetTime(m2.resetAt);
    ctx.fillStyle = pct >= 95 ? '#ff5c5c' : (pct >= 80 ? '#d1a128' : '#9aa0b5');
    ctx.fillText(m2.label || 'Claude', leftX, row2Y);
    drawUsageBar(barX, row2Y - USAGE_BAR_HEIGHT / 2, USAGE_BAR_WIDTH, USAGE_BAR_HEIGHT, pct, true);
    ctx.fillStyle = pct >= 95 ? '#ff5c5c' : (pct >= 80 ? '#d1a128' : '#c9cedf');
    ctx.fillText(pct.toFixed(1) + '%', barX + USAGE_BAR_WIDTH + 6, row2Y);
    if (resetLabel) {
      ctx.fillStyle = '#7b8096';
      ctx.fillText('resets ' + resetLabel, barX + USAGE_BAR_WIDTH + 50, row2Y);
    }
  }

  // Extra usage (right side, row 1)
  if (claude && claude.extraUsage && claude.extraUsage.is_enabled) {
    const limitCents = Number(claude.extraUsage.monthly_limit) || 0;
    const usedCents = Number(claude.extraUsage.used_credits) || 0;
    const limitUsd = (limitCents / 100).toFixed(2);
    const usedUsd = (usedCents / 100).toFixed(2);
    const extraPct = limitCents > 0 ? (usedCents / limitCents) * 100 : 0;
    const extraX = 370;
    ctx.fillStyle = '#9aa0b5';
    ctx.fillText('Extra', extraX, row1Y);
    drawUsageBar(extraX + 42, row1Y - USAGE_BAR_HEIGHT / 2, 80, USAGE_BAR_HEIGHT, extraPct, false);
    ctx.fillStyle = '#c9cedf';
    ctx.fillText('$' + usedUsd + '/$' + limitUsd, extraX + 42 + 80 + 6, row1Y);
  }

  // Codex provider (right side, row 2)
  const codex = findProvider(usageData, 'codex');
  if (codex && codex.quotaStatus && codex.quotaStatus.exhausted) {
    // Quota exhausted â€” show red blinking warning
    const codexX = 370;
    const blink = frame % 40 < 20;
    ctx.fillStyle = blink ? '#ff5c5c' : '#cc3333';
    ctx.fillText('\u26D4 Codex', codexX, row2Y);
    ctx.fillStyle = '#ff5c5c';
    const resetLabel = codex.quotaStatus.resetAt ? formatResetTime(codex.quotaStatus.resetAt) : '';
    const msg = resetLabel ? 'Quota exhausted \u2014 resets ' + resetLabel : 'Quota exhausted';
    ctx.fillText(msg, codexX + 52, row2Y);
  } else if (codex && codex.status === 'ok' && Array.isArray(codex.metrics)) {
    const tokenMetric = codex.metrics.find(m => m.id === 'tokens');
    const codexX = 370;
    ctx.fillStyle = '#9aa0b5';
    ctx.fillText('Codex', codexX, row2Y);
    ctx.fillStyle = '#c9cedf';
    if (tokenMetric && tokenMetric.used !== null) {
      const label = tokenMetric.limit
        ? formatTokenCount(tokenMetric.used) + '/' + formatTokenCount(tokenMetric.limit)
        : formatTokenCount(tokenMetric.used) + ' tokens';
      ctx.fillText(label + (tokenMetric.estimated ? ' (est.)' : ''), codexX + 42, row2Y);
    } else if (codex.note) {
      ctx.fillText(codex.note, codexX + 42, row2Y);
    }
  }

  // Warning indicators
  const codexExhausted = codex && codex.quotaStatus && codex.quotaStatus.exhausted;
  const maxPct = claudeMetrics.length ? Math.max(...claudeMetrics.map(m => m.pct)) : 0;
  if (maxPct >= 95 || codexExhausted) {
    const warnX = CANVAS_W - 70;
    const warnY = y + USAGE_PANEL_HEIGHT / 2;
    const blink = frame % 30 < 15;
    ctx.fillStyle = blink ? '#ff1a1a' : '#cc0000';
    ctx.font = 'bold 11px Courier New';
    ctx.textBaseline = 'middle';
    ctx.fillText('LIMIT!', warnX, warnY);
  } else if (maxPct >= 80) {
    const warnX = CANVAS_W - 60;
    const warnY = y + USAGE_PANEL_HEIGHT / 2;
    ctx.fillStyle = '#d1a128';
    ctx.font = 'bold 11px Courier New';
    ctx.textBaseline = 'middle';
    ctx.fillText('WARN', warnX, warnY);
  }
}

// === STATUS BAR ===
function drawStatusBar() {
  const y = USAGE_PANEL_Y + USAGE_PANEL_HEIGHT;
  ctx.fillStyle = '#0b0b12';
  ctx.fillRect(0, y, CANVAS_W, S);
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, y, CANVAS_W, 1);
  ctx.font = '11px Courier New';
  ctx.textBaseline = 'middle';
  let x = 8;
  ctx.fillStyle = '#c9cedf';
  const title = 'ðŸ¤  Corral';
  ctx.fillText(title, x, y + S / 2);
  x += ctx.measureText(title).width + 12;
  const activeCount = agents.filter(isAgentActive).length;
  const agentLabel = `${agents.length} agents`;
  ctx.fillText(agentLabel, x, y + S / 2);
  x += ctx.measureText(agentLabel).width + 12;
  const activeLabel = `${activeCount} active`;
  ctx.fillText(activeLabel, x, y + S / 2);
  x += ctx.measureText(activeLabel).width + 12;
  const dotColor = connectionState === 'connected'
    ? '#2f9a3d'
    : connectionState === 'connecting'
      ? '#d1a128'
      : '#6c6c6c';
  ctx.fillStyle = dotColor;
  ctx.fillRect(x, y + S / 2 - 3, 6, 6);
  x += 10;
  ctx.fillStyle = '#c9cedf';
  const connLabel = connectionState === 'connected'
    ? 'connected'
    : connectionState === 'connecting'
      ? 'connecting'
      : 'offline';
  ctx.fillText(connLabel, x, y + S / 2);
  x += ctx.measureText(connLabel).width + 12;
  const message = getStatusMessage();

  const lastUpdateLabel = lastUpdateAt ? lastUpdateAt.toLocaleTimeString() : 'â€”';
  const rightText = `Updated ${lastUpdateLabel}`;
  const rightWidth = ctx.measureText(rightText).width;
  const rightX = CANVAS_W - rightWidth - 8;
  if (message) {
    const messageWidth = ctx.measureText(message).width;
    const available = rightX - x - 8;
    if (available > messageWidth) {
      ctx.fillStyle = '#d1a128';
      ctx.fillText(message, x, y + S / 2);
    }
  }
  ctx.fillStyle = '#9aa0b5';
  ctx.fillText(rightText, rightX, y + S / 2);
}

// === MAP LASSO STATE â†’ ANIMATION STATE ===
function mapState(agent) {
  if (!agent) return 'idle';
  if (agent.endedAt || agent.ended_at) return 'dead';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  if (status.includes('merged') || activity.includes('merged')) return 'merged';
  if (status.includes('pr_closed') || activity.includes('pr_closed')) return 'pr_closed';
  if (
    status.includes('exited') ||
    activity.includes('exited') ||
    status.includes('archived') ||
    activity.includes('archived')
  ) return 'exited';
  if (status.includes('dead') || activity.includes('dead')) return 'dead';
  if (status.includes('pr_review') || status.includes('changes_requested')) return 'reading';
  if (status.includes('pr_open') && agent.alive === false) return 'review_waiting';
  if (status.includes('pr_open') || status.includes('ci') || activity.includes('stale')) return 'waiting';
  if (status.includes('working') || activity.includes('active')) return 'coding';
  return 'idle';
}

function isDoneState(state) {
  return state === 'dead' || state === 'merged' || state === 'exited' || state === 'pr_closed';
}

function stateLabel(state, agent) {
  switch(state) {
    case 'coding': return 'âŒ¨ï¸ coding';
    case 'reading': return 'ðŸ“– review';
    case 'review_waiting': return 'ðŸ™‹ needs review';
    case 'waiting': return 'â³ waiting';
    case 'merged': return 'ðŸŽ‰ merged';
    case 'pr_closed': return 'ðŸš« PR closed';
    case 'exited': return 'ðŸ’€ exited';
    case 'dead': return 'ðŸ’€ done';
    default: return 'ðŸ’¤ idle';
  }
}

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY,
  };
}

function isInTimelineArea(y) {
  return y >= TIMELINE_Y && y < TIMELINE_Y + TIMELINE_HEIGHT;
}

function handleTimelineHover(x, y, clientX, clientY) {
  if (!timelineLayout || !timelineLayout.rows.length) {
    hideTooltip();
    return;
  }
  const relativeY = y - timelineLayout.contentTop;
  if (relativeY < 0) {
    hideTooltip();
    return;
  }
  const rowIndex = Math.floor(relativeY / TIMELINE_ROW_HEIGHT);
  const row = timelineLayout.rows[rowIndex];
  if (!row) {
    hideTooltip();
    return;
  }
  let marker = null;
  const radius = 4;
  for (const m of row.markers) {
    if (Math.abs(x - m.x) <= radius && Math.abs(y - (m.y + 1)) <= radius) {
      marker = m;
      break;
    }
  }
  const signature = `timeline:${row.entry.id}:${marker ? marker.type + marker.at : 'row'}`;
  if (signature !== hoveredSignature) {
    tooltip.innerHTML = buildTimelineTooltip(row.entry, marker);
    hoveredSignature = signature;
  }
  timelineHover = { entry: row.entry, marker };
  tooltip.style.display = 'block';
  tooltip.setAttribute('aria-hidden', 'false');
  positionTooltip(clientX, clientY);
}

function deskIndexAt(x, y) {
  for (let i = 0; i < DESKS.length; i++) {
    const desk = DESKS[i];
    const left = desk.x * S;
    const top = desk.y * S;
    const width = S;
    const height = S * 2;
    if (x >= left && x <= left + width && y >= top && y <= top + height) {
      return i;
    }
  }
  return null;
}

function tooltipSignature(agent) {
  if (!agent) return '';
  const reaction = getReaction(agent);
  return [
    agent.id,
    agent.status,
    agent.activity,
    agent.prNumber,
    agent.prUrl,
    agent.branch,
    agent.issueId,
    agent.issueTitle,
    agent.repo,
    agent.agentType,
    agent.createdAt,
    agent.tokensUsed,
    reaction.ciRetries,
    reaction.ciEscalated,
  ].join('|');
}

function positionTooltip(clientX, clientY) {
  const padding = 12;
  const maxX = window.innerWidth - 8;
  const maxY = window.innerHeight - 8;
  let left = clientX + padding;
  let top = clientY + padding;
  const { offsetWidth: w, offsetHeight: h } = tooltip;
  if (left + w > maxX) left = clientX - w - padding;
  if (top + h > maxY) top = clientY - h - padding;
  tooltip.style.left = `${Math.max(8, left)}px`;
  tooltip.style.top = `${Math.max(8, top)}px`;
}

function showTooltip(agent, clientX, clientY) {
  const signature = tooltipSignature(agent);
  if (signature !== hoveredSignature) {
    tooltip.innerHTML = buildTooltip(agent);
    hoveredSignature = signature;
  }
  tooltip.style.display = 'block';
  tooltip.setAttribute('aria-hidden', 'false');
  positionTooltip(clientX, clientY);
}

function hideTooltip() {
  hoveredDeskIndex = null;
  hoveredAgent = null;
  hoveredSignature = '';
  timelineHover = null;
  tooltip.style.display = 'none';
  tooltip.setAttribute('aria-hidden', 'true');
}

// === MAIN RENDER LOOP ===
let frame = 0;
function render(now) {
  if (lastRenderTime === null) lastRenderTime = now;
  const dt = Math.min(0.05, (now - lastRenderTime) / 1000);
  lastRenderTime = now;
  frame++;
  updateTransitions(now, dt);
  updateCelebrations(now, dt);
  const nowMs = Date.now();
  pruneTombstones(nowMs);
  const nowTime = new Date();
  timeState = getTimeState(nowTime.getHours(), nowTime.getMinutes());
  PAL = timeState.palette;
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawFloor();
  drawDoor();

  const layout = buildLayout(agents);
  currentLayout = layout;
  const transitionByKey = new Map(transitions.map(transition => [transition.key, transition]));

  layout.dividers.forEach(divider => drawGroupDivider(divider.left.desk, divider.right.desk));

  // draw desks
  DESKS.forEach((d, i) => {
    const slot = layout.deskAgents[i];
    const agent = slot ? slot.agent : null;
    const transition = slot ? transitionByKey.get(slot.key) : null;
    let deskAgent = transition ? null : agent;
    let state = deskAgent ? mapState(deskAgent) : 'idle';
    if (state === 'dead') {
      deskAgent = null;
      state = 'idle';
    }
    const flash = slot ? celebrationFlashIntensity(slot.key, now) : 0;
    drawDesk(d.x, d.y, deskAgent, state, frame, flash);
    const tombstone = tombstonesByDesk.get(i);
    if ((deskAgent || transition) && tombstone) {
      removeTombstoneAtDesk(i);
    } else if (!deskAgent && !transition && tombstone) {
      drawTombstone(d.x, d.y, tombstone, nowMs);
    }
  });

  // decorative plants
  drawPlant(0, 2);
  drawPlant(0, 8);
  drawPlant(COLS - 1, 5);

  layout.labels.forEach(label => drawGroupLabel(label.desk.x, label.desk.y, label.repo));

  // draw agents at desks
  layout.slots.forEach((slot, i) => {
    const agent = slot.agent;
    const desk = slot.desk;
    const transition = transitionByKey.get(slot.key);
    if (transition) return;
    const state = mapState(agent);
    if (state === 'dead') return; // ghost desk
    drawCharacter(desk.x, desk.y + 1, slot.idx, state, frame, resolveAgentType(agent));
    drawTokenBar(desk.x, desk.y + 1, getTokensUsed(agent));
    const prNumber = agent ? agent.prNumber : null;
    const status = (agent.status || '').toLowerCase();
    if (prNumber !== null && prNumber !== undefined) {
      drawPrBadge(desk.x, desk.y, prNumber, status.includes('merged'));
    }
    // bubble with repo/issue
    const repo = getRepoName(agent);
    const issueId = getIssueId(agent);
    const label = issueId ? `${repo}#${issueId}` : (repo || agent.id || `agent-${i}`);
    const bubbleColor = state === 'review_waiting' ? '#8f8' : (state === 'waiting' ? '#ff0' : '#fff');
    drawBubble(desk.x, desk.y, label, bubbleColor);
  });

  // draw transitions
  transitions.forEach(transition => {
    if (now < transition.startAt) return;
    const pos = transitionPosition(transition, now);
    drawCharacter(pos.x, pos.y, transition.colorIdx, 'walking', frame, resolveAgentType(transition.agent));
  });

  drawConfetti();
  drawCelebrationText(now);
  drawTimeline(Date.now());
  drawUsagePanel();
  drawStatusBar();
  requestAnimationFrame(render);
}

// === DATA LOADING ===
function setHistoryEntries(list) {
  historyEntries = Array.isArray(list) ? list.map(normalizeHistoryEntry).filter(Boolean) : [];
  updateTimelineEntries();
}

function loadDemo() {
  const now = Date.now();
  const demoAgents = [
    {
      id: 'codex-1',
      repo: 'zall',
      issueId: '7',
      issueTitle: 'Tighten input validation',
      status: 'running',
      agentType: 'codex',
      tokensUsed: 24350,
      createdAt: new Date(now - 30 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-2',
      repo: 'zall',
      issueId: '12',
      issueTitle: 'Add rate limiting',
      status: 'pr_open',
      agentType: 'codex',
      prNumber: 42,
      alive: false,
      tokensUsed: 61200,
      createdAt: new Date(now - 2.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'claude-3',
      repo: 'lasso',
      issueId: '29',
      issueTitle: 'Refine lasso ingestion',
      status: 'running',
      agentType: 'claude',
      tokensUsed: 128400,
      createdAt: new Date(now - 5.5 * 60 * 60 * 1000).toISOString(),
      reactionState: { ciRetries: 2 },
    },
    {
      id: 'codex-4',
      repo: 'corral',
      issueId: '1',
      issueTitle: 'Rich visuals polish',
      status: 'ci_pending',
      agentType: 'codex',
      reactionState: { ciRetries: 3, ciEscalated: true },
      prNumber: 88,
      tokensUsed: 85400,
      createdAt: new Date(now - 4.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-5',
      repo: 'zall',
      issueId: '15',
      status: 'merged',
      agentType: 'codex',
      prNumber: 61,
      tokensUsed: 3220,
      createdAt: new Date(now - 90 * 60 * 1000).toISOString(),
    },
    {
      id: 'claude-6',
      repo: 'corral',
      issueId: '3',
      issueTitle: 'Fix liveness check',
      status: 'exited',
      agentType: 'claude',
      tokensUsed: 45200,
      createdAt: new Date(now - 3 * 60 * 60 * 1000).toISOString(),
      endedAt: new Date(now - 10 * 60 * 1000).toISOString(),
    },
  ];
  const demoHistory = demoAgents.map((agent) => {
    const createdAt = agent.createdAt;
    const createdTs = Date.parse(createdAt);
    const statusHistory = [
      { status: 'working', activity: '', at: createdAt },
    ];
    if ((agent.status || '').includes('pr_open')) {
      statusHistory.push({ status: 'pr_open', activity: '', at: new Date(createdTs + 45 * 60 * 1000).toISOString() });
    }
    if ((agent.status || '').includes('ci')) {
      statusHistory.push({ status: 'ci_failed', activity: '', at: new Date(createdTs + 75 * 60 * 1000).toISOString() });
    }
    if ((agent.status || '').includes('merged')) {
      statusHistory.push({ status: 'merged', activity: '', at: new Date(createdTs + 70 * 60 * 1000).toISOString() });
    }
    const endedAt = agent.endedAt
      || (statusHistory[statusHistory.length - 1].status === 'merged'
        ? statusHistory[statusHistory.length - 1].at
        : null);
    return {
      id: agent.id,
      repo: agent.repo,
      issueId: agent.issueId,
      issueTitle: agent.issueTitle,
      status: agent.status,
      agentType: agent.agentType,
      createdAt,
      endedAt,
      prNumber: agent.prNumber,
      statusHistory,
    };
  });
  setAgents(demoAgents);
  setHistoryEntries(demoHistory);
  const demoUsage = {
    fetchedAt: new Date(now).toISOString(),
    providers: [
      {
        id: 'claude-max',
        name: 'Claude Max',
        status: 'ok',
        format: 'anthropic',
        resetAt: new Date(now + 3 * 60 * 60 * 1000).toISOString(),
        metrics: [
          { id: 'five_hour', label: '5h window', utilization: 42.3, resetAt: new Date(now + 3 * 60 * 60 * 1000).toISOString() },
          { id: 'seven_day', label: '7d window', utilization: 68.7, resetAt: new Date(now + 4 * 24 * 60 * 60 * 1000).toISOString() },
        ],
        extraUsage: { is_enabled: true, monthly_limit: 10000, used_credits: 2750 },
      },
      {
        id: 'codex',
        name: 'Codex',
        status: 'ok',
        source: 'local',
        estimated: true,
        note: 'Estimated from active agent logs',
        metrics: [
          { id: 'tokens', label: 'Tokens', used: 340000, limit: null, unit: 'tokens', estimated: true },
        ],
      },
    ],
  };
  setUsageData(demoUsage);
}

async function refreshFromLasso() {
  if (connectionState !== 'connected') {
    setConnectionState('connecting', 'Connecting');
  }
  try {
    const [agentsResp, historyResp] = await Promise.all([
      fetch('/api/agents'),
      fetch('/api/history'),
    ]);
    if (!agentsResp.ok) throw new Error(`Agents fetch failed (${agentsResp.status})`);
    const data = await agentsResp.json();
    const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
    setAgents(nextAgents);
    if (historyResp.ok) {
      const historyData = await historyResp.json();
      const historyList = Array.isArray(historyData) ? historyData : (historyData.history || []);
      setHistoryEntries(historyList);
    }
    refreshUsage();
    lastUpdateAt = new Date();
    setConnectionState('connected', '');
    return true;
  } catch(e) {
    setConnectionState('disconnected', 'Server not running â€” start with: node server.js');
    return false;
  }
}

// Auto-poll every 5s
let polling = false;
async function startPolling() {
  if (polling) return;
  polling = true;
  setConnectionState('connecting', 'Connecting');
  while (polling) {
    await refreshFromLasso();
    await new Promise(r => setTimeout(r, 5000));
  }
}

function renderAgentPill(agent, index, extraClass = '') {
  if (!agent) return '';
  const name = escapeHtml(agent.id || agent.label || `agent-${index}`);
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  const repoLabel = escapeHtml(`${repo}${issueId ? '#' + issueId : ''}`);
  const state = mapState(agent);
  const stateText = escapeHtml(stateLabel(state, agent));
  const classes = ['agent-pill', `state-${state}`];
  if (extraClass) classes.push(extraClass);
  return `<div class="${classes.join(' ')}">
    <span class="agent-pill-name">${name}</span>
    <span class="agent-pill-repo">${repoLabel || 'â€”'}</span>
    <span class="agent-pill-state">${stateText}</span>
  </div>`;
}

function updateAgentsList() {
  const el = document.getElementById('agents-list');
  const queueEl = document.getElementById('queue-list');
  const summaryEl = document.getElementById('agents-summary');
  const layout = buildLayout(agents);
  const deskAgents = layout.slots.map(slot => slot.agent);
  const queued = (layout.overflow || []).map(item => item.agent);
  if (el) {
    const pills = deskAgents.map((a, i) => renderAgentPill(a, i)).join('');
    el.innerHTML = pills || '<div class="agents-empty">No active agents on desks.</div>';
  }
  if (queueEl) {
    queueEl.innerHTML = queued.length
      ? [
        `<div class="queue-title">Queue (${queued.length})</div>`,
        queued.map((a, i) => renderAgentPill(a, i, 'queued')).join(''),
      ].join('')
      : '';
  }
  const visibleCount = deskAgents.length + queued.length;
  const hiddenCount = Math.max(0, agents.length - visibleCount);
  if (summaryEl) {
    const summaryParts = [`${agents.length} total`];
    if (queued.length) summaryParts.push(`${queued.length} queued`);
    if (hiddenCount > 0) {
      summaryParts.push(showCompleted ? `${hiddenCount} evicted` : `${hiddenCount} hidden`);
    }
    summaryEl.textContent = summaryParts.join(' â€¢ ');
  }
}


canvas.addEventListener('mousemove', e => {
  const { x, y } = getCanvasPoint(e);
  if (isInTimelineArea(y)) {
    handleTimelineHover(x, y, e.clientX, e.clientY);
    return;
  }
  if (!currentLayout) return;
  const idx = deskIndexAt(x, y);
  if (idx === null) {
    hideTooltip();
    return;
  }
  const slot = currentLayout.deskAgents[idx];
  if (!slot || !slot.agent) {
    hideTooltip();
    return;
  }
  if (transitions.some(transition => transition.key === slot.key)) {
    hideTooltip();
    return;
  }
  hoveredDeskIndex = idx;
  hoveredAgent = slot.agent;
  showTooltip(slot.agent, e.clientX, e.clientY);
});

canvas.addEventListener('mouseleave', () => { hideTooltip(); hoveredAgent = null; });

canvas.addEventListener('click', e => {
  const pt = getCanvasPoint(e);
  if (isInTimelineArea(pt.y)) {
    if (timelineHover && timelineHover.entry) {
      const url = getAgentUrl(timelineHover.entry.source || timelineHover.entry);
      if (url) window.open(url, '_blank');
    }
    return;
  }
  // Use pinned hover agent to avoid race condition with layout refresh
  const agent = hoveredAgent;
  if (!agent) return;
  const url = getAgentUrl(agent);
  if (url) window.open(url, '_blank');
});

canvas.addEventListener('wheel', e => {
  const { x, y } = getCanvasPoint(e);
  if (!isInTimelineArea(y)) return;
  if (timelineEntries.length <= TIMELINE_MAX_ROWS) return;
  e.preventDefault();
  const direction = e.deltaY > 0 ? 1 : -1;
  const maxScroll = Math.max(0, timelineEntries.length - TIMELINE_MAX_ROWS);
  timelineScroll = clamp(timelineScroll + direction, 0, maxScroll);
}, { passive: false });

document.addEventListener('keydown', (e) => {
  if (e.repeat || e.metaKey || e.ctrlKey || e.altKey) return;
  const target = e.target;
  if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) return;
  const key = e.key.toLowerCase();
  if (key === 's') {
    toggleSound();
  } else if (key === 'c') {
    cleanCompleted();
  } else if (key === 'f') {
    toggleFullscreen();
  }
});

// start
updateSoundButton();
updateCompletedToggle();
setCleanButtonState(false);
updateConnectionIndicator();
renderUsagePanel();
requestAnimationFrame(render);
// auto-connect to live server
startPolling();
</script>
</body>
</html>
