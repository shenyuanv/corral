<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ü§†</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: 'Courier New', monospace; color: #e0e0e0; }
  h1 { font-size: 18px; margin-bottom: 8px; color: #f0c040; }
  canvas { border: 2px solid #333; image-rendering: pixelated; image-rendering: crisp-edges; cursor: default; }
  #info { margin-top: 8px; font-size: 12px; color: #888; }
  #agents-list { margin-top: 12px; font-size: 11px; max-width: 640px; }
  .agent-row { display: flex; gap: 8px; padding: 2px 0; }
  .agent-name { color: #f0c040; min-width: 80px; }
  .agent-status { color: #8f8; }
  .agent-repo { color: #88f; }
  #controls { margin-top: 10px; display: flex; gap: 8px; }
  button { background: #333; color: #e0e0e0; border: 1px solid #555; padding: 4px 12px; font-family: inherit; font-size: 11px; cursor: pointer; }
  button:hover { background: #444; }
</style>
</head>
<body>
<h1>ü§† Corral</h1>
<canvas id="office" width="640" height="400"></canvas>
<div id="info">Click "Load Agents" or drop agents.json to populate</div>
<div id="controls">
  <button onclick="loadAgentsFile()">Load agents.json</button>
  <button onclick="loadDemo()">Demo Mode</button>
  <button onclick="refreshFromLasso()">Refresh</button>
  <button onclick="startPolling()">‚ñ∂ Live</button>
  <button onclick="stopPolling()">‚èπ Stop</button>
</div>
<div id="agents-list"></div>

<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFile(event)">

<script>
// === CONSTANTS ===
const TILE = 16;
const SCALE = 2;
const S = TILE * SCALE; // rendered tile size
const COLS = 20;
const ROWS = 12; // 640x384 at scale 2
const DESK_COLS = 4;
const DESK_ROWS = 3;
const DESK_START_X = 2;
const DESK_START_Y = 2;
const DESK_GAP_X = 5;
const DESK_GAP_Y = 3;
const CANVAS_W = COLS * S;
const CANVAS_H = ROWS * S + S; // extra row for status bar

const canvas = document.getElementById('office');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// === COLORS (pixel art palette) ===
const PAL = {
  floor: '#3a3a5c',
  floorAlt: '#33334f',
  wall: '#5c5c8a',
  wallTop: '#7a7ab0',
  desk: '#8b6914',
  deskTop: '#c49b2a',
  monitor: '#222',
  monitorScreen: '#0f380f',
  monitorScreenActive: '#4ae04a',
  monitorScreenCi: '#ff3b3b',
  monitorScreenCiDark: '#7a1111',
  chair: '#444',
  plant: '#2d5a1e',
  plantPot: '#8b5e3c',
  divider: '#26263b',
  badgeGreen: '#2f9a3d',
  badgeGold: '#d1a128',
  badgeText: '#111',
  cup: '#d9d9d9',
  coffee: '#5a3a1a',
  steam: '#e5e5e5',
  fire1: '#f04',
  fire2: '#f80',
  fire3: '#ff0',
};

// === CHARACTER COLORS ===
const CHAR_COLORS = [
  { skin: '#f5c6a0', hair: '#4a2800', shirt: '#e04040', pants: '#3050a0' }, // red
  { skin: '#d4a373', hair: '#1a1a2e', shirt: '#4080e0', pants: '#2a2a4e' }, // blue
  { skin: '#f5deb3', hair: '#c04000', shirt: '#40c040', pants: '#404040' }, // green
  { skin: '#c49b6a', hair: '#222', shirt: '#e0a040', pants: '#3a3a5c' },   // gold
  { skin: '#f0d0b0', hair: '#604020', shirt: '#a040c0', pants: '#333' },    // purple
  { skin: '#e8c090', hair: '#802020', shirt: '#40c0c0', pants: '#2a2a4e' }, // teal
];

const MONITOR = {
  w: 8,
  h: 6,
  screenX: 1,
  screenY: 1,
  screenW: 6,
  screenH: 4,
  standW: 4,
  standH: 2,
};

// === DESK POSITIONS ===
const DESKS = [];
for (let row = 0; row < DESK_ROWS; row++) {
  for (let col = 0; col < DESK_COLS; col++) {
    DESKS.push({ x: DESK_START_X + col * DESK_GAP_X, y: DESK_START_Y + row * DESK_GAP_Y });
  }
}

// === AGENT STATE ===
let agents = [];
let currentLayout = null;

// === DRAWING HELPERS ===
function fillTile(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * S, y * S, S, S);
}

function drawRect(px, py, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(px * SCALE, py * SCALE, w * SCALE, h * SCALE);
}

// === DATA HELPERS ===
function getRepoName(agent) {
  if (!agent) return '';
  return (agent.repo || '').split('/').pop() || '';
}

function getIssueId(agent) {
  if (!agent) return '';
  return agent.issueId ?? agent.issue ?? agent.issueID ?? '';
}

function resolveAgentType(agent) {
  if (!agent) return '';
  return (agent.agentType || agent.agent || agent.type || '').toLowerCase();
}

function getMonitorText(agent) {
  if (!agent) return '';
  const issueTitle = (agent.issueTitle || '').toString().trim();
  if (issueTitle) return issueTitle;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  if (repo && issueId) return `${repo}#${issueId}`;
  return repo || agent.id || '';
}

function getReaction(agent) {
  return agent && agent.reactionState ? agent.reactionState : {};
}

function getAgentUrl(agent) {
  if (!agent) return '';
  const prUrl = agent.prUrl || agent.prURL || agent.pullRequestUrl || agent.pull_request_url;
  if (typeof prUrl === 'string' && prUrl.trim()) return prUrl.trim();
  const repo = typeof agent.repo === 'string' ? agent.repo.trim() : '';
  const issueId = getIssueId(agent);
  const issueIdStr = issueId !== null && issueId !== undefined ? String(issueId).trim() : '';
  if (repo && issueIdStr) return `https://github.com/${repo}/issues/${issueIdStr}`;
  return '';
}

function hoursRunning(agent) {
  if (!agent || !agent.createdAt) return 0;
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 0;
  return Math.max(0, (Date.now() - ts) / 3600000);
}

function coffeeCount(agent) {
  const hours = hoursRunning(agent);
  if (hours < 1) return 0;
  if (hours < 2) return 1;
  if (hours < 4) return 2;
  return 3;
}

function buildLayout(list) {
  const groups = [];
  const byRepo = new Map();
  list.forEach(agent => {
    const repo = getRepoName(agent) || 'unknown';
    if (!byRepo.has(repo)) {
      const g = { repo, agents: [] };
      byRepo.set(repo, g);
      groups.push(g);
    }
    byRepo.get(repo).agents.push(agent);
  });

  const ordered = [];
  groups.forEach(group => group.agents.forEach(agent => ordered.push({ agent, repo: group.repo })));

  const slots = [];
  const deskAgents = new Array(DESKS.length).fill(null);
  const firstIndex = new Map();
  const maxCount = Math.min(ordered.length, DESKS.length);
  for (let i = 0; i < maxCount; i++) {
    const item = ordered[i];
    const desk = DESKS[i];
    const row = Math.floor(i / DESK_COLS);
    const col = i % DESK_COLS;
    const slot = { ...item, idx: i, desk, row, col };
    slots.push(slot);
    deskAgents[i] = slot;
    if (!firstIndex.has(item.repo)) firstIndex.set(item.repo, i);
  }

  const labels = [];
  for (const [repo, idx] of firstIndex.entries()) {
    const slot = slots[idx];
    if (slot) labels.push({ repo, desk: slot.desk, row: slot.row, col: slot.col });
  }

  const dividers = [];
  for (let i = 1; i < slots.length; i++) {
    if (slots[i].repo !== slots[i - 1].repo && slots[i].row === slots[i - 1].row) {
      dividers.push({ left: slots[i - 1], right: slots[i] });
    }
  }

  return { slots, deskAgents, labels, dividers };
}

// === DRAW OFFICE ===
function drawFloor() {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      fillTile(x, y, (x + y) % 2 === 0 ? PAL.floor : PAL.floorAlt);
    }
  }
  // top wall
  for (let x = 0; x < COLS; x++) {
    fillTile(x, 0, PAL.wall);
    drawRect(x * TILE, 0, TILE, 4, PAL.wallTop);
  }
}

function drawMonitor(dx, dy, agent, state, frame) {
  const baseX = dx * TILE + 4;
  const baseY = dy * TILE;
  const reaction = getReaction(agent);
  const ciRetries = Number(reaction.ciRetries || 0);
  const ciEscalated = !!reaction.ciEscalated;
  const active = state === 'coding';
  const screenColor = ciEscalated
    ? (frame % 20 < 10 ? PAL.monitorScreenCi : PAL.monitorScreenCiDark)
    : (active ? PAL.monitorScreenActive : PAL.monitorScreen);

  drawRect(baseX, baseY, MONITOR.w, MONITOR.h, PAL.monitor);
  drawRect(baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, screenColor);
  drawRect(baseX + (MONITOR.w - MONITOR.standW) / 2, baseY + MONITOR.h, MONITOR.standW, MONITOR.standH, PAL.monitor);

  const textColor = ciEscalated ? '#ffe6e6' : (active ? '#0b2' : '#5fbf6a');
  drawMonitorText(getMonitorText(agent), baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, frame, textColor);

  if (ciRetries > 0) {
    drawFire(baseX + MONITOR.screenX, baseY + MONITOR.screenY, frame);
  }
}

function drawDesk(dx, dy, agent, state, frame) {
  // desk surface
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.desk);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.deskTop);
  // monitor
  drawMonitor(dx, dy, agent, state, frame);
  // chair (below desk)
  drawRect(dx * TILE + 5, (dy + 1) * TILE + 2, 6, 5, PAL.chair);

  const count = coffeeCount(agent);
  if (count > 0) {
    drawCoffeeCups(dx, dy, count, frame);
  }
}

function drawCoffeeCups(dx, dy, count, frame) {
  const baseX = dx * TILE + 3;
  const baseY = dy * TILE + 5;
  for (let i = 0; i < count; i++) {
    const cupX = baseX + i * 4;
    drawRect(cupX, baseY, 3, 2, PAL.cup);
    drawRect(cupX + 1, baseY + 1, 1, 1, PAL.coffee);
    drawRect(cupX + 3, baseY + 1, 1, 1, PAL.cup);
  }

  if (count >= 3) {
    const steamX = baseX + (count - 1) * 4 + 1;
    const phase = frame % 20 < 10 ? 0 : 1;
    drawRect(steamX, baseY - 2 - phase, 1, 1, PAL.steam);
    drawRect(steamX + 1, baseY - 4 + phase, 1, 1, PAL.steam);
  }
}

function drawFire(screenX, screenY, frame) {
  const frames = [
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 2, c: PAL.fire2 }, { x: 3, y: 3, c: PAL.fire3 },
      { x: 4, y: 2, c: PAL.fire2 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 2, c: PAL.fire2 }, { x: 2, y: 3, c: PAL.fire1 }, { x: 3, y: 1, c: PAL.fire3 },
      { x: 4, y: 3, c: PAL.fire2 }, { x: 5, y: 2, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 1, c: PAL.fire3 }, { x: 3, y: 2, c: PAL.fire2 },
      { x: 4, y: 1, c: PAL.fire3 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
  ];
  const idx = frame % frames.length;
  frames[idx].forEach(p => drawRect(screenX + p.x, screenY + p.y, 1, 1, p.c));
}

function drawMonitorText(text, screenX, screenY, screenW, screenH, frame, color) {
  if (!text) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenX * SCALE, screenY * SCALE, screenW * SCALE, screenH * SCALE);
  ctx.clip();
  ctx.fillStyle = color;
  ctx.font = `${4 * SCALE}px Courier New`;
  ctx.textBaseline = 'top';
  const textWidth = ctx.measureText(text).width;
  const pad = 4 * SCALE;
  const scroll = (frame * 0.6) % (textWidth + screenW * SCALE + pad);
  const x = screenX * SCALE + screenW * SCALE - scroll;
  const y = screenY * SCALE + 1 * SCALE;
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawGroupDivider(leftDesk, rightDesk) {
  const midTileX = leftDesk.x + Math.floor((rightDesk.x - leftDesk.x) / 2);
  drawRect(midTileX * TILE + 7, leftDesk.y * TILE + 2, 2, 12, PAL.divider);
}

function drawGroupLabel(dx, dy, text) {
  if (!text) return;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(text).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 8) * SCALE - w / 2;
  const y = (dy * TILE - 14) * SCALE;
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = '#f0c040';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPrBadge(dx, dy, prNumber, merged) {
  const label = `PR #${prNumber}${merged ? ' ‚úì' : ''}`;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(label).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 12) * SCALE - w / 2;
  const y = (dy * TILE - 12) * SCALE;
  ctx.fillStyle = merged ? PAL.badgeGold : PAL.badgeGreen;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = PAL.badgeText;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPlant(px, py) {
  drawRect(px * TILE + 6, py * TILE + 4, 4, 6, PAL.plantPot);
  drawRect(px * TILE + 3, py * TILE, 10, 5, PAL.plant);
  drawRect(px * TILE + 5, py * TILE - 2, 6, 3, PAL.plant);
}

// === DRAW CHARACTER ===
function drawCharacter(tileX, tileY, colorIdx, state, frame, agentType) {
  const base = CHAR_COLORS[colorIdx % CHAR_COLORS.length];
  const shirt = agentType === 'codex' ? '#3fbf3f' : (agentType === 'claude' ? '#f08b2e' : base.shirt);
  const c = { ...base, shirt };
  const px = tileX * TILE;
  const py = tileY * TILE;
  const bob = Math.sin(frame * 0.15) > 0 ? 0 : 1;

  // body offset (sitting = higher up to align with chair)
  const sitting = state === 'coding' || state === 'reading' || state === 'waiting';
  const oy = sitting ? -2 : bob;

  // legs
  if (!sitting) {
    const walk = state === 'walking';
    const legOff = walk ? (Math.sin(frame * 0.3) > 0 ? 1 : -1) : 0;
    drawRect(px + 5, py + 11 + oy, 2, 4, c.pants);
    drawRect(px + 9, py + 11 + oy + legOff, 2, 4, c.pants);
  } else {
    // seated legs forward
    drawRect(px + 4, py + 11 + oy, 8, 2, c.pants);
  }

  // torso
  drawRect(px + 4, py + 6 + oy, 8, 5, c.shirt);

  // head
  drawRect(px + 5, py + 1 + oy, 6, 5, c.skin);
  // hair
  drawRect(px + 5, py + oy, 6, 2, c.hair);
  // hoodie hints
  drawRect(px + 4, py + 3 + oy, 1, 2, c.shirt);
  drawRect(px + 11, py + 3 + oy, 1, 2, c.shirt);

  // arms
  if (state === 'coding') {
    // arms forward (typing)
    const armBob = frame % 6 < 3 ? 0 : 1;
    drawRect(px + 2, py + 7 + oy, 2, 3, c.shirt);
    drawRect(px + 12, py + 7 + oy + armBob, 2, 3, c.shirt);
    // hands on desk
    drawRect(px + 2, py + 10 + oy, 2, 1, c.skin);
    drawRect(px + 12, py + 10 + oy + armBob, 2, 1, c.skin);
  } else if (state === 'reading') {
    // hand on chin
    drawRect(px + 2, py + 7 + oy, 2, 4, c.shirt);
    drawRect(px + 12, py + 7 + oy, 2, 2, c.shirt);
    drawRect(px + 12, py + 5 + oy, 2, 2, c.skin); // hand near face
  } else {
    // arms at sides
    drawRect(px + 2, py + 6 + oy, 2, 4, c.shirt);
    drawRect(px + 12, py + 6 + oy, 2, 4, c.shirt);
  }

  // eyes
  const blinking = frame % 60 < 3;
  if (!blinking) {
    drawRect(px + 6, py + 3 + oy, 1, 1, '#222');
    drawRect(px + 9, py + 3 + oy, 1, 1, '#222');
  }
}

// === SPEECH BUBBLE ===
function drawBubble(tileX, tileY, text, color = '#fff') {
  const px = tileX * TILE * SCALE;
  const py = (tileY * TILE - 10) * SCALE;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  const w = Math.max(text.length * 6 + 8, 30);
  ctx.fillRect(px - w/2 + S/2, py - 14, w, 14);
  ctx.fillStyle = color;
  ctx.font = '10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(text, px + S/2, py - 4);
  ctx.textAlign = 'left';
}

// === STATUS BAR ===
function drawStatusBar() {
  const y = ROWS * S;
  ctx.fillStyle = '#111';
  ctx.fillRect(0, y, CANVAS_W, S);
  ctx.fillStyle = '#888';
  ctx.font = '11px Courier New';
  const running = agents.filter(a => mapState(a) !== 'dead').length;
  ctx.fillText(`ü§† Corral | ${agents.length} agents | ${running} active`, 8, y + 20);
  const now = new Date().toLocaleTimeString();
  ctx.fillText(now, CANVAS_W - 80, y + 20);
}

// === MAP LASSO STATE ‚Üí ANIMATION STATE ===
function mapState(agent) {
  if (!agent) return 'idle';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  if (status.includes('dead') || status.includes('exited') || activity.includes('exited') || activity.includes('dead')) return 'dead';
  if (status.includes('pr_review') || status.includes('changes_requested')) return 'reading';
  if (status.includes('pr_open') || status.includes('ci') || status.includes('merged') || activity.includes('stale')) return 'waiting';
  if (status.includes('working') || activity.includes('active')) return 'coding';
  return 'idle';
}

function stateLabel(state) {
  switch(state) {
    case 'coding': return '‚å®Ô∏è coding';
    case 'reading': return 'üìñ review';
    case 'waiting': return '‚è≥ waiting';
    case 'dead': return 'üíÄ done';
    default: return 'üí§ idle';
  }
}

function getTileFromEvent(event) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (event.clientX - rect.left) * scaleX;
  const y = (event.clientY - rect.top) * scaleY;
  return { tileX: Math.floor(x / S), tileY: Math.floor(y / S) };
}

function getSlotAtTile(tileX, tileY) {
  if (!currentLayout) return null;
  if (tileX < 0 || tileX >= COLS || tileY < 0 || tileY >= ROWS) return null;
  for (const slot of currentLayout.slots) {
    const dx = slot.desk.x;
    const dy = slot.desk.y;
    if (tileX === dx && (tileY === dy || tileY === dy + 1)) return slot;
  }
  return null;
}

function handleCanvasClick(event) {
  const { tileX, tileY } = getTileFromEvent(event);
  const slot = getSlotAtTile(tileX, tileY);
  if (!slot) return;
  const url = getAgentUrl(slot.agent);
  if (url) window.open(url, '_blank');
}

function handleCanvasMove(event) {
  const { tileX, tileY } = getTileFromEvent(event);
  const slot = getSlotAtTile(tileX, tileY);
  canvas.style.cursor = slot ? 'pointer' : 'default';
}

function handleCanvasLeave() {
  canvas.style.cursor = 'default';
}

// === MAIN RENDER LOOP ===
let frame = 0;
function render() {
  frame++;
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawFloor();

  const layout = buildLayout(agents);
  currentLayout = layout;

  layout.dividers.forEach(divider => drawGroupDivider(divider.left.desk, divider.right.desk));

  // draw desks
  DESKS.forEach((d, i) => {
    const slot = layout.deskAgents[i];
    const agent = slot ? slot.agent : null;
    const state = agent ? mapState(agent) : 'idle';
    drawDesk(d.x, d.y, agent, state, frame);
  });

  // decorative plants
  drawPlant(0, 2);
  drawPlant(0, 8);
  drawPlant(COLS - 1, 5);

  layout.labels.forEach(label => drawGroupLabel(label.desk.x, label.desk.y, label.repo));

  // draw agents at desks
  layout.slots.forEach((slot, i) => {
    const agent = slot.agent;
    const desk = slot.desk;
    const state = mapState(agent);
    if (state === 'dead') return; // ghost desk
    drawCharacter(desk.x, desk.y + 1, i, state, frame, resolveAgentType(agent));
    const prNumber = agent ? agent.prNumber : null;
    const status = (agent.status || '').toLowerCase();
    if (prNumber !== null && prNumber !== undefined) {
      drawPrBadge(desk.x, desk.y, prNumber, status.includes('merged'));
    }
    // bubble with repo/issue
    const repo = getRepoName(agent);
    const issueId = getIssueId(agent);
    const label = issueId ? `${repo}#${issueId}` : (repo || agent.id || `agent-${i}`);
    drawBubble(desk.x, desk.y, label, state === 'waiting' ? '#ff0' : '#fff');
  });

  drawStatusBar();
  requestAnimationFrame(render);
}

// === DATA LOADING ===
function loadDemo() {
  const now = Date.now();
  agents = [
    {
      id: 'codex-1',
      repo: 'zall',
      issueId: '7',
      issueTitle: 'Tighten input validation',
      status: 'running',
      agentType: 'codex',
      createdAt: new Date(now - 30 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-2',
      repo: 'zall',
      issueId: '12',
      issueTitle: 'Add rate limiting',
      status: 'pr_open',
      agentType: 'codex',
      prNumber: 42,
      createdAt: new Date(now - 2.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'claude-3',
      repo: 'lasso',
      issueId: '29',
      issueTitle: 'Refine lasso ingestion',
      status: 'running',
      agentType: 'claude',
      createdAt: new Date(now - 5.5 * 60 * 60 * 1000).toISOString(),
      reactionState: { ciRetries: 2 },
    },
    {
      id: 'codex-4',
      repo: 'corral',
      issueId: '1',
      issueTitle: 'Rich visuals polish',
      status: 'ci_pending',
      agentType: 'codex',
      reactionState: { ciRetries: 3, ciEscalated: true },
      prNumber: 88,
      createdAt: new Date(now - 4.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-5',
      repo: 'zall',
      issueId: '15',
      status: 'merged',
      agentType: 'codex',
      prNumber: 61,
      createdAt: new Date(now - 90 * 60 * 1000).toISOString(),
    },
  ];
  updateAgentsList();
}

function loadAgentsFile() {
  document.getElementById('fileInput').click();
}

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      agents = Array.isArray(data) ? data : (data.sessions || []);
      updateAgentsList();
    } catch(err) { alert('Invalid JSON'); }
  };
  reader.readAsText(file);
}

async function refreshFromLasso() {
  try {
    const resp = await fetch('/api/agents');
    const data = await resp.json();
    agents = Array.isArray(data) ? data : (data.sessions || []);
    updateAgentsList();
    return true;
  } catch(e) {
    document.getElementById('info').textContent = 'Server not running ‚Äî start with: node server.js';
    return false;
  }
}

// Auto-poll every 5s
let polling = false;
async function startPolling() {
  if (polling) return;
  polling = true;
  document.getElementById('info').textContent = 'üîÑ Live mode ‚Äî polling every 5s';
  while (polling) {
    await refreshFromLasso();
    await new Promise(r => setTimeout(r, 5000));
  }
}
function stopPolling() { polling = false; }

function updateAgentsList() {
  const el = document.getElementById('agents-list');
  el.innerHTML = agents.map((a, i) => {
    const state = mapState(a);
    const repo = getRepoName(a);
    const issueId = getIssueId(a);
    return `<div class="agent-row">
      <span class="agent-name">${a.id || a.label || 'agent-' + i}</span>
      <span class="agent-repo">${repo}${issueId ? '#' + issueId : ''}</span>
      <span class="agent-status">${stateLabel(state)}</span>
    </div>`;
  }).join('');
  document.getElementById('info').textContent = `${agents.length} agents loaded`;
}

canvas.addEventListener('click', handleCanvasClick);
canvas.addEventListener('mousemove', handleCanvasMove);
canvas.addEventListener('mouseleave', handleCanvasLeave);

// drag & drop
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        agents = Array.isArray(data) ? data : (data.sessions || []);
        updateAgentsList();
      } catch(err) { alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  }
});

// start
render();
// auto-connect to live server if available
refreshFromLasso().then(ok => { if (ok) startPolling(); });
</script>
</body>
</html>
