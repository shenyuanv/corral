<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ü§†</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: 'Courier New', monospace; color: #e0e0e0; }
  h1 { font-size: 18px; margin-bottom: 8px; color: #f0c040; }
  canvas { border: 2px solid #333; image-rendering: pixelated; image-rendering: crisp-edges; cursor: default; }
  #info { margin-top: 8px; font-size: 12px; color: #888; }
  #agents-list { margin-top: 12px; font-size: 11px; max-width: 640px; }
  .agent-row { display: flex; gap: 8px; padding: 2px 0; }
  .agent-name { color: #f0c040; min-width: 80px; }
  .agent-status { color: #8f8; }
  .agent-repo { color: #88f; }
  #controls { margin-top: 10px; display: flex; gap: 8px; }
  button { background: #333; color: #e0e0e0; border: 1px solid #555; padding: 4px 12px; font-family: inherit; font-size: 11px; cursor: pointer; }
  button:hover { background: #444; }
</style>
</head>
<body>
<h1>ü§† Corral</h1>
<canvas id="office" width="640" height="400"></canvas>
<div id="info">Click "Load Agents" or drop agents.json to populate</div>
<div id="controls">
  <button onclick="loadAgentsFile()">Load agents.json</button>
  <button onclick="loadDemo()">Demo Mode</button>
  <button onclick="refreshFromLasso()">Refresh</button>
  <button onclick="startPolling()">‚ñ∂ Live</button>
  <button onclick="stopPolling()">‚èπ Stop</button>
</div>
<div id="agents-list"></div>

<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFile(event)">

<script>
// === CONSTANTS ===
const TILE = 16;
const SCALE = 2;
const S = TILE * SCALE; // rendered tile size
const COLS = 20;
const ROWS = 12; // 640x384 at scale 2
const CANVAS_W = COLS * S;
const CANVAS_H = ROWS * S + S; // extra row for status bar

const canvas = document.getElementById('office');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// === COLORS (pixel art palette) ===
const PAL = {
  floor: '#3a3a5c',
  floorAlt: '#33334f',
  wall: '#5c5c8a',
  wallTop: '#7a7ab0',
  desk: '#8b6914',
  deskTop: '#c49b2a',
  monitor: '#222',
  monitorScreen: '#0f380f',
  monitorScreenActive: '#4ae04a',
  chair: '#444',
  plant: '#2d5a1e',
  plantPot: '#8b5e3c',
};

// === CHARACTER COLORS ===
const CHAR_COLORS = [
  { skin: '#f5c6a0', hair: '#4a2800', shirt: '#e04040', pants: '#3050a0' }, // red
  { skin: '#d4a373', hair: '#1a1a2e', shirt: '#4080e0', pants: '#2a2a4e' }, // blue
  { skin: '#f5deb3', hair: '#c04000', shirt: '#40c040', pants: '#404040' }, // green
  { skin: '#c49b6a', hair: '#222', shirt: '#e0a040', pants: '#3a3a5c' },   // gold
  { skin: '#f0d0b0', hair: '#604020', shirt: '#a040c0', pants: '#333' },    // purple
  { skin: '#e8c090', hair: '#802020', shirt: '#40c0c0', pants: '#2a2a4e' }, // teal
];

// === DESK POSITIONS ===
const DESKS = [];
for (let row = 0; row < 3; row++) {
  for (let col = 0; col < 4; col++) {
    DESKS.push({ x: 2 + col * 5, y: 2 + row * 3 });
  }
}

// === AGENT STATE ===
let agents = [];

// === DRAWING HELPERS ===
function fillTile(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * S, y * S, S, S);
}

function drawRect(px, py, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(px * SCALE, py * SCALE, w * SCALE, h * SCALE);
}

// === DRAW OFFICE ===
function drawFloor() {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      fillTile(x, y, (x + y) % 2 === 0 ? PAL.floor : PAL.floorAlt);
    }
  }
  // top wall
  for (let x = 0; x < COLS; x++) {
    fillTile(x, 0, PAL.wall);
    drawRect(x * TILE, 0, TILE, 4, PAL.wallTop);
  }
}

function drawDesk(dx, dy, active) {
  // desk surface
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.desk);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.deskTop);
  // monitor
  drawRect(dx * TILE + 5, dy * TILE, 6, 4, PAL.monitor);
  drawRect(dx * TILE + 6, dy * TILE + 1, 4, 2, active ? PAL.monitorScreenActive : PAL.monitorScreen);
  // chair (below desk)
  drawRect(dx * TILE + 5, (dy + 1) * TILE + 2, 6, 5, PAL.chair);
}

function drawPlant(px, py) {
  drawRect(px * TILE + 6, py * TILE + 4, 4, 6, PAL.plantPot);
  drawRect(px * TILE + 3, py * TILE, 10, 5, PAL.plant);
  drawRect(px * TILE + 5, py * TILE - 2, 6, 3, PAL.plant);
}

// === DRAW CHARACTER ===
function drawCharacter(tileX, tileY, colorIdx, state, frame) {
  const c = CHAR_COLORS[colorIdx % CHAR_COLORS.length];
  const px = tileX * TILE;
  const py = tileY * TILE;
  const bob = Math.sin(frame * 0.15) > 0 ? 0 : 1;

  // body offset (sitting = higher up to align with chair)
  const sitting = state === 'coding' || state === 'reading' || state === 'waiting';
  const oy = sitting ? -2 : bob;

  // legs
  if (!sitting) {
    const walk = state === 'walking';
    const legOff = walk ? (Math.sin(frame * 0.3) > 0 ? 1 : -1) : 0;
    drawRect(px + 5, py + 11 + oy, 2, 4, c.pants);
    drawRect(px + 9, py + 11 + oy + legOff, 2, 4, c.pants);
  } else {
    // seated legs forward
    drawRect(px + 4, py + 11 + oy, 8, 2, c.pants);
  }

  // torso
  drawRect(px + 4, py + 6 + oy, 8, 5, c.shirt);

  // head
  drawRect(px + 5, py + 1 + oy, 6, 5, c.skin);
  // hair
  drawRect(px + 5, py + oy, 6, 2, c.hair);

  // arms
  if (state === 'coding') {
    // arms forward (typing)
    const armBob = frame % 6 < 3 ? 0 : 1;
    drawRect(px + 2, py + 7 + oy, 2, 3, c.shirt);
    drawRect(px + 12, py + 7 + oy + armBob, 2, 3, c.shirt);
    // hands on desk
    drawRect(px + 2, py + 10 + oy, 2, 1, c.skin);
    drawRect(px + 12, py + 10 + oy + armBob, 2, 1, c.skin);
  } else if (state === 'reading') {
    // hand on chin
    drawRect(px + 2, py + 7 + oy, 2, 4, c.shirt);
    drawRect(px + 12, py + 7 + oy, 2, 2, c.shirt);
    drawRect(px + 12, py + 5 + oy, 2, 2, c.skin); // hand near face
  } else {
    // arms at sides
    drawRect(px + 2, py + 6 + oy, 2, 4, c.shirt);
    drawRect(px + 12, py + 6 + oy, 2, 4, c.shirt);
  }

  // eyes
  const blinking = frame % 60 < 3;
  if (!blinking) {
    drawRect(px + 6, py + 3 + oy, 1, 1, '#222');
    drawRect(px + 9, py + 3 + oy, 1, 1, '#222');
  }
}

// === SPEECH BUBBLE ===
function drawBubble(tileX, tileY, text, color = '#fff') {
  const px = tileX * TILE * SCALE;
  const py = (tileY * TILE - 10) * SCALE;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  const w = Math.max(text.length * 6 + 8, 30);
  ctx.fillRect(px - w/2 + S/2, py - 14, w, 14);
  ctx.fillStyle = color;
  ctx.font = '10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(text, px + S/2, py - 4);
  ctx.textAlign = 'left';
}

// === STATUS BAR ===
function drawStatusBar() {
  const y = ROWS * S;
  ctx.fillStyle = '#111';
  ctx.fillRect(0, y, CANVAS_W, S);
  ctx.fillStyle = '#888';
  ctx.font = '11px Courier New';
  const running = agents.filter(a => a.state !== 'dead').length;
  ctx.fillText(`ü§† Corral | ${agents.length} agents | ${running} active`, 8, y + 20);
  const now = new Date().toLocaleTimeString();
  ctx.fillText(now, CANVAS_W - 80, y + 20);
}

// === MAP LASSO STATE ‚Üí ANIMATION STATE ===
function mapState(agent) {
  if (!agent) return 'idle';
  const s = (agent.status || agent.state || '').toLowerCase();
  if (s.includes('dead') || s.includes('exited') || s.includes('killed')) return 'dead';
  if (s.includes('review') || s.includes('pr_open') || s.includes('pr_review')) return 'reading';
  if (s.includes('wait') || s.includes('ci') || s.includes('pending')) return 'waiting';
  if (s.includes('running') || s.includes('coding') || s.includes('active')) return 'coding';
  return 'idle';
}

function stateLabel(state) {
  switch(state) {
    case 'coding': return '‚å®Ô∏è coding';
    case 'reading': return 'üìñ review';
    case 'waiting': return '‚è≥ waiting';
    case 'dead': return 'üíÄ done';
    default: return 'üí§ idle';
  }
}

// === MAIN RENDER LOOP ===
let frame = 0;
function render() {
  frame++;
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawFloor();

  // draw desks
  DESKS.forEach((d, i) => {
    const agent = agents[i];
    const active = agent && mapState(agent) === 'coding';
    drawDesk(d.x, d.y, active);
  });

  // decorative plants
  drawPlant(0, 2);
  drawPlant(0, 8);
  drawPlant(COLS - 1, 5);

  // draw agents at desks
  agents.forEach((agent, i) => {
    if (i >= DESKS.length) return;
    const desk = DESKS[i];
    const state = mapState(agent);
    if (state === 'dead') return; // ghost desk
    drawCharacter(desk.x, desk.y + 1, i, state, frame);
    // bubble with repo/issue
    const label = agent.issue ? `#${agent.issue}` : (agent.repo || agent.label || `agent-${i}`);
    drawBubble(desk.x, desk.y, label, state === 'waiting' ? '#ff0' : '#fff');
  });

  drawStatusBar();
  requestAnimationFrame(render);
}

// === DATA LOADING ===
function loadDemo() {
  agents = [
    { label: 'codex-1', repo: 'zall', issue: '7', status: 'running', agent: 'codex' },
    { label: 'codex-2', repo: 'zall', issue: '12', status: 'pr_open', agent: 'codex' },
    { label: 'claude-3', repo: 'lasso', issue: '29', status: 'running', agent: 'claude' },
    { label: 'codex-4', repo: 'corral', issue: '1', status: 'ci_pending', agent: 'codex' },
    { label: 'codex-5', repo: 'zall', issue: '15', status: 'dead', agent: 'codex' },
  ];
  updateAgentsList();
}

function loadAgentsFile() {
  document.getElementById('fileInput').click();
}

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      agents = Array.isArray(data) ? data : (data.sessions || []);
      updateAgentsList();
    } catch(err) { alert('Invalid JSON'); }
  };
  reader.readAsText(file);
}

async function refreshFromLasso() {
  try {
    const resp = await fetch('/api/agents');
    const data = await resp.json();
    agents = Array.isArray(data) ? data : (data.sessions || []);
    updateAgentsList();
    return true;
  } catch(e) {
    document.getElementById('info').textContent = 'Server not running ‚Äî start with: node server.js';
    return false;
  }
}

// Auto-poll every 5s
let polling = false;
async function startPolling() {
  if (polling) return;
  polling = true;
  document.getElementById('info').textContent = 'üîÑ Live mode ‚Äî polling every 5s';
  while (polling) {
    await refreshFromLasso();
    await new Promise(r => setTimeout(r, 5000));
  }
}
function stopPolling() { polling = false; }

function updateAgentsList() {
  const el = document.getElementById('agents-list');
  el.innerHTML = agents.map((a, i) => {
    const state = mapState(a);
    return `<div class="agent-row">
      <span class="agent-name">${a.label || 'agent-' + i}</span>
      <span class="agent-repo">${a.repo || ''}${a.issue ? '#' + a.issue : ''}</span>
      <span class="agent-status">${stateLabel(state)}</span>
    </div>`;
  }).join('');
  document.getElementById('info').textContent = `${agents.length} agents loaded`;
}

// drag & drop
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        agents = Array.isArray(data) ? data : (data.sessions || []);
        updateAgentsList();
      } catch(err) { alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  }
});

// start
render();
// auto-connect to live server if available
refreshFromLasso().then(ok => { if (ok) startPolling(); });
</script>
</body>
</html>
