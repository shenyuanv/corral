<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ü§†</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: 'Courier New', monospace; color: #e0e0e0; }
  h1 { font-size: 18px; margin-bottom: 8px; color: #f0c040; }
  canvas { border: 2px solid #333; image-rendering: pixelated; image-rendering: crisp-edges; cursor: default; }
  #info { margin-top: 8px; font-size: 12px; color: #888; }
  #agents-list { margin-top: 12px; font-size: 11px; max-width: 640px; }
  .agent-row { display: flex; gap: 8px; padding: 2px 0; }
  .agent-name { color: #f0c040; min-width: 80px; }
  .agent-status { color: #8f8; }
  .agent-repo { color: #88f; }
  #controls { margin-top: 10px; display: flex; gap: 8px; }
  button { background: #333; color: #e0e0e0; border: 1px solid #555; padding: 4px 12px; font-family: inherit; font-size: 11px; cursor: pointer; }
  button:hover { background: #444; }
  #tooltip {
    position: fixed;
    z-index: 10;
    display: none;
    max-width: 320px;
    padding: 8px 10px;
    font-size: 11px;
    line-height: 1.35;
    color: #e6e6e6;
    background: #15151f;
    border: 2px solid #4a4a62;
    box-shadow: 0 0 0 2px #0b0b12, 4px 4px 0 #0b0b12;
    pointer-events: none;
  }
  .tooltip-title { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; font-weight: bold; color: #f0c040; }
  .tooltip-row { display: flex; gap: 6px; margin: 2px 0; }
  .tooltip-label { min-width: 70px; color: #9aa0b5; }
  .tooltip-value { color: #e6e6e6; word-break: break-word; }
  .tooltip-muted { color: #8b8fa3; }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; box-shadow: 0 0 0 1px #0b0b12; }
  .status-active { background: #2f9a3d; }
  .status-waiting { background: #d1a128; }
  .status-ci { background: #c13c3c; }
  .status-dead { background: #6c6c6c; }
</style>
</head>
<body>
<h1>ü§† Corral</h1>
<canvas id="office" width="640" height="400"></canvas>
<div id="tooltip" role="tooltip" aria-hidden="true"></div>
<div id="info">Click "Load Agents" or drop agents.json to populate</div>
<div id="controls">
  <button onclick="loadAgentsFile()">Load agents.json</button>
  <button onclick="loadDemo()">Demo Mode</button>
  <button onclick="refreshFromLasso()">Refresh</button>
  <button onclick="startPolling()">‚ñ∂ Live</button>
  <button onclick="stopPolling()">‚èπ Stop</button>
</div>
<div id="agents-list"></div>

<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFile(event)">

<script>
// === CONSTANTS ===
const TILE = 16;
const SCALE = 2;
const S = TILE * SCALE; // rendered tile size
const COLS = 20;
const ROWS = 12; // 640x384 at scale 2
const DESK_COLS = 4;
const DESK_ROWS = 3;
const DESK_START_X = 2;
const DESK_START_Y = 2;
const DESK_GAP_X = 5;
const DESK_GAP_Y = 3;
const CANVAS_W = COLS * S;
const CANVAS_H = ROWS * S + S; // extra row for status bar
const DOOR_TILE = { x: 0, y: 6 };
const WALK_SPEED = 2; // tiles per second
const ENTER_STAGGER = 0.5; // seconds

const canvas = document.getElementById('office');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const tooltip = document.getElementById('tooltip');

// === COLORS (pixel art palette) ===
const PAL = {
  floor: '#3a3a5c',
  floorAlt: '#33334f',
  wall: '#5c5c8a',
  wallTop: '#7a7ab0',
  desk: '#8b6914',
  deskTop: '#c49b2a',
  monitor: '#222',
  monitorScreen: '#0f380f',
  monitorScreenActive: '#4ae04a',
  monitorScreenCi: '#ff3b3b',
  monitorScreenCiDark: '#7a1111',
  chair: '#444',
  plant: '#2d5a1e',
  plantPot: '#8b5e3c',
  divider: '#26263b',
  badgeGreen: '#2f9a3d',
  badgeGold: '#d1a128',
  badgeText: '#111',
  cup: '#d9d9d9',
  coffee: '#5a3a1a',
  steam: '#e5e5e5',
  fire1: '#f04',
  fire2: '#f80',
  fire3: '#ff0',
  tokenGreen: '#2f9a3d',
  tokenYellow: '#d1a128',
  tokenRed: '#c13c3c',
  tokenBg: '#0b0b12',
};

// === CHARACTER COLORS ===
const CHAR_COLORS = [
  { skin: '#f5c6a0', hair: '#4a2800', shirt: '#e04040', pants: '#3050a0' }, // red
  { skin: '#d4a373', hair: '#1a1a2e', shirt: '#4080e0', pants: '#2a2a4e' }, // blue
  { skin: '#f5deb3', hair: '#c04000', shirt: '#40c040', pants: '#404040' }, // green
  { skin: '#c49b6a', hair: '#222', shirt: '#e0a040', pants: '#3a3a5c' },   // gold
  { skin: '#f0d0b0', hair: '#604020', shirt: '#a040c0', pants: '#333' },    // purple
  { skin: '#e8c090', hair: '#802020', shirt: '#40c0c0', pants: '#2a2a4e' }, // teal
];

const MONITOR = {
  w: 8,
  h: 6,
  screenX: 1,
  screenY: 1,
  screenW: 6,
  screenH: 4,
  standW: 4,
  standH: 2,
};

// === DESK POSITIONS ===
const DESKS = [];
for (let row = 0; row < DESK_ROWS; row++) {
  for (let col = 0; col < DESK_COLS; col++) {
    DESKS.push({ x: DESK_START_X + col * DESK_GAP_X, y: DESK_START_Y + row * DESK_GAP_Y });
  }
}

// === AGENT STATE ===
let agents = [];
let currentLayout = null;
let hoveredDeskIndex = null;
let hoveredSignature = '';
let transitions = [];
let hasInitialized = false;
let lastRenderTime = null;

// === DRAWING HELPERS ===
function fillTile(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * S, y * S, S, S);
}

function drawRect(px, py, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(px * SCALE, py * SCALE, w * SCALE, h * SCALE);
}

// === DATA HELPERS ===
function getRepoName(agent) {
  if (!agent) return '';
  return (agent.repo || '').split('/').pop() || '';
}

function getIssueId(agent) {
  if (!agent) return '';
  return agent.issueId ?? agent.issue ?? agent.issueID ?? '';
}

function resolveAgentType(agent) {
  if (!agent) return '';
  return (agent.agentType || agent.agent || agent.type || '').toLowerCase();
}

function getMonitorText(agent) {
  if (!agent) return '';
  const issueTitle = (agent.issueTitle || '').toString().trim();
  if (issueTitle) return issueTitle;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  if (repo && issueId) return `${repo}#${issueId}`;
  return repo || agent.id || '';
}

function getReaction(agent) {
  return agent && agent.reactionState ? agent.reactionState : {};
}

function getTokensUsed(agent) {
  if (!agent) return null;
  const value = agent.tokensUsed ?? agent.tokens_used ?? agent.tokenUsage ?? agent.token_usage;
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string' && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return null;
}

function getAgentUrl(agent) {
  if (!agent) return '';
  const prUrl = agent.prUrl || agent.prURL || agent.pullRequestUrl || agent.pull_request_url;
  if (typeof prUrl === 'string' && prUrl.trim()) return prUrl.trim();
  const repo = typeof agent.repo === 'string' ? agent.repo.trim() : '';
  const issueId = getIssueId(agent);
  const issueIdStr = issueId !== null && issueId !== undefined ? String(issueId).trim() : '';
  if (repo && issueIdStr) return `https://github.com/${repo}/issues/${issueIdStr}`;
  return '';
}

function escapeHtml(value) {
  return String(value ?? '').replace(/[&<>"']/g, char => {
    switch (char) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return char;
    }
  });
}

function formatDuration(ms) {
  const totalMins = Math.max(0, Math.floor(ms / 60000));
  const hours = Math.floor(totalMins / 60);
  const mins = totalMins % 60;
  if (hours > 0) return `${hours}h ${mins}m`;
  return `${mins}m`;
}

function agentKey(agent, fallbackIndex) {
  if (!agent) return `agent-${fallbackIndex}`;
  const id = (agent.id || agent.label || agent.agentId || agent.name || '').toString().trim();
  if (id) return id;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  const created = (agent.createdAt || '').toString().trim();
  if (repo || issueId || created) return `${repo}#${issueId}-${created}`;
  return `agent-${fallbackIndex}`;
}

function buildPath(start, end) {
  const mid = { x: end.x, y: start.y };
  const seg1 = Math.abs(mid.x - start.x) + Math.abs(mid.y - start.y);
  const seg2 = Math.abs(end.x - mid.x) + Math.abs(end.y - mid.y);
  return {
    start: { ...start },
    mid,
    end: { ...end },
    seg1,
    seg2,
    total: seg1 + seg2,
  };
}

function positionAlongPath(path, dist) {
  if (path.total === 0) return { x: path.end.x, y: path.end.y };
  if (dist <= path.seg1) {
    const dx = path.mid.x - path.start.x;
    const dy = path.mid.y - path.start.y;
    const stepX = dx === 0 ? 0 : Math.sign(dx) * dist;
    const stepY = dy === 0 ? 0 : Math.sign(dy) * dist;
    return { x: path.start.x + stepX, y: path.start.y + stepY };
  }
  const remaining = dist - path.seg1;
  const dx = path.end.x - path.mid.x;
  const dy = path.end.y - path.mid.y;
  const stepX = dx === 0 ? 0 : Math.sign(dx) * remaining;
  const stepY = dy === 0 ? 0 : Math.sign(dy) * remaining;
  return { x: path.mid.x + stepX, y: path.mid.y + stepY };
}

function transitionPosition(transition, now) {
  const progress = now < transition.startAt ? 0 : Math.min(transition.progress, transition.path.total);
  return positionAlongPath(transition.path, progress);
}

function makeTransition({ key, agent, type, start, end, startAt, colorIdx }) {
  return {
    key,
    agent,
    type,
    path: buildPath(start, end),
    progress: 0,
    startAt,
    colorIdx,
  };
}

function reverseTransition(transition, type, end, now) {
  const start = transitionPosition(transition, now);
  transition.type = type;
  transition.path = buildPath(start, end);
  transition.progress = 0;
  transition.startAt = now;
}

function mapSlotsByKey(layout) {
  const map = new Map();
  layout.slots.forEach(slot => {
    map.set(slot.key, slot);
  });
  return map;
}

function updateTransitions(now, dt) {
  if (!transitions.length) return;
  transitions = transitions.filter(transition => {
    if (now < transition.startAt) return true;
    if (transition.path.total === 0) return false;
    if (dt > 0) {
      transition.progress = Math.min(transition.path.total, transition.progress + dt * WALK_SPEED);
    }
    return transition.progress < transition.path.total;
  });
}

function setAgents(nextAgents, { skipAnimation = false } = {}) {
  const prevAgents = agents;
  const prevLayout = buildLayout(prevAgents);
  const nextLayout = buildLayout(nextAgents);
  const prevSlotsByKey = mapSlotsByKey(prevLayout);
  const nextSlotsByKey = mapSlotsByKey(nextLayout);
  const now = performance.now();

  if (!hasInitialized || skipAnimation) {
    agents = nextAgents;
    transitions = [];
    hasInitialized = true;
    updateAgentsList();
    return;
  }

  transitions.forEach(transition => {
    const nextSlot = nextSlotsByKey.get(transition.key);
    if (transition.type === 'enter') {
      const shouldExit = !nextSlot || mapState(nextSlot.agent) === 'dead';
      if (shouldExit) {
        reverseTransition(transition, 'exit', DOOR_TILE, now);
      } else {
        transition.agent = nextSlot.agent;
      }
      return;
    }
    if (transition.type === 'exit') {
      if (nextSlot && mapState(nextSlot.agent) !== 'dead') {
        reverseTransition(transition, 'enter', { x: nextSlot.desk.x, y: nextSlot.desk.y + 1 }, now);
        transition.agent = nextSlot.agent;
      } else if (nextSlot) {
        transition.agent = nextSlot.agent;
      }
    }
  });

  const transitionKeys = new Set(transitions.map(transition => transition.key));
  const enteringSlots = [];
  nextSlotsByKey.forEach(slot => {
    if (!prevSlotsByKey.has(slot.key)) enteringSlots.push(slot);
  });
  const exitingSlots = [];
  prevSlotsByKey.forEach(slot => {
    if (!nextSlotsByKey.has(slot.key)) exitingSlots.push(slot);
  });

  enteringSlots.forEach((slot, index) => {
    if (transitionKeys.has(slot.key)) return;
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'enter',
      start: DOOR_TILE,
      end: { x: slot.desk.x, y: slot.desk.y + 1 },
      startAt: now + index * ENTER_STAGGER * 1000,
      colorIdx: slot.idx,
    }));
  });

  exitingSlots.forEach(slot => {
    if (transitionKeys.has(slot.key)) return;
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'exit',
      start: { x: slot.desk.x, y: slot.desk.y + 1 },
      end: DOOR_TILE,
      startAt: now,
      colorIdx: slot.idx,
    }));
  });

  agents = nextAgents;
  hasInitialized = true;
  updateAgentsList();
}

function runtimeLabel(agent) {
  if (!agent || !agent.createdAt) return 'Unknown';
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 'Unknown';
  const diff = Math.max(0, Date.now() - ts);
  const isDone = mapState(agent) === 'dead';
  const verb = isDone ? 'Ran for' : 'Running for';
  return `${verb} ${formatDuration(diff)}`;
}

function formatRepoIssue(agent) {
  if (!agent) return 'Unknown';
  const repo = agent.repo || '';
  const issueId = getIssueId(agent);
  const title = (agent.issueTitle || '').toString().trim();
  if (repo && issueId) {
    return title ? `${repo} #${issueId} ‚Äî ${title}` : `${repo} #${issueId}`;
  }
  if (repo) return title ? `${repo} ‚Äî ${title}` : repo;
  return title || agent.id || 'Unknown';
}

function formatStatus(agent) {
  if (!agent) return 'unknown';
  const status = (agent.status || '').toString().trim();
  const activity = (agent.activity || '').toString().trim();
  if (status && activity && status !== activity) return `${status} (${activity})`;
  return status || activity || 'unknown';
}

function formatTokenCount(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '‚Äî';
  if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1).replace(/\.0$/, '')}m`;
  if (value >= 1_000) return `${(value / 1_000).toFixed(1).replace(/\.0$/, '')}k`;
  return `${Math.round(value)}`;
}

function formatTokenDetail(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '‚Äî';
  return Math.round(value).toLocaleString();
}

function formatCiState(agent) {
  const reaction = getReaction(agent);
  const retries = Number(reaction.ciRetries || 0);
  const status = (agent && agent.status ? agent.status : '').toLowerCase();
  const failing = !!reaction.ciEscalated || status.includes('ci_failed') || status.includes('failed');
  const state = failing ? 'failing' : 'passing';
  return `${state} (retries: ${retries})`;
}

function statusDotClass(agent) {
  if (!agent) return 'status-dead';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  const reaction = getReaction(agent);
  if (mapState(agent) === 'dead') return 'status-dead';
  if (reaction.ciEscalated || status.includes('ci_failed') || status.includes('failed')) return 'status-ci';
  if (status.includes('pr_open') || status.includes('merged') || status.includes('ci') || activity.includes('stale') || mapState(agent) === 'waiting') {
    return 'status-waiting';
  }
  return 'status-active';
}

function buildTooltip(agent) {
  if (!agent) return '';
  const agentId = escapeHtml(agent.id || agent.label || 'agent');
  const agentType = escapeHtml(resolveAgentType(agent) || 'unknown');
  const repoIssue = escapeHtml(formatRepoIssue(agent));
  const status = escapeHtml(formatStatus(agent));
  const runtime = escapeHtml(runtimeLabel(agent));
  const branch = escapeHtml(agent.branch || 'unknown');
  const tokensUsed = getTokensUsed(agent);
  const tokensLabel = escapeHtml(formatTokenDetail(tokensUsed));
  const prNumber = agent.prNumber ?? '';
  const prUrl = agent.prUrl || '';
  const prLabel = prNumber !== '' && prNumber !== null ? `PR #${prNumber}` : (prUrl ? 'PR link' : '‚Äî');
  const prValue = escapeHtml(prLabel + (prUrl ? ` ‚Äî ${prUrl}` : ''));
  const ciState = escapeHtml(formatCiState(agent));
  return `
    <div class="tooltip-title">
      <span class="status-dot ${statusDotClass(agent)}"></span>
      <span>${agentId}</span>
    </div>
    <div class="tooltip-row"><span class="tooltip-label">Type</span><span class="tooltip-value">${agentType}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Repo/Issue</span><span class="tooltip-value">${repoIssue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Status</span><span class="tooltip-value">${status}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Runtime</span><span class="tooltip-value">${runtime}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Tokens</span><span class="tooltip-value">${tokensLabel}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">PR</span><span class="tooltip-value">${prValue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">CI</span><span class="tooltip-value">${ciState}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Branch</span><span class="tooltip-value">${branch}</span></div>
  `;
}

function hoursRunning(agent) {
  if (!agent || !agent.createdAt) return 0;
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 0;
  return Math.max(0, (Date.now() - ts) / 3600000);
}

function coffeeCount(agent) {
  const hours = hoursRunning(agent);
  if (hours < 1) return 0;
  if (hours < 2) return 1;
  if (hours < 4) return 2;
  return 3;
}

function buildLayout(list) {
  const groups = [];
  const byRepo = new Map();
  list.forEach((agent, index) => {
    const repo = getRepoName(agent) || 'unknown';
    if (!byRepo.has(repo)) {
      const g = { repo, agents: [] };
      byRepo.set(repo, g);
      groups.push(g);
    }
    byRepo.get(repo).agents.push({ agent, repo, index });
  });

  const ordered = [];
  groups.forEach(group => group.agents.forEach(item => ordered.push(item)));

  const slots = [];
  const deskAgents = new Array(DESKS.length).fill(null);
  const firstIndex = new Map();
  const maxCount = Math.min(ordered.length, DESKS.length);
  for (let i = 0; i < maxCount; i++) {
    const item = ordered[i];
    const desk = DESKS[i];
    const row = Math.floor(i / DESK_COLS);
    const col = i % DESK_COLS;
    const key = agentKey(item.agent, item.index);
    const slot = { ...item, idx: i, desk, row, col, key };
    slots.push(slot);
    deskAgents[i] = slot;
    if (!firstIndex.has(item.repo)) firstIndex.set(item.repo, i);
  }

  const labels = [];
  for (const [repo, idx] of firstIndex.entries()) {
    const slot = slots[idx];
    if (slot) labels.push({ repo, desk: slot.desk, row: slot.row, col: slot.col });
  }

  const dividers = [];
  for (let i = 1; i < slots.length; i++) {
    if (slots[i].repo !== slots[i - 1].repo && slots[i].row === slots[i - 1].row) {
      dividers.push({ left: slots[i - 1], right: slots[i] });
    }
  }

  return { slots, deskAgents, labels, dividers };
}

// === DRAW OFFICE ===
function drawFloor() {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      fillTile(x, y, (x + y) % 2 === 0 ? PAL.floor : PAL.floorAlt);
    }
  }
  // top wall
  for (let x = 0; x < COLS; x++) {
    fillTile(x, 0, PAL.wall);
    drawRect(x * TILE, 0, TILE, 4, PAL.wallTop);
  }
}

function drawDoor() {
  const px = DOOR_TILE.x * TILE;
  const py = DOOR_TILE.y * TILE;
  drawRect(px + 1, py + 1, 14, 14, '#7a4b1f');
  drawRect(px + 11, py + 8, 2, 2, '#d8c28a');
}

function drawMonitor(dx, dy, agent, state, frame) {
  const baseX = dx * TILE + 4;
  const baseY = dy * TILE;
  const reaction = getReaction(agent);
  const ciRetries = Number(reaction.ciRetries || 0);
  const ciEscalated = !!reaction.ciEscalated;
  const active = state === 'coding';
  const screenColor = ciEscalated
    ? (frame % 20 < 10 ? PAL.monitorScreenCi : PAL.monitorScreenCiDark)
    : (active ? PAL.monitorScreenActive : PAL.monitorScreen);

  drawRect(baseX, baseY, MONITOR.w, MONITOR.h, PAL.monitor);
  drawRect(baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, screenColor);
  drawRect(baseX + (MONITOR.w - MONITOR.standW) / 2, baseY + MONITOR.h, MONITOR.standW, MONITOR.standH, PAL.monitor);

  const textColor = ciEscalated ? '#ffe6e6' : (active ? '#0b2' : '#5fbf6a');
  drawMonitorText(getMonitorText(agent), baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, frame, textColor);

  if (ciRetries > 0) {
    drawFire(baseX + MONITOR.screenX, baseY + MONITOR.screenY, frame);
  }
}

function drawDesk(dx, dy, agent, state, frame) {
  // desk surface
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.desk);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.deskTop);
  // monitor
  drawMonitor(dx, dy, agent, state, frame);
  // chair (below desk)
  drawRect(dx * TILE + 5, (dy + 1) * TILE + 2, 6, 5, PAL.chair);

  const count = coffeeCount(agent);
  if (count > 0) {
    drawCoffeeCups(dx, dy, count, frame);
  }
}

function drawCoffeeCups(dx, dy, count, frame) {
  const baseX = dx * TILE + 3;
  const baseY = dy * TILE + 5;
  for (let i = 0; i < count; i++) {
    const cupX = baseX + i * 4;
    drawRect(cupX, baseY, 3, 2, PAL.cup);
    drawRect(cupX + 1, baseY + 1, 1, 1, PAL.coffee);
    drawRect(cupX + 3, baseY + 1, 1, 1, PAL.cup);
  }

  if (count >= 3) {
    const steamX = baseX + (count - 1) * 4 + 1;
    const phase = frame % 20 < 10 ? 0 : 1;
    drawRect(steamX, baseY - 2 - phase, 1, 1, PAL.steam);
    drawRect(steamX + 1, baseY - 4 + phase, 1, 1, PAL.steam);
  }
}

function drawFire(screenX, screenY, frame) {
  const frames = [
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 2, c: PAL.fire2 }, { x: 3, y: 3, c: PAL.fire3 },
      { x: 4, y: 2, c: PAL.fire2 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 2, c: PAL.fire2 }, { x: 2, y: 3, c: PAL.fire1 }, { x: 3, y: 1, c: PAL.fire3 },
      { x: 4, y: 3, c: PAL.fire2 }, { x: 5, y: 2, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 1, c: PAL.fire3 }, { x: 3, y: 2, c: PAL.fire2 },
      { x: 4, y: 1, c: PAL.fire3 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
  ];
  const idx = frame % frames.length;
  frames[idx].forEach(p => drawRect(screenX + p.x, screenY + p.y, 1, 1, p.c));
}

function tokenBarColor(tokens) {
  if (tokens >= 100000) return PAL.tokenRed;
  if (tokens >= 50000) return PAL.tokenYellow;
  return PAL.tokenGreen;
}

function drawTokenBar(tileX, tileY, tokensUsed) {
  if (tokensUsed === null || tokensUsed === undefined) return;
  const tokens = Number(tokensUsed);
  if (!Number.isFinite(tokens)) return;
  const maxTokens = 100000;
  const barWidth = 12;
  const barHeight = 2;
  const px = tileX * TILE + 2;
  const py = tileY * TILE - 4;
  drawRect(px, py, barWidth, barHeight, PAL.tokenBg);
  const fill = Math.max(1, Math.round(barWidth * Math.min(tokens / maxTokens, 1)));
  drawRect(px, py, fill, barHeight, tokenBarColor(tokens));
}

function drawMonitorText(text, screenX, screenY, screenW, screenH, frame, color) {
  if (!text) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenX * SCALE, screenY * SCALE, screenW * SCALE, screenH * SCALE);
  ctx.clip();
  ctx.fillStyle = color;
  ctx.font = `${4 * SCALE}px Courier New`;
  ctx.textBaseline = 'top';
  const textWidth = ctx.measureText(text).width;
  const pad = 4 * SCALE;
  const scroll = (frame * 0.6) % (textWidth + screenW * SCALE + pad);
  const x = screenX * SCALE + screenW * SCALE - scroll;
  const y = screenY * SCALE + 1 * SCALE;
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawGroupDivider(leftDesk, rightDesk) {
  const midTileX = leftDesk.x + Math.floor((rightDesk.x - leftDesk.x) / 2);
  drawRect(midTileX * TILE + 7, leftDesk.y * TILE + 2, 2, 12, PAL.divider);
}

function drawGroupLabel(dx, dy, text) {
  if (!text) return;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(text).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 8) * SCALE - w / 2;
  const y = (dy * TILE - 14) * SCALE;
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = '#f0c040';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPrBadge(dx, dy, prNumber, merged) {
  const label = `PR #${prNumber}${merged ? ' ‚úì' : ''}`;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(label).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 12) * SCALE - w / 2;
  const y = (dy * TILE - 12) * SCALE;
  ctx.fillStyle = merged ? PAL.badgeGold : PAL.badgeGreen;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = PAL.badgeText;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPlant(px, py) {
  drawRect(px * TILE + 6, py * TILE + 4, 4, 6, PAL.plantPot);
  drawRect(px * TILE + 3, py * TILE, 10, 5, PAL.plant);
  drawRect(px * TILE + 5, py * TILE - 2, 6, 3, PAL.plant);
}

// === DRAW CHARACTER ===
function drawCharacter(tileX, tileY, colorIdx, state, frame, agentType) {
  const base = CHAR_COLORS[colorIdx % CHAR_COLORS.length];
  const shirt = agentType === 'codex' ? '#3fbf3f' : (agentType === 'claude' ? '#f08b2e' : base.shirt);
  const c = { ...base, shirt };
  const px = tileX * TILE;
  const py = tileY * TILE;
  const bob = Math.sin(frame * 0.15) > 0 ? 0 : 1;

  // body offset (sitting = higher up to align with chair)
  const sitting = state === 'coding' || state === 'reading' || state === 'waiting';
  const oy = sitting ? -2 : bob;

  // legs
  if (!sitting) {
    const walk = state === 'walking';
    const legOff = walk ? (Math.sin(frame * 0.3) > 0 ? 1 : -1) : 0;
    drawRect(px + 5, py + 11 + oy, 2, 4, c.pants);
    drawRect(px + 9, py + 11 + oy + legOff, 2, 4, c.pants);
  } else {
    // seated legs forward
    drawRect(px + 4, py + 11 + oy, 8, 2, c.pants);
  }

  // torso
  drawRect(px + 4, py + 6 + oy, 8, 5, c.shirt);

  // head
  drawRect(px + 5, py + 1 + oy, 6, 5, c.skin);
  // hair
  drawRect(px + 5, py + oy, 6, 2, c.hair);
  // hoodie hints
  drawRect(px + 4, py + 3 + oy, 1, 2, c.shirt);
  drawRect(px + 11, py + 3 + oy, 1, 2, c.shirt);

  // arms
  if (state === 'coding') {
    // arms forward (typing)
    const armBob = frame % 6 < 3 ? 0 : 1;
    drawRect(px + 2, py + 7 + oy, 2, 3, c.shirt);
    drawRect(px + 12, py + 7 + oy + armBob, 2, 3, c.shirt);
    // hands on desk
    drawRect(px + 2, py + 10 + oy, 2, 1, c.skin);
    drawRect(px + 12, py + 10 + oy + armBob, 2, 1, c.skin);
  } else if (state === 'reading') {
    // hand on chin
    drawRect(px + 2, py + 7 + oy, 2, 4, c.shirt);
    drawRect(px + 12, py + 7 + oy, 2, 2, c.shirt);
    drawRect(px + 12, py + 5 + oy, 2, 2, c.skin); // hand near face
  } else {
    // arms at sides
    drawRect(px + 2, py + 6 + oy, 2, 4, c.shirt);
    drawRect(px + 12, py + 6 + oy, 2, 4, c.shirt);
  }

  // eyes
  const blinking = frame % 60 < 3;
  if (!blinking) {
    drawRect(px + 6, py + 3 + oy, 1, 1, '#222');
    drawRect(px + 9, py + 3 + oy, 1, 1, '#222');
  }
}

// === SPEECH BUBBLE ===
function drawBubble(tileX, tileY, text, color = '#fff') {
  const px = tileX * TILE * SCALE;
  const py = (tileY * TILE - 10) * SCALE;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  const w = Math.max(text.length * 6 + 8, 30);
  ctx.fillRect(px - w/2 + S/2, py - 14, w, 14);
  ctx.fillStyle = color;
  ctx.font = '10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(text, px + S/2, py - 4);
  ctx.textAlign = 'left';
}

// === STATUS BAR ===
function drawStatusBar() {
  const y = ROWS * S;
  ctx.fillStyle = '#111';
  ctx.fillRect(0, y, CANVAS_W, S);
  ctx.fillStyle = '#888';
  ctx.font = '11px Courier New';
  const running = agents.filter(a => mapState(a) !== 'dead').length;
  ctx.fillText(`ü§† Corral | ${agents.length} agents | ${running} active`, 8, y + 20);
  const totalTokens = agents.reduce((sum, agent) => {
    const tokens = getTokensUsed(agent);
    return tokens === null ? sum : sum + tokens;
  }, 0);
  const hasTokens = agents.some(agent => getTokensUsed(agent) !== null);
  const tokensLabel = hasTokens ? `Tokens ${formatTokenCount(totalTokens)}` : 'Tokens ‚Äî';
  const now = new Date().toLocaleTimeString();
  const timeWidth = ctx.measureText(now).width;
  const tokensWidth = ctx.measureText(tokensLabel).width;
  const timeX = CANVAS_W - timeWidth - 8;
  const tokensX = Math.max(8, timeX - tokensWidth - 16);
  ctx.fillText(tokensLabel, tokensX, y + 20);
  ctx.fillText(now, timeX, y + 20);
}

// === MAP LASSO STATE ‚Üí ANIMATION STATE ===
function mapState(agent) {
  if (!agent) return 'idle';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  if (status.includes('dead') || status.includes('exited') || activity.includes('exited') || activity.includes('dead')) return 'dead';
  if (status.includes('pr_review') || status.includes('changes_requested')) return 'reading';
  if (status.includes('pr_open') || status.includes('ci') || status.includes('merged') || activity.includes('stale')) return 'waiting';
  if (status.includes('working') || activity.includes('active')) return 'coding';
  return 'idle';
}

function stateLabel(state) {
  switch(state) {
    case 'coding': return '‚å®Ô∏è coding';
    case 'reading': return 'üìñ review';
    case 'waiting': return '‚è≥ waiting';
    case 'dead': return 'üíÄ done';
    default: return 'üí§ idle';
  }
}

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY,
  };
}

function deskIndexAt(x, y) {
  for (let i = 0; i < DESKS.length; i++) {
    const desk = DESKS[i];
    const left = desk.x * S;
    const top = desk.y * S;
    const width = S;
    const height = S * 2;
    if (x >= left && x <= left + width && y >= top && y <= top + height) {
      return i;
    }
  }
  return null;
}

function tooltipSignature(agent) {
  if (!agent) return '';
  const reaction = getReaction(agent);
  return [
    agent.id,
    agent.status,
    agent.activity,
    agent.prNumber,
    agent.prUrl,
    agent.branch,
    agent.issueId,
    agent.issueTitle,
    agent.repo,
    agent.agentType,
    agent.createdAt,
    agent.tokensUsed,
    reaction.ciRetries,
    reaction.ciEscalated,
  ].join('|');
}

function positionTooltip(clientX, clientY) {
  const padding = 12;
  const maxX = window.innerWidth - 8;
  const maxY = window.innerHeight - 8;
  let left = clientX + padding;
  let top = clientY + padding;
  const { offsetWidth: w, offsetHeight: h } = tooltip;
  if (left + w > maxX) left = clientX - w - padding;
  if (top + h > maxY) top = clientY - h - padding;
  tooltip.style.left = `${Math.max(8, left)}px`;
  tooltip.style.top = `${Math.max(8, top)}px`;
}

function showTooltip(agent, clientX, clientY) {
  const signature = tooltipSignature(agent);
  if (signature !== hoveredSignature) {
    tooltip.innerHTML = buildTooltip(agent);
    hoveredSignature = signature;
  }
  tooltip.style.display = 'block';
  tooltip.setAttribute('aria-hidden', 'false');
  positionTooltip(clientX, clientY);
}

function hideTooltip() {
  hoveredDeskIndex = null;
  hoveredSignature = '';
  tooltip.style.display = 'none';
  tooltip.setAttribute('aria-hidden', 'true');
}

// === MAIN RENDER LOOP ===
let frame = 0;
function render(now) {
  if (lastRenderTime === null) lastRenderTime = now;
  const dt = Math.min(0.05, (now - lastRenderTime) / 1000);
  lastRenderTime = now;
  frame++;
  updateTransitions(now, dt);
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawFloor();
  drawDoor();

  const layout = buildLayout(agents);
  currentLayout = layout;
  const transitionByKey = new Map(transitions.map(transition => [transition.key, transition]));

  layout.dividers.forEach(divider => drawGroupDivider(divider.left.desk, divider.right.desk));

  // draw desks
  DESKS.forEach((d, i) => {
    const slot = layout.deskAgents[i];
    const agent = slot ? slot.agent : null;
    const transition = slot ? transitionByKey.get(slot.key) : null;
    const deskAgent = transition ? null : agent;
    const state = deskAgent ? mapState(deskAgent) : 'idle';
    drawDesk(d.x, d.y, deskAgent, state, frame);
  });

  // decorative plants
  drawPlant(0, 2);
  drawPlant(0, 8);
  drawPlant(COLS - 1, 5);

  layout.labels.forEach(label => drawGroupLabel(label.desk.x, label.desk.y, label.repo));

  // draw agents at desks
  layout.slots.forEach((slot, i) => {
    const agent = slot.agent;
    const desk = slot.desk;
    const transition = transitionByKey.get(slot.key);
    if (transition) return;
    const state = mapState(agent);
    if (state === 'dead') return; // ghost desk
    drawCharacter(desk.x, desk.y + 1, slot.idx, state, frame, resolveAgentType(agent));
    drawTokenBar(desk.x, desk.y + 1, getTokensUsed(agent));
    const prNumber = agent ? agent.prNumber : null;
    const status = (agent.status || '').toLowerCase();
    if (prNumber !== null && prNumber !== undefined) {
      drawPrBadge(desk.x, desk.y, prNumber, status.includes('merged'));
    }
    // bubble with repo/issue
    const repo = getRepoName(agent);
    const issueId = getIssueId(agent);
    const label = issueId ? `${repo}#${issueId}` : (repo || agent.id || `agent-${i}`);
    drawBubble(desk.x, desk.y, label, state === 'waiting' ? '#ff0' : '#fff');
  });

  // draw transitions
  transitions.forEach(transition => {
    if (now < transition.startAt) return;
    const pos = transitionPosition(transition, now);
    drawCharacter(pos.x, pos.y, transition.colorIdx, 'walking', frame, resolveAgentType(transition.agent));
  });

  drawStatusBar();
  requestAnimationFrame(render);
}

// === DATA LOADING ===
function loadDemo() {
  const now = Date.now();
  const demoAgents = [
    {
      id: 'codex-1',
      repo: 'zall',
      issueId: '7',
      issueTitle: 'Tighten input validation',
      status: 'running',
      agentType: 'codex',
      tokensUsed: 24350,
      createdAt: new Date(now - 30 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-2',
      repo: 'zall',
      issueId: '12',
      issueTitle: 'Add rate limiting',
      status: 'pr_open',
      agentType: 'codex',
      prNumber: 42,
      tokensUsed: 61200,
      createdAt: new Date(now - 2.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'claude-3',
      repo: 'lasso',
      issueId: '29',
      issueTitle: 'Refine lasso ingestion',
      status: 'running',
      agentType: 'claude',
      tokensUsed: 128400,
      createdAt: new Date(now - 5.5 * 60 * 60 * 1000).toISOString(),
      reactionState: { ciRetries: 2 },
    },
    {
      id: 'codex-4',
      repo: 'corral',
      issueId: '1',
      issueTitle: 'Rich visuals polish',
      status: 'ci_pending',
      agentType: 'codex',
      reactionState: { ciRetries: 3, ciEscalated: true },
      prNumber: 88,
      tokensUsed: 85400,
      createdAt: new Date(now - 4.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-5',
      repo: 'zall',
      issueId: '15',
      status: 'merged',
      agentType: 'codex',
      prNumber: 61,
      tokensUsed: 3220,
      createdAt: new Date(now - 90 * 60 * 1000).toISOString(),
    },
  ];
  setAgents(demoAgents);
}

function loadAgentsFile() {
  document.getElementById('fileInput').click();
}

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
      setAgents(nextAgents);
    } catch(err) { alert('Invalid JSON'); }
  };
  reader.readAsText(file);
}

async function refreshFromLasso() {
  try {
    const resp = await fetch('/api/agents');
    const data = await resp.json();
    const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
    setAgents(nextAgents);
    return true;
  } catch(e) {
    document.getElementById('info').textContent = 'Server not running ‚Äî start with: node server.js';
    return false;
  }
}

// Auto-poll every 5s
let polling = false;
async function startPolling() {
  if (polling) return;
  polling = true;
  document.getElementById('info').textContent = 'üîÑ Live mode ‚Äî polling every 5s';
  while (polling) {
    await refreshFromLasso();
    await new Promise(r => setTimeout(r, 5000));
  }
}
function stopPolling() { polling = false; }

function updateAgentsList() {
  const el = document.getElementById('agents-list');
  el.innerHTML = agents.map((a, i) => {
    const state = mapState(a);
    const repo = getRepoName(a);
    const issueId = getIssueId(a);
    return `<div class="agent-row">
      <span class="agent-name">${a.id || a.label || 'agent-' + i}</span>
      <span class="agent-repo">${repo}${issueId ? '#' + issueId : ''}</span>
      <span class="agent-status">${stateLabel(state)}</span>
    </div>`;
  }).join('');
  document.getElementById('info').textContent = `${agents.length} agents loaded`;
}

// drag & drop
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
        setAgents(nextAgents);
      } catch(err) { alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  }
});

canvas.addEventListener('mousemove', e => {
  if (!currentLayout) return;
  const { x, y } = getCanvasPoint(e);
  const idx = deskIndexAt(x, y);
  if (idx === null) {
    hideTooltip();
    return;
  }
  const slot = currentLayout.deskAgents[idx];
  if (!slot || !slot.agent) {
    hideTooltip();
    return;
  }
  if (transitions.some(transition => transition.key === slot.key)) {
    hideTooltip();
    return;
  }
  hoveredDeskIndex = idx;
  showTooltip(slot.agent, e.clientX, e.clientY);
});

canvas.addEventListener('mouseleave', () => hideTooltip());

canvas.addEventListener('click', e => {
  const pt = getCanvasPoint(e);
  const idx = deskIndexAt(pt.x, pt.y);
  if (idx === null || idx === undefined) return;
  const agent = agents[idx];
  if (!agent) return;
  if (currentLayout) {
    const slot = currentLayout.deskAgents[idx];
    if (slot && transitions.some(transition => transition.key === slot.key)) return;
  }
  const url = getAgentUrl(agent);
  if (url) window.open(url, '_blank');
});

// start
requestAnimationFrame(render);
// auto-connect to live server if available
refreshFromLasso().then(ok => { if (ok) startPolling(); });
</script>
</body>
</html>
