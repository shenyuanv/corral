<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ü§†</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: 'Courier New', monospace; color: #e0e0e0; }
  h1 { font-size: 18px; margin-bottom: 8px; color: #f0c040; }
  canvas { border: 2px solid #333; image-rendering: pixelated; image-rendering: crisp-edges; cursor: default; }
  #info { margin-top: 8px; font-size: 12px; color: #888; }
  #agents-list { margin-top: 12px; font-size: 11px; max-width: 640px; }
  .agent-row { display: flex; gap: 8px; padding: 2px 0; }
  .agent-name { color: #f0c040; min-width: 80px; }
  .agent-status { color: #8f8; }
  .agent-repo { color: #88f; }
  #controls { margin-top: 10px; display: flex; gap: 8px; }
  button { background: #333; color: #e0e0e0; border: 1px solid #555; padding: 4px 12px; font-family: inherit; font-size: 11px; cursor: pointer; }
  button:hover { background: #444; }
  button.active { background: #4a4a4a; border-color: #7a7a7a; color: #f0c040; }
  #tooltip {
    position: fixed;
    z-index: 10;
    display: none;
    max-width: 320px;
    padding: 8px 10px;
    font-size: 11px;
    line-height: 1.35;
    color: #e6e6e6;
    background: #15151f;
    border: 2px solid #4a4a62;
    box-shadow: 0 0 0 2px #0b0b12, 4px 4px 0 #0b0b12;
    pointer-events: none;
  }
  .tooltip-title { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; font-weight: bold; color: #f0c040; }
  .tooltip-row { display: flex; gap: 6px; margin: 2px 0; }
  .tooltip-label { min-width: 70px; color: #9aa0b5; }
  .tooltip-value { color: #e6e6e6; word-break: break-word; }
  .tooltip-muted { color: #8b8fa3; }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; box-shadow: 0 0 0 1px #0b0b12; }
  .status-active { background: #2f9a3d; }
  .status-waiting { background: #d1a128; }
  .status-ci { background: #c13c3c; }
  .status-merged { background: #d1a128; }
  .status-exited { background: #6c6c6c; }
  .status-dead { background: #6c6c6c; }
</style>
</head>
<body>
<h1>ü§† Corral</h1>
<canvas id="office" width="640" height="400"></canvas>
<div id="tooltip" role="tooltip" aria-hidden="true"></div>
<div id="info">Click "Load Agents" or drop agents.json to populate</div>
<div id="controls">
  <button onclick="loadAgentsFile()">Load agents.json</button>
  <button onclick="loadDemo()">Demo Mode</button>
  <button onclick="refreshFromLasso()">Refresh</button>
  <button onclick="startPolling()">‚ñ∂ Live</button>
  <button onclick="stopPolling()">‚èπ Stop</button>
  <button id="soundToggle" onclick="toggleSound()">üîá Sound</button>
</div>
<div id="agents-list"></div>

<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFile(event)">

<script>
// === CONSTANTS ===
const TILE = 16;
const SCALE = 2;
const S = TILE * SCALE; // rendered tile size
const COLS = 20;
const ROWS = 12; // 640x384 at scale 2
const DESK_COLS = 4;
const DESK_ROWS = 3;
const DESK_START_X = 2;
const DESK_START_Y = 2;
const DESK_GAP_X = 5;
const DESK_GAP_Y = 3;
const CANVAS_W = COLS * S;
const OFFICE_H = ROWS * S;
const TIMELINE_MAX_ROWS = 20;
const TIMELINE_ROW_HEIGHT = 12;
const TIMELINE_BAR_HEIGHT = 4;
const TIMELINE_HEADER_HEIGHT = 18;
const TIMELINE_PADDING = 8;
const TIMELINE_LABEL_WIDTH = 150;
const TIMELINE_HEIGHT = TIMELINE_HEADER_HEIGHT + TIMELINE_PADDING * 2 + TIMELINE_ROW_HEIGHT * TIMELINE_MAX_ROWS;
const TIMELINE_Y = OFFICE_H;
const CANVAS_H = OFFICE_H + TIMELINE_HEIGHT + S; // office + timeline + status bar
const DOOR_TILE = { x: 0, y: 6 };
const WALK_SPEED = 2; // tiles per second
const ENTER_STAGGER = 0.5; // seconds
const CONFETTI_COUNT_MIN = 20;
const CONFETTI_COUNT_MAX = 30;
const CONFETTI_SIZE = 2; // base pixels
const CONFETTI_LIFE = 2.0; // seconds
const CONFETTI_GRAVITY = 70; // px/s^2
const CONFETTI_COLORS = ['#f0c040', '#4ae04a', '#ffffff', '#d1a128'];
const CELEBRATION_TEXT_DURATION = 900; // ms
const CELEBRATION_FLASH_DURATION = 450; // ms
const CELEBRATION_TOTAL_DURATION = 2000; // ms

const canvas = document.getElementById('office');
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const tooltip = document.getElementById('tooltip');

// === COLORS (pixel art palette) ===
const BASE_PAL = {
  floor: '#3a3a5c',
  floorAlt: '#33334f',
  wall: '#5c5c8a',
  wallTop: '#7a7ab0',
  desk: '#8b6914',
  deskTop: '#c49b2a',
  monitor: '#222',
  monitorScreen: '#0f380f',
  monitorScreenActive: '#4ae04a',
  monitorScreenCi: '#ff3b3b',
  monitorScreenCiDark: '#7a1111',
  chair: '#444',
  plant: '#2d5a1e',
  plantPot: '#8b5e3c',
  divider: '#26263b',
  badgeGreen: '#2f9a3d',
  badgeGold: '#d1a128',
  badgeText: '#111',
  cup: '#d9d9d9',
  coffee: '#5a3a1a',
  steam: '#e5e5e5',
  fire1: '#f04',
  fire2: '#f80',
  fire3: '#ff0',
  tokenGreen: '#2f9a3d',
  tokenYellow: '#d1a128',
  tokenRed: '#c13c3c',
  tokenBg: '#0b0b12',
};
let PAL = { ...BASE_PAL };

const TIMELINE_COLORS = {
  working: '#3b7cff',
  pr: '#3adf7a',
  ciFailed: '#ff5c5c',
  merged: '#f0c040',
  dead: '#6c6c6c',
  axis: '#2a2a3f',
  grid: '#242438',
  label: '#c9cedf',
  muted: '#7b8096',
  now: '#f7e28a',
};

// === CHARACTER COLORS ===
const CHAR_COLORS = [
  { skin: '#f5c6a0', hair: '#4a2800', shirt: '#e04040', pants: '#3050a0' }, // red
  { skin: '#d4a373', hair: '#1a1a2e', shirt: '#4080e0', pants: '#2a2a4e' }, // blue
  { skin: '#f5deb3', hair: '#c04000', shirt: '#40c040', pants: '#404040' }, // green
  { skin: '#c49b6a', hair: '#222', shirt: '#e0a040', pants: '#3a3a5c' },   // gold
  { skin: '#f0d0b0', hair: '#604020', shirt: '#a040c0', pants: '#333' },    // purple
  { skin: '#e8c090', hair: '#802020', shirt: '#40c0c0', pants: '#2a2a4e' }, // teal
];

const MONITOR = {
  w: 8,
  h: 6,
  screenX: 1,
  screenY: 1,
  screenW: 6,
  screenH: 4,
  standW: 4,
  standH: 2,
};

// === DESK POSITIONS ===
const DESKS = [];
for (let row = 0; row < DESK_ROWS; row++) {
  for (let col = 0; col < DESK_COLS; col++) {
    DESKS.push({ x: DESK_START_X + col * DESK_GAP_X, y: DESK_START_Y + row * DESK_GAP_Y });
  }
}

// === TIME + WINDOW SETTINGS ===
const WINDOW = { x: Math.floor(COLS / 2) - 2, y: 0, w: 4, h: 1 };
const TIME_TRANSITION_MINUTES = 30;
const TIME_PHASES = {
  day: {
    brightness: 1.05,
    tint: { r: 1.02, g: 1.04, b: 1.08 },
    sky: '#7ec8ff',
    sun: '#ffe39a',
    sunAlpha: 1,
    starAlpha: 0,
    lamp: 0,
    monitorGlow: 0.05,
    monitorBoost: 1.0,
  },
  sunset: {
    brightness: 0.9,
    tint: { r: 1.08, g: 0.98, b: 0.9 },
    sky: '#f7a062',
    sun: '#ffd08a',
    sunAlpha: 0.6,
    starAlpha: 0.2,
    lamp: 0.55,
    monitorGlow: 0.3,
    monitorBoost: 1.1,
  },
  night: {
    brightness: 0.55,
    tint: { r: 0.8, g: 0.85, b: 1.0 },
    sky: '#0a1029',
    sun: '#ffe39a',
    sunAlpha: 0,
    starAlpha: 1,
    lamp: 1,
    monitorGlow: 0.9,
    monitorBoost: 1.5,
  },
  sunrise: {
    brightness: 0.85,
    tint: { r: 1.05, g: 0.98, b: 0.95 },
    sky: '#f6b4a0',
    sun: '#ffd7a0',
    sunAlpha: 0.6,
    starAlpha: 0.35,
    lamp: 0.35,
    monitorGlow: 0.35,
    monitorBoost: 1.15,
  },
};

// === AGENT STATE ===
let agents = [];
let currentLayout = null;
let hoveredDeskIndex = null;
let hoveredSignature = '';
let transitions = [];
let hasInitialized = false;
let lastRenderTime = null;
let timeState = null;
let windowStars = [];
let windowStarSeed = null;
let previousAgentsByKey = new Map();
let historyEntries = [];
let timelineEntries = [];
let timelineLayout = null;
let timelineScroll = 0;
let timelineHover = null;
const mergedAgents = new Set();
const confettiPool = [];
const confettiActive = [];
const celebrations = [];
const celebrationByKey = new Map();
let soundEnabled = false;
let audioCtx = null;

// === DRAWING HELPERS ===
function fillTile(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * S, y * S, S, S);
}

function drawRect(px, py, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(px * SCALE, py * SCALE, w * SCALE, h * SCALE);
}

// === TIME + COLOR HELPERS ===
function clampByte(value) {
  return Math.max(0, Math.min(255, Math.round(value)));
}

function hexToRgb(hex) {
  const clean = hex.replace('#', '').trim();
  if (clean.length === 3) {
    const r = parseInt(clean[0] + clean[0], 16);
    const g = parseInt(clean[1] + clean[1], 16);
    const b = parseInt(clean[2] + clean[2], 16);
    return { r, g, b };
  }
  const num = parseInt(clean, 16);
  return {
    r: (num >> 16) & 255,
    g: (num >> 8) & 255,
    b: num & 255,
  };
}

function rgbToHex({ r, g, b }) {
  const rr = clampByte(r).toString(16).padStart(2, '0');
  const gg = clampByte(g).toString(16).padStart(2, '0');
  const bb = clampByte(b).toString(16).padStart(2, '0');
  return `#${rr}${gg}${bb}`;
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function lerpHex(a, b, t) {
  const ar = hexToRgb(a);
  const br = hexToRgb(b);
  return rgbToHex({
    r: lerp(ar.r, br.r, t),
    g: lerp(ar.g, br.g, t),
    b: lerp(ar.b, br.b, t),
  });
}

function applyTone(hex, brightness, tint) {
  const rgb = hexToRgb(hex);
  return rgbToHex({
    r: rgb.r * brightness * tint.r,
    g: rgb.g * brightness * tint.g,
    b: rgb.b * brightness * tint.b,
  });
}

function boostColor(hex, boost) {
  if (boost === 1) return hex;
  const rgb = hexToRgb(hex);
  return rgbToHex({
    r: rgb.r * boost,
    g: rgb.g * boost,
    b: rgb.b * boost,
  });
}

function hashString(input) {
  let hash = 2166136261;
  for (let i = 0; i < input.length; i++) {
    hash ^= input.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}

function mulberry32(seed) {
  return function() {
    let t = seed += 0x6d2b79f5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function ensureWindowStars(seed, width, height) {
  if (windowStarSeed === seed && windowStars.length) return;
  windowStarSeed = seed;
  const rng = mulberry32(hashString(seed));
  const count = Math.max(6, Math.floor((width * height) / 36));
  windowStars = [];
  for (let i = 0; i < count; i++) {
    windowStars.push({
      x: Math.floor(rng() * width),
      y: Math.floor(rng() * height),
      twinkle: rng() * Math.PI * 2,
    });
  }
}

function getTimeBlend(minutes) {
  const transitions = [
    { at: 6 * 60, from: 'night', to: 'sunrise' },
    { at: 8 * 60, from: 'sunrise', to: 'day' },
    { at: 17 * 60, from: 'day', to: 'sunset' },
    { at: 19 * 60, from: 'sunset', to: 'night' },
  ];
  for (const transition of transitions) {
    const start = transition.at - TIME_TRANSITION_MINUTES;
    if (minutes >= start && minutes < transition.at) {
      const blend = (minutes - start) / TIME_TRANSITION_MINUTES;
      return { from: transition.from, to: transition.to, blend };
    }
  }
  let phase = 'day';
  if (minutes >= 8 * 60 && minutes < 17 * 60) phase = 'day';
  else if (minutes >= 17 * 60 && minutes < 19 * 60) phase = 'sunset';
  else if (minutes >= 19 * 60 || minutes < 6 * 60) phase = 'night';
  else phase = 'sunrise';
  return { from: phase, to: phase, blend: 0 };
}

function blendPhaseSettings(fromKey, toKey, blend) {
  const from = TIME_PHASES[fromKey];
  const to = TIME_PHASES[toKey];
  return {
    phase: fromKey,
    nextPhase: toKey,
    blend,
    brightness: lerp(from.brightness, to.brightness, blend),
    tint: {
      r: lerp(from.tint.r, to.tint.r, blend),
      g: lerp(from.tint.g, to.tint.g, blend),
      b: lerp(from.tint.b, to.tint.b, blend),
    },
    sky: lerpHex(from.sky, to.sky, blend),
    sun: lerpHex(from.sun, to.sun, blend),
    sunAlpha: lerp(from.sunAlpha, to.sunAlpha, blend),
    starAlpha: lerp(from.starAlpha, to.starAlpha, blend),
    lamp: lerp(from.lamp, to.lamp, blend),
    monitorGlow: lerp(from.monitorGlow, to.monitorGlow, blend),
    monitorBoost: lerp(from.monitorBoost, to.monitorBoost, blend),
  };
}

function getTimeSettings(hour, minute) {
  const minutes = ((hour * 60) + minute) % 1440;
  const dayFactor = minutes / 1440;
  const blendInfo = getTimeBlend(minutes);
  const settings = blendPhaseSettings(blendInfo.from, blendInfo.to, blendInfo.blend);
  return { ...settings, dayFactor };
}

function getTimeColors(hour, minute, settings) {
  const state = settings || getTimeSettings(hour, minute);
  const palette = {};
  Object.keys(BASE_PAL).forEach((key) => {
    palette[key] = applyTone(BASE_PAL[key], state.brightness, state.tint);
  });
  const boost = state.monitorBoost;
  palette.monitorScreen = boostColor(palette.monitorScreen, boost);
  palette.monitorScreenActive = boostColor(palette.monitorScreenActive, boost);
  palette.monitorScreenCi = boostColor(palette.monitorScreenCi, boost);
  palette.monitorScreenCiDark = boostColor(palette.monitorScreenCiDark, boost);
  palette.windowSky = state.sky;
  palette.windowSun = state.sun;
  palette.star = '#f8f8ff';
  palette.lampGlow = '#ffd27a';
  return palette;
}

function getTimeState(hour, minute) {
  const settings = getTimeSettings(hour, minute);
  const palette = getTimeColors(hour, minute, settings);
  return { ...settings, palette };
}

function updateSoundButton() {
  const btn = document.getElementById('soundToggle');
  if (!btn) return;
  btn.textContent = soundEnabled ? 'üîä Sound' : 'üîá Sound';
  btn.classList.toggle('active', soundEnabled);
}

function initAudio() {
  if (!audioCtx) {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = AudioContext ? new AudioContext() : null;
  }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  updateSoundButton();
  if (soundEnabled) {
    initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }
}

function playDing() {
  if (!soundEnabled) return;
  initAudio();
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(880, t);
  osc.frequency.exponentialRampToValueAtTime(440, t + 0.12);
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.08, t + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.3);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + 0.32);
}

// === DATA HELPERS ===
function getRepoName(agent) {
  if (!agent) return '';
  return (agent.repo || '').split('/').pop() || '';
}

function getIssueId(agent) {
  if (!agent) return '';
  return agent.issueId ?? agent.issue ?? agent.issueID ?? '';
}

function resolveAgentType(agent) {
  if (!agent) return '';
  return (agent.agentType || agent.agent || agent.type || '').toLowerCase();
}

function getMonitorText(agent) {
  if (!agent) return '';
  const issueTitle = (agent.issueTitle || '').toString().trim();
  if (issueTitle) return issueTitle;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  if (repo && issueId) return `${repo}#${issueId}`;
  return repo || agent.id || '';
}

function getReaction(agent) {
  return agent && agent.reactionState ? agent.reactionState : {};
}

function getTokensUsed(agent) {
  if (!agent) return null;
  const value = agent.tokensUsed ?? agent.tokens_used ?? agent.tokenUsage ?? agent.token_usage;
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string' && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return null;
}

function isMergedStatus(agent) {
  if (!agent) return false;
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  return status.includes('merged') || activity.includes('merged');
}

function getAgentUrl(agent) {
  if (!agent) return '';
  const prUrl = agent.prUrl || agent.prURL || agent.pullRequestUrl || agent.pull_request_url;
  if (typeof prUrl === 'string' && prUrl.trim()) return prUrl.trim();
  const repo = typeof agent.repo === 'string' ? agent.repo.trim() : '';
  const issueId = getIssueId(agent);
  const issueIdStr = issueId !== null && issueId !== undefined ? String(issueId).trim() : '';
  if (repo && issueIdStr) return `https://github.com/${repo}/issues/${issueIdStr}`;
  return '';
}

function escapeHtml(value) {
  return String(value ?? '').replace(/[&<>"']/g, char => {
    switch (char) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return char;
    }
  });
}

function formatDuration(ms) {
  const totalMins = Math.max(0, Math.floor(ms / 60000));
  const hours = Math.floor(totalMins / 60);
  const mins = totalMins % 60;
  if (hours > 0) return `${hours}h ${mins}m`;
  return `${mins}m`;
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function coerceMs(value) {
  if (typeof value === 'number' && Number.isFinite(value)) {
    if (value > 1e12) return value;
    if (value > 1e9) return value * 1000;
  }
  if (typeof value === 'string' && value.trim()) {
    const num = Number(value);
    if (Number.isFinite(num)) return coerceMs(num);
    const parsed = Date.parse(value);
    if (!Number.isNaN(parsed)) return parsed;
  }
  return null;
}

function normalizeHistoryEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const next = { ...entry };
  if (!Array.isArray(next.statusHistory)) next.statusHistory = [];
  return next;
}

function entryId(entry, fallbackIndex) {
  if (!entry) return `agent-${fallbackIndex}`;
  const id = (entry.id || entry.agentId || entry.sessionId || entry.name || '').toString().trim();
  if (id) return id;
  return agentKey(entry, fallbackIndex);
}

function mergeTimelineEntries(activeAgents, historyList) {
  const historyMap = new Map();
  historyList.map(normalizeHistoryEntry).forEach((entry) => {
    if (entry && entry.id) historyMap.set(entry.id, entry);
  });

  const merged = [];
  activeAgents.forEach((agent, index) => {
    const id = entryId(agent, index);
    const historyEntry = historyMap.get(id);
    const createdAt = coerceMs(agent.createdAt) || coerceMs(historyEntry && historyEntry.createdAt) || Date.now();
    const entry = {
      id,
      repo: agent.repo || (historyEntry && historyEntry.repo),
      issueId: agent.issueId || agent.issue_id || (historyEntry && historyEntry.issueId),
      issueTitle: agent.issueTitle || agent.issue_title || (historyEntry && historyEntry.issueTitle),
      status: agent.status || (historyEntry && historyEntry.status) || '',
      activity: agent.activity || (historyEntry && historyEntry.activity) || '',
      agentType: agent.agentType || agent.agent_type || (historyEntry && historyEntry.agentType),
      createdAt: new Date(createdAt).toISOString(),
      endedAt: null,
      prNumber: agent.prNumber || agent.pr_number || (historyEntry && historyEntry.prNumber),
      statusHistory: (historyEntry && historyEntry.statusHistory) ? historyEntry.statusHistory.slice() : [],
      isActive: true,
      source: agent,
    };
    merged.push(entry);
    historyMap.delete(id);
  });

  historyMap.forEach((entry) => {
    const createdAt = coerceMs(entry.createdAt) || Date.now();
    merged.push({
      ...entry,
      createdAt: new Date(createdAt).toISOString(),
      endedAt: entry.endedAt || null,
      status: entry.status || '',
      activity: entry.activity || '',
      statusHistory: Array.isArray(entry.statusHistory) ? entry.statusHistory.slice() : [],
      isActive: false,
      source: entry,
    });
  });

  merged.sort((a, b) => {
    if (a.isActive !== b.isActive) return a.isActive ? -1 : 1;
    const aTime = a.isActive ? coerceMs(a.createdAt) : (coerceMs(a.endedAt) || coerceMs(a.createdAt));
    const bTime = b.isActive ? coerceMs(b.createdAt) : (coerceMs(b.endedAt) || coerceMs(b.createdAt));
    return (bTime || 0) - (aTime || 0);
  });

  return merged;
}

function updateTimelineEntries() {
  timelineEntries = mergeTimelineEntries(agents, historyEntries);
  const maxScroll = Math.max(0, timelineEntries.length - TIMELINE_MAX_ROWS);
  timelineScroll = clamp(timelineScroll, 0, maxScroll);
}

function agentKey(agent, fallbackIndex) {
  if (!agent) return `agent-${fallbackIndex}`;
  const id = (agent.id || agent.label || agent.agentId || agent.name || '').toString().trim();
  if (id) return id;
  const repo = getRepoName(agent);
  const issueId = getIssueId(agent);
  const created = (agent.createdAt || '').toString().trim();
  if (repo || issueId || created) return `${repo}#${issueId}-${created}`;
  return `agent-${fallbackIndex}`;
}

function buildPath(start, end) {
  const mid = { x: end.x, y: start.y };
  const seg1 = Math.abs(mid.x - start.x) + Math.abs(mid.y - start.y);
  const seg2 = Math.abs(end.x - mid.x) + Math.abs(end.y - mid.y);
  return {
    start: { ...start },
    mid,
    end: { ...end },
    seg1,
    seg2,
    total: seg1 + seg2,
  };
}

function positionAlongPath(path, dist) {
  if (path.total === 0) return { x: path.end.x, y: path.end.y };
  if (dist <= path.seg1) {
    const dx = path.mid.x - path.start.x;
    const dy = path.mid.y - path.start.y;
    const stepX = dx === 0 ? 0 : Math.sign(dx) * dist;
    const stepY = dy === 0 ? 0 : Math.sign(dy) * dist;
    return { x: path.start.x + stepX, y: path.start.y + stepY };
  }
  const remaining = dist - path.seg1;
  const dx = path.end.x - path.mid.x;
  const dy = path.end.y - path.mid.y;
  const stepX = dx === 0 ? 0 : Math.sign(dx) * remaining;
  const stepY = dy === 0 ? 0 : Math.sign(dy) * remaining;
  return { x: path.mid.x + stepX, y: path.mid.y + stepY };
}

function transitionPosition(transition, now) {
  const progress = now < transition.startAt ? 0 : Math.min(transition.progress, transition.path.total);
  return positionAlongPath(transition.path, progress);
}

function makeTransition({ key, agent, type, start, end, startAt, colorIdx }) {
  return {
    key,
    agent,
    type,
    path: buildPath(start, end),
    progress: 0,
    startAt,
    colorIdx,
  };
}

function reverseTransition(transition, type, end, now) {
  const start = transitionPosition(transition, now);
  transition.type = type;
  transition.path = buildPath(start, end);
  transition.progress = 0;
  transition.startAt = now;
}

function mapSlotsByKey(layout) {
  const map = new Map();
  layout.slots.forEach(slot => {
    map.set(slot.key, slot);
  });
  return map;
}

function storePreviousAgents(list) {
  const map = new Map();
  list.forEach((agent, index) => {
    map.set(agentKey(agent, index), agent);
  });
  previousAgentsByKey = map;
}

function updateTransitions(now, dt) {
  if (!transitions.length) return;
  transitions = transitions.filter(transition => {
    if (now < transition.startAt) return true;
    if (transition.path.total === 0) return false;
    if (dt > 0) {
      transition.progress = Math.min(transition.path.total, transition.progress + dt * WALK_SPEED);
    }
    return transition.progress < transition.path.total;
  });
}

function setAgents(nextAgents, { skipAnimation = false } = {}) {
  const prevAgents = agents;
  const prevLayout = buildLayout(prevAgents);
  const nextLayout = buildLayout(nextAgents);
  const prevSlotsByKey = mapSlotsByKey(prevLayout);
  const nextSlotsByKey = mapSlotsByKey(nextLayout);
  const now = performance.now();
  if (hasInitialized && previousAgentsByKey.size > 0) {
    nextLayout.slots.forEach(slot => {
      const key = slot.key;
      const prevAgent = previousAgentsByKey.get(key);
      if (!prevAgent) return;
      if (mergedAgents.has(key)) return;
      if (!isMergedStatus(prevAgent) && isMergedStatus(slot.agent)) {
        mergedAgents.add(key);
        startCelebration(slot, now);
      }
    });
  }

  if (!hasInitialized || skipAnimation) {
    agents = nextAgents;
    transitions = [];
    hasInitialized = true;
    updateAgentsList();
    storePreviousAgents(nextAgents);
    updateTimelineEntries();
    return;
  }

  transitions.forEach(transition => {
    const nextSlot = nextSlotsByKey.get(transition.key);
    if (transition.type === 'enter') {
      const shouldExit = !nextSlot || mapState(nextSlot.agent) === 'dead';
      if (shouldExit) {
        reverseTransition(transition, 'exit', DOOR_TILE, now);
      } else {
        transition.agent = nextSlot.agent;
      }
      return;
    }
    if (transition.type === 'exit') {
      if (nextSlot && mapState(nextSlot.agent) !== 'dead') {
        reverseTransition(transition, 'enter', { x: nextSlot.desk.x, y: nextSlot.desk.y + 1 }, now);
        transition.agent = nextSlot.agent;
      } else if (nextSlot) {
        transition.agent = nextSlot.agent;
      }
    }
  });

  const transitionKeys = new Set(transitions.map(transition => transition.key));
  const enteringSlots = [];
  nextSlotsByKey.forEach(slot => {
    if (!prevSlotsByKey.has(slot.key)) enteringSlots.push(slot);
  });
  const exitingSlots = [];
  prevSlotsByKey.forEach(slot => {
    if (!nextSlotsByKey.has(slot.key)) exitingSlots.push(slot);
  });

  enteringSlots.forEach((slot, index) => {
    if (transitionKeys.has(slot.key)) return;
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'enter',
      start: DOOR_TILE,
      end: { x: slot.desk.x, y: slot.desk.y + 1 },
      startAt: now + index * ENTER_STAGGER * 1000,
      colorIdx: slot.idx,
    }));
  });

  exitingSlots.forEach(slot => {
    if (transitionKeys.has(slot.key)) return;
    transitions.push(makeTransition({
      key: slot.key,
      agent: slot.agent,
      type: 'exit',
      start: { x: slot.desk.x, y: slot.desk.y + 1 },
      end: DOOR_TILE,
      startAt: now,
      colorIdx: slot.idx,
    }));
  });

  agents = nextAgents;
  hasInitialized = true;
  updateAgentsList();
  storePreviousAgents(nextAgents);
  updateTimelineEntries();
}

function runtimeLabel(agent) {
  if (!agent || !agent.createdAt) return 'Unknown';
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 'Unknown';
  const diff = Math.max(0, Date.now() - ts);
  const isDone = isDoneState(mapState(agent));
  const verb = isDone ? 'Ran for' : 'Running for';
  return `${verb} ${formatDuration(diff)}`;
}

function formatRepoIssue(agent) {
  if (!agent) return 'Unknown';
  const repo = agent.repo || '';
  const issueId = getIssueId(agent);
  const title = (agent.issueTitle || '').toString().trim();
  if (repo && issueId) {
    return title ? `${repo} #${issueId} ‚Äî ${title}` : `${repo} #${issueId}`;
  }
  if (repo) return title ? `${repo} ‚Äî ${title}` : repo;
  return title || agent.id || 'Unknown';
}

function formatStatus(agent) {
  if (!agent) return 'unknown';
  const status = (agent.status || '').toString().trim();
  const activity = (agent.activity || '').toString().trim();
  if (status && activity && status !== activity) return `${status} (${activity})`;
  return status || activity || 'unknown';
}

function formatTokenCount(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '‚Äî';
  if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1).replace(/\.0$/, '')}m`;
  if (value >= 1_000) return `${(value / 1_000).toFixed(1).replace(/\.0$/, '')}k`;
  return `${Math.round(value)}`;
}

function formatTokenDetail(value) {
  if (typeof value !== 'number' || !Number.isFinite(value)) return '‚Äî';
  return Math.round(value).toLocaleString();
}

function formatCiState(agent) {
  const reaction = getReaction(agent);
  const retries = Number(reaction.ciRetries || 0);
  const status = (agent && agent.status ? agent.status : '').toLowerCase();
  const failing = !!reaction.ciEscalated || status.includes('ci_failed') || status.includes('failed');
  const state = failing ? 'failing' : 'passing';
  return `${state} (retries: ${retries})`;
}

function statusDotClass(agent) {
  if (!agent) return 'status-dead';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  const reaction = getReaction(agent);
  const state = mapState(agent);
  if (state === 'merged') return 'status-merged';
  if (state === 'exited') return 'status-exited';
  if (state === 'dead') return 'status-dead';
  if (reaction.ciEscalated || status.includes('ci_failed') || status.includes('failed')) return 'status-ci';
  if (status.includes('pr_open') || status.includes('merged') || status.includes('ci') || activity.includes('stale') || state === 'waiting') {
    return 'status-waiting';
  }
  return 'status-active';
}

function buildTooltip(agent) {
  if (!agent) return '';
  const agentId = escapeHtml(agent.id || agent.label || 'agent');
  const agentType = escapeHtml(resolveAgentType(agent) || 'unknown');
  const repoIssue = escapeHtml(formatRepoIssue(agent));
  const status = escapeHtml(formatStatus(agent));
  const runtime = escapeHtml(runtimeLabel(agent));
  const branch = escapeHtml(agent.branch || 'unknown');
  const tokensUsed = getTokensUsed(agent);
  const tokensLabel = escapeHtml(formatTokenDetail(tokensUsed));
  const prNumber = agent.prNumber ?? '';
  const prUrl = agent.prUrl || '';
  const prLabel = prNumber !== '' && prNumber !== null ? `PR #${prNumber}` : (prUrl ? 'PR link' : '‚Äî');
  const prValue = escapeHtml(prLabel + (prUrl ? ` ‚Äî ${prUrl}` : ''));
  const ciState = escapeHtml(formatCiState(agent));
  return `
    <div class="tooltip-title">
      <span class="status-dot ${statusDotClass(agent)}"></span>
      <span>${agentId}</span>
    </div>
    <div class="tooltip-row"><span class="tooltip-label">Type</span><span class="tooltip-value">${agentType}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Repo/Issue</span><span class="tooltip-value">${repoIssue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Status</span><span class="tooltip-value">${status}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Runtime</span><span class="tooltip-value">${runtime}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Tokens</span><span class="tooltip-value">${tokensLabel}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">PR</span><span class="tooltip-value">${prValue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">CI</span><span class="tooltip-value">${ciState}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Branch</span><span class="tooltip-value">${branch}</span></div>
  `;
}

function hoursRunning(agent) {
  if (!agent || !agent.createdAt) return 0;
  const ts = Date.parse(agent.createdAt);
  if (Number.isNaN(ts)) return 0;
  return Math.max(0, (Date.now() - ts) / 3600000);
}

function coffeeCount(agent) {
  const hours = hoursRunning(agent);
  if (hours < 1) return 0;
  if (hours < 2) return 1;
  if (hours < 4) return 2;
  return 3;
}

function buildLayout(list) {
  const groups = [];
  const byRepo = new Map();
  list.forEach((agent, index) => {
    const repo = getRepoName(agent) || 'unknown';
    if (!byRepo.has(repo)) {
      const g = { repo, agents: [] };
      byRepo.set(repo, g);
      groups.push(g);
    }
    byRepo.get(repo).agents.push({ agent, repo, index });
  });

  const ordered = [];
  groups.forEach(group => group.agents.forEach(item => ordered.push(item)));

  const slots = [];
  const deskAgents = new Array(DESKS.length).fill(null);
  const firstIndex = new Map();
  const maxCount = Math.min(ordered.length, DESKS.length);
  for (let i = 0; i < maxCount; i++) {
    const item = ordered[i];
    const desk = DESKS[i];
    const row = Math.floor(i / DESK_COLS);
    const col = i % DESK_COLS;
    const key = agentKey(item.agent, item.index);
    const slot = { ...item, idx: i, desk, row, col, key };
    slots.push(slot);
    deskAgents[i] = slot;
    if (!firstIndex.has(item.repo)) firstIndex.set(item.repo, i);
  }

  const labels = [];
  for (const [repo, idx] of firstIndex.entries()) {
    const slot = slots[idx];
    if (slot) labels.push({ repo, desk: slot.desk, row: slot.row, col: slot.col });
  }

  const dividers = [];
  for (let i = 1; i < slots.length; i++) {
    if (slots[i].repo !== slots[i - 1].repo && slots[i].row === slots[i - 1].row) {
      dividers.push({ left: slots[i - 1], right: slots[i] });
    }
  }

  return { slots, deskAgents, labels, dividers };
}

// === DRAW OFFICE ===
function drawFloor() {
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      fillTile(x, y, (x + y) % 2 === 0 ? PAL.floor : PAL.floorAlt);
    }
  }
  // top wall
  for (let x = 0; x < COLS; x++) {
    fillTile(x, 0, PAL.wall);
    drawRect(x * TILE, 0, TILE, 4, PAL.wallTop);
  }
  drawWindow();
}

function drawWindow() {
  if (!timeState) return;
  const px = WINDOW.x * TILE;
  const py = WINDOW.y * TILE + 2;
  const w = WINDOW.w * TILE;
  const h = 10;
  const innerX = px + 1;
  const innerY = py + 1;
  const innerW = w - 2;
  const innerH = h - 2;

  drawRect(px, py, w, h, PAL.wallTop);
  drawRect(innerX, innerY, innerW, innerH, PAL.windowSky);
  drawRect(px + Math.floor(w / 2) - 1, innerY, 2, innerH, PAL.wall);

  if (timeState.starAlpha > 0.05) {
    const now = new Date();
    const starSeed = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
    ensureWindowStars(starSeed, innerW, innerH);
    ctx.save();
    ctx.globalAlpha = timeState.starAlpha;
    windowStars.forEach(star => {
      drawRect(innerX + star.x, innerY + star.y, 1, 1, PAL.star);
    });
    ctx.restore();
  }

  if (timeState.sunAlpha > 0.05) {
    ctx.save();
    ctx.globalAlpha = timeState.sunAlpha;
    drawRect(innerX + innerW - 5, innerY + 2, 3, 3, PAL.windowSun);
    ctx.restore();
  }
}

function drawDoor() {
  const px = DOOR_TILE.x * TILE;
  const py = DOOR_TILE.y * TILE;
  drawRect(px + 1, py + 1, 14, 14, '#7a4b1f');
  drawRect(px + 11, py + 8, 2, 2, '#d8c28a');
}

function drawLampGlow(tileX, tileY, intensity) {
  if (intensity <= 0) return;
  const cx = (tileX * TILE + 9) * SCALE;
  const cy = (tileY * TILE + 7) * SCALE;
  const radius = 7 * SCALE;
  ctx.save();
  ctx.globalAlpha = 0.18 * intensity;
  ctx.fillStyle = PAL.lampGlow;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawMonitorGlow(tileX, tileY, intensity) {
  if (intensity <= 0) return;
  const cx = (tileX * TILE + 4 + MONITOR.screenX + MONITOR.screenW / 2) * SCALE;
  const cy = (tileY * TILE + MONITOR.screenY + MONITOR.screenH / 2) * SCALE;
  const radius = 6 * SCALE;
  ctx.save();
  ctx.globalAlpha = 0.16 * intensity;
  ctx.fillStyle = PAL.monitorScreenActive;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawMonitorCheck(screenX, screenY, color) {
  drawRect(screenX + 1, screenY + 2, 1, 1, color);
  drawRect(screenX + 2, screenY + 3, 1, 1, color);
  drawRect(screenX + 3, screenY + 2, 1, 1, color);
  drawRect(screenX + 4, screenY + 1, 1, 1, color);
}

function drawMonitor(dx, dy, agent, state, frame) {
  const baseX = dx * TILE + 4;
  const baseY = dy * TILE;
  const reaction = getReaction(agent);
  const ciRetries = Number(reaction.ciRetries || 0);
  const ciEscalated = !!reaction.ciEscalated;
  const active = state === 'coding';
  const merged = state === 'merged';
  const exited = state === 'exited';
  const screenColor = merged
    ? PAL.badgeGold
    : (exited
      ? PAL.monitorScreenCiDark
      : (ciEscalated
        ? (frame % 20 < 10 ? PAL.monitorScreenCi : PAL.monitorScreenCiDark)
        : (active ? PAL.monitorScreenActive : PAL.monitorScreen)));

  if (timeState && timeState.monitorGlow > 0 && agent && state !== 'dead') {
    drawMonitorGlow(dx, dy, timeState.monitorGlow);
  }

  drawRect(baseX, baseY, MONITOR.w, MONITOR.h, PAL.monitor);
  drawRect(baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, screenColor);
  drawRect(baseX + (MONITOR.w - MONITOR.standW) / 2, baseY + MONITOR.h, MONITOR.standW, MONITOR.standH, PAL.monitor);

  if (merged) {
    drawMonitorCheck(baseX + MONITOR.screenX, baseY + MONITOR.screenY, PAL.badgeGreen);
  } else if (!exited) {
    const textColor = ciEscalated ? '#ffe6e6' : (active ? '#0b2' : '#5fbf6a');
    drawMonitorText(getMonitorText(agent), baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, frame, textColor);
  }

  if (ciRetries > 0 && !merged && !exited) {
    drawFire(baseX + MONITOR.screenX, baseY + MONITOR.screenY, frame);
  }
}

function drawDeskFlash(dx, dy, intensity) {
  const alpha = Math.min(0.6, 0.15 + intensity * 0.45);
  const baseX = dx * TILE + 4;
  const baseY = dy * TILE;
  ctx.save();
  ctx.globalAlpha = alpha;
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.badgeGold);
  drawRect(baseX + MONITOR.screenX, baseY + MONITOR.screenY, MONITOR.screenW, MONITOR.screenH, PAL.badgeGold);
  ctx.restore();
}

function drawDeskTint(dx, dy, alpha = 0.35) {
  ctx.save();
  ctx.globalAlpha = alpha;
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.badgeGold);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.badgeGold);
  ctx.restore();
}

function drawDesk(dx, dy, agent, state, frame, flash = 0) {
  if (timeState && timeState.lamp > 0 && agent && state !== 'dead') {
    drawLampGlow(dx, dy, timeState.lamp);
  }
  // desk surface
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 8, PAL.desk);
  drawRect(dx * TILE + 2, dy * TILE + 4, 14, 3, PAL.deskTop);
  if (state === 'merged') {
    drawDeskTint(dx, dy);
  }
  // monitor
  drawMonitor(dx, dy, agent, state, frame);
  // chair (below desk)
  drawRect(dx * TILE + 5, (dy + 1) * TILE + 2, 6, 5, PAL.chair);

  const count = coffeeCount(agent);
  if (count > 0) {
    drawCoffeeCups(dx, dy, count, frame);
  }

  if (flash > 0) {
    drawDeskFlash(dx, dy, flash);
  }
}

function drawCoffeeCups(dx, dy, count, frame) {
  const baseX = dx * TILE + 3;
  const baseY = dy * TILE + 5;
  for (let i = 0; i < count; i++) {
    const cupX = baseX + i * 4;
    drawRect(cupX, baseY, 3, 2, PAL.cup);
    drawRect(cupX + 1, baseY + 1, 1, 1, PAL.coffee);
    drawRect(cupX + 3, baseY + 1, 1, 1, PAL.cup);
  }

  if (count >= 3) {
    const steamX = baseX + (count - 1) * 4 + 1;
    const phase = frame % 20 < 10 ? 0 : 1;
    drawRect(steamX, baseY - 2 - phase, 1, 1, PAL.steam);
    drawRect(steamX + 1, baseY - 4 + phase, 1, 1, PAL.steam);
  }
}

function drawFire(screenX, screenY, frame) {
  const frames = [
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 2, c: PAL.fire2 }, { x: 3, y: 3, c: PAL.fire3 },
      { x: 4, y: 2, c: PAL.fire2 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 2, c: PAL.fire2 }, { x: 2, y: 3, c: PAL.fire1 }, { x: 3, y: 1, c: PAL.fire3 },
      { x: 4, y: 3, c: PAL.fire2 }, { x: 5, y: 2, c: PAL.fire1 },
    ],
    [
      { x: 1, y: 3, c: PAL.fire1 }, { x: 2, y: 1, c: PAL.fire3 }, { x: 3, y: 2, c: PAL.fire2 },
      { x: 4, y: 1, c: PAL.fire3 }, { x: 5, y: 3, c: PAL.fire1 },
    ],
  ];
  const idx = frame % frames.length;
  frames[idx].forEach(p => drawRect(screenX + p.x, screenY + p.y, 1, 1, p.c));
}

function tokenBarColor(tokens) {
  if (tokens >= 100000) return PAL.tokenRed;
  if (tokens >= 50000) return PAL.tokenYellow;
  return PAL.tokenGreen;
}

function drawTokenBar(tileX, tileY, tokensUsed) {
  if (tokensUsed === null || tokensUsed === undefined) return;
  const tokens = Number(tokensUsed);
  if (!Number.isFinite(tokens)) return;
  const maxTokens = 100000;
  const barWidth = 12;
  const barHeight = 2;
  const px = tileX * TILE + 2;
  const py = tileY * TILE - 4;
  drawRect(px, py, barWidth, barHeight, PAL.tokenBg);
  const fill = Math.max(1, Math.round(barWidth * Math.min(tokens / maxTokens, 1)));
  drawRect(px, py, fill, barHeight, tokenBarColor(tokens));
}

function drawMonitorText(text, screenX, screenY, screenW, screenH, frame, color) {
  if (!text) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenX * SCALE, screenY * SCALE, screenW * SCALE, screenH * SCALE);
  ctx.clip();
  ctx.fillStyle = color;
  ctx.font = `${4 * SCALE}px Courier New`;
  ctx.textBaseline = 'top';
  const textWidth = ctx.measureText(text).width;
  const pad = 4 * SCALE;
  const scroll = (frame * 0.6) % (textWidth + screenW * SCALE + pad);
  const x = screenX * SCALE + screenW * SCALE - scroll;
  const y = screenY * SCALE + 1 * SCALE;
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawGroupDivider(leftDesk, rightDesk) {
  const midTileX = leftDesk.x + Math.floor((rightDesk.x - leftDesk.x) / 2);
  drawRect(midTileX * TILE + 7, leftDesk.y * TILE + 2, 2, 12, PAL.divider);
}

function drawGroupLabel(dx, dy, text) {
  if (!text) return;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(text).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 8) * SCALE - w / 2;
  const y = (dy * TILE - 14) * SCALE;
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = '#f0c040';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPrBadge(dx, dy, prNumber, merged) {
  const label = `PR #${prNumber}${merged ? ' ‚úì' : ''}`;
  ctx.font = `${6 * SCALE}px Courier New`;
  const textWidth = ctx.measureText(label).width;
  const padding = 2 * SCALE;
  const w = textWidth + padding * 2;
  const h = 8 * SCALE;
  const x = (dx * TILE + 12) * SCALE - w / 2;
  const y = (dy * TILE - 12) * SCALE;
  ctx.fillStyle = merged ? PAL.badgeGold : PAL.badgeGreen;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle = PAL.badgeText;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x + w / 2, y + h / 2 + 1);
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPlant(px, py) {
  drawRect(px * TILE + 6, py * TILE + 4, 4, 6, PAL.plantPot);
  drawRect(px * TILE + 3, py * TILE, 10, 5, PAL.plant);
  drawRect(px * TILE + 5, py * TILE - 2, 6, 3, PAL.plant);
}

// === DRAW CHARACTER ===
function drawCharacter(tileX, tileY, colorIdx, state, frame, agentType) {
  const base = CHAR_COLORS[colorIdx % CHAR_COLORS.length];
  const shirt = agentType === 'codex' ? '#3fbf3f' : (agentType === 'claude' ? '#f08b2e' : base.shirt);
  const c = { ...base, shirt };
  const px = tileX * TILE;
  const py = tileY * TILE;
  const bob = Math.sin(frame * 0.15) > 0 ? 0 : 1;
  const celebrating = state === 'merged';
  const slumped = state === 'exited';

  // body offset (sitting = higher up to align with chair)
  const sitting = state === 'coding' || state === 'reading' || state === 'waiting' || celebrating || slumped;
  const oy = sitting ? (celebrating ? -3 : (slumped ? -1 : -2)) : bob;
  const ox = celebrating ? -1 : 0;
  const headDrop = slumped ? 1 : 0;

  // legs
  if (!sitting) {
    const walk = state === 'walking';
    const legOff = walk ? (Math.sin(frame * 0.3) > 0 ? 1 : -1) : 0;
    drawRect(px + 5 + ox, py + 11 + oy, 2, 4, c.pants);
    drawRect(px + 9 + ox, py + 11 + oy + legOff, 2, 4, c.pants);
  } else {
    // seated legs forward
    drawRect(px + 4 + ox, py + 11 + oy, 8, 2, c.pants);
  }

  // torso
  drawRect(px + 4 + ox, py + 6 + oy, 8, 5, c.shirt);

  // head
  drawRect(px + 5 + ox, py + 1 + oy + headDrop, 6, 5, c.skin);
  // hair
  drawRect(px + 5 + ox, py + oy + headDrop, 6, 2, c.hair);
  // hoodie hints
  drawRect(px + 4 + ox, py + 3 + oy + headDrop, 1, 2, c.shirt);
  drawRect(px + 11 + ox, py + 3 + oy + headDrop, 1, 2, c.shirt);

  // arms
  if (state === 'coding') {
    // arms forward (typing)
    const armBob = frame % 6 < 3 ? 0 : 1;
    drawRect(px + 2 + ox, py + 7 + oy, 2, 3, c.shirt);
    drawRect(px + 12 + ox, py + 7 + oy + armBob, 2, 3, c.shirt);
    // hands on desk
    drawRect(px + 2 + ox, py + 10 + oy, 2, 1, c.skin);
    drawRect(px + 12 + ox, py + 10 + oy + armBob, 2, 1, c.skin);
  } else if (state === 'reading') {
    // hand on chin
    drawRect(px + 2 + ox, py + 7 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 7 + oy, 2, 2, c.shirt);
    drawRect(px + 12 + ox, py + 5 + oy, 2, 2, c.skin); // hand near face
  } else if (celebrating) {
    // arms up (celebration pose)
    drawRect(px + 2 + ox, py + 1 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 1 + oy, 2, 4, c.shirt);
    drawRect(px + 2 + ox, py + oy, 2, 1, c.skin);
    drawRect(px + 12 + ox, py + oy, 2, 1, c.skin);
  } else if (slumped) {
    // arms droop (exited)
    drawRect(px + 2 + ox, py + 8 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 8 + oy, 2, 4, c.shirt);
    drawRect(px + 2 + ox, py + 11 + oy, 2, 1, c.skin);
    drawRect(px + 12 + ox, py + 11 + oy, 2, 1, c.skin);
  } else {
    // arms at sides
    drawRect(px + 2 + ox, py + 6 + oy, 2, 4, c.shirt);
    drawRect(px + 12 + ox, py + 6 + oy, 2, 4, c.shirt);
  }

  // eyes
  const blinking = frame % 60 < 3;
  if (slumped) {
    drawRect(px + 6 + ox, py + 4 + oy + headDrop, 2, 1, '#222');
    drawRect(px + 9 + ox, py + 4 + oy + headDrop, 2, 1, '#222');
  } else if (!blinking) {
    drawRect(px + 6 + ox, py + 3 + oy + headDrop, 1, 1, '#222');
    drawRect(px + 9 + ox, py + 3 + oy + headDrop, 1, 1, '#222');
  }
}

// === SPEECH BUBBLE ===
function drawBubble(tileX, tileY, text, color = '#fff') {
  const px = tileX * TILE * SCALE;
  const py = (tileY * TILE - 10) * SCALE;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  const w = Math.max(text.length * 6 + 8, 30);
  ctx.fillRect(px - w/2 + S/2, py - 14, w, 14);
  ctx.fillStyle = color;
  ctx.font = '10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(text, px + S/2, py - 4);
  ctx.textAlign = 'left';
}

function getCelebrationOrigin(slot) {
  if (!slot) return { x: 0, y: 0 };
  const x = slot.desk.x * TILE + 8;
  const y = (slot.desk.y + 1) * TILE + 6;
  return { x, y };
}

function getConfettiParticle() {
  return confettiPool.pop() || {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    color: '#fff',
    life: 0,
    maxLife: 0,
    size: CONFETTI_SIZE,
  };
}

function emitConfetti(x, y) {
  const count = CONFETTI_COUNT_MIN + Math.floor(Math.random() * (CONFETTI_COUNT_MAX - CONFETTI_COUNT_MIN + 1));
  for (let i = 0; i < count; i++) {
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 2);
    const speed = 30 + Math.random() * 50;
    const particle = getConfettiParticle();
    particle.x = x + (Math.random() - 0.5) * 6;
    particle.y = y + (Math.random() - 0.5) * 4;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.color = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
    particle.life = CONFETTI_LIFE;
    particle.maxLife = CONFETTI_LIFE;
    particle.size = CONFETTI_SIZE;
    confettiActive.push(particle);
  }
}

function updateConfetti(dt) {
  for (let i = confettiActive.length - 1; i >= 0; i--) {
    const p = confettiActive[i];
    p.life -= dt;
    if (p.life <= 0) {
      confettiActive[i] = confettiActive[confettiActive.length - 1];
      confettiActive.pop();
      confettiPool.push(p);
      continue;
    }
    p.vy += CONFETTI_GRAVITY * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
}

function drawConfetti() {
  if (!confettiActive.length) return;
  ctx.save();
  for (const p of confettiActive) {
    const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));
    ctx.globalAlpha = alpha;
    drawRect(p.x, p.y, p.size, p.size, p.color);
  }
  ctx.restore();
}

function startCelebration(slot, now) {
  if (!slot) return;
  const origin = getCelebrationOrigin(slot);
  emitConfetti(origin.x, origin.y);
  const text = Math.random() < 0.5 ? 'üéâ' : '‚úì';
  const celebration = {
    key: slot.key,
    x: origin.x,
    y: origin.y,
    text,
    startAt: now,
  };
  celebrations.push(celebration);
  celebrationByKey.set(slot.key, celebration);
  playDing();
}

function updateCelebrations(now, dt) {
  updateConfetti(dt);
  for (let i = celebrations.length - 1; i >= 0; i--) {
    const c = celebrations[i];
    if (now - c.startAt > CELEBRATION_TOTAL_DURATION) {
      celebrations[i] = celebrations[celebrations.length - 1];
      celebrations.pop();
      if (celebrationByKey.get(c.key) === c) celebrationByKey.delete(c.key);
    }
  }
}

function celebrationFlashIntensity(key, now) {
  const c = celebrationByKey.get(key);
  if (!c) return 0;
  const elapsed = now - c.startAt;
  if (elapsed < 0 || elapsed > CELEBRATION_FLASH_DURATION) return 0;
  return 1 - elapsed / CELEBRATION_FLASH_DURATION;
}

function drawCelebrationText(now) {
  if (!celebrations.length) return;
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.font = `${8 * SCALE}px Courier New`;
  ctx.fillStyle = '#f0c040';
  for (const c of celebrations) {
    const elapsed = now - c.startAt;
    if (elapsed < 0) continue;
    const progress = Math.min(1, elapsed / CELEBRATION_TEXT_DURATION);
    const alpha = progress < 0.2 ? progress / 0.2 : (progress > 0.8 ? (1 - progress) / 0.2 : 1);
    const rise = 10 * progress;
    ctx.globalAlpha = Math.max(0, alpha);
    ctx.fillText(c.text, c.x * SCALE, (c.y - 6 - rise) * SCALE);
  }
  ctx.restore();
}

// === TIMELINE ===
function timelineStatusLabel(status, activity) {
  const s = (status || '').toLowerCase();
  const a = (activity || '').toLowerCase();
  if (s.includes('merged') || a.includes('merged')) return 'Merged';
  if (s.includes('ci_failed') || s.includes('failed')) return 'CI Failed';
  if (s.includes('ci_passed') || s.includes('passed')) return 'CI Passed';
  if (s.includes('pr_open') || s.includes('pr_review') || s.includes('changes_requested')) return 'PR Open';
  if (s.includes('dead') || s.includes('exited') || s.includes('archived')) return 'Exited';
  if (s.includes('working') || s.includes('running') || a.includes('active')) return 'Working';
  return status || activity || 'Unknown';
}

function timelineColorForStatus(status, activity) {
  const s = (status || '').toLowerCase();
  const a = (activity || '').toLowerCase();
  if (s.includes('merged') || a.includes('merged')) return TIMELINE_COLORS.merged;
  if (s.includes('dead') || s.includes('exited') || s.includes('archived') || a.includes('dead') || a.includes('exited')) return TIMELINE_COLORS.dead;
  if (s.includes('ci_failed') || s.includes('failed')) return TIMELINE_COLORS.ciFailed;
  if (s.includes('pr_open') || s.includes('pr_review') || s.includes('changes_requested') || s.includes('ci')) return TIMELINE_COLORS.pr;
  if (s.includes('working') || s.includes('running') || a.includes('active')) return TIMELINE_COLORS.working;
  return TIMELINE_COLORS.working;
}

function fitText(ctx, text, maxWidth) {
  if (ctx.measureText(text).width <= maxWidth) return text;
  let clipped = text;
  while (clipped.length > 3 && ctx.measureText(`${clipped}...`).width > maxWidth) {
    clipped = clipped.slice(0, -1);
  }
  return `${clipped}...`;
}

function buildTimelineEvents(entry, now) {
  const events = [];
  if (entry && Array.isArray(entry.statusHistory)) {
    entry.statusHistory.forEach((item) => {
      const at = coerceMs(item.at);
      if (at) events.push({ at, status: item.status || '', activity: item.activity || '' });
    });
  }
  if (!events.length) {
    const createdAt = coerceMs(entry.createdAt) || now;
    events.push({ at: createdAt, status: entry.status || '', activity: entry.activity || '' });
  }
  events.sort((a, b) => a.at - b.at);
  return events;
}

function buildTimelineSegments(entry, now) {
  const events = buildTimelineEvents(entry, now);
  const endedAt = coerceMs(entry.endedAt);
  const endTs = endedAt || now;
  const segments = [];
  for (let i = 0; i < events.length; i++) {
    const current = events[i];
    const next = events[i + 1];
    const start = current.at;
    const end = next ? next.at : endTs;
    if (!start || !end || end <= start) continue;
    segments.push({
      start,
      end,
      status: current.status,
      activity: current.activity,
    });
  }
  return segments;
}

function buildTimelineMarkers(entry, events, now) {
  const markers = [];
  const createdAt = coerceMs(entry.createdAt) || (events[0] && events[0].at) || now;
  markers.push({ at: createdAt, type: 'spawn', label: 'Spawned', color: '#ffffff' });
  let sawPr = false;
  let sawCiFail = false;
  let sawCiPass = false;
  let sawMerge = false;
  events.forEach((event) => {
    const status = (event.status || '').toLowerCase();
    if (!sawPr && status.includes('pr_open')) {
      sawPr = true;
      markers.push({ at: event.at, type: 'pr', label: 'PR Opened', color: TIMELINE_COLORS.pr });
    }
    if (!sawCiFail && (status.includes('ci_failed') || status.includes('failed'))) {
      sawCiFail = true;
      markers.push({ at: event.at, type: 'ci_failed', label: 'CI Failed', color: TIMELINE_COLORS.ciFailed });
    }
    if (!sawCiPass && status.includes('ci_pass')) {
      sawCiPass = true;
      markers.push({ at: event.at, type: 'ci_passed', label: 'CI Passed', color: TIMELINE_COLORS.pr });
    }
    if (!sawMerge && status.includes('merged')) {
      sawMerge = true;
      markers.push({ at: event.at, type: 'merged', label: 'Merged', color: TIMELINE_COLORS.merged });
    }
  });
  const endedAt = coerceMs(entry.endedAt);
  if (endedAt && !sawMerge) {
    markers.push({ at: endedAt, type: 'ended', label: 'Ended', color: TIMELINE_COLORS.dead });
  }
  return markers;
}

function computeTimelineWindow(entries, now) {
  const oneHour = 60 * 60 * 1000;
  const day = 24 * 60 * 60 * 1000;
  let earliest = now - oneHour;
  entries.forEach((entry) => {
    const createdAt = coerceMs(entry.createdAt);
    if (createdAt) earliest = Math.min(earliest, createdAt);
    if (Array.isArray(entry.statusHistory)) {
      entry.statusHistory.forEach((item) => {
        const at = coerceMs(item.at);
        if (at) earliest = Math.min(earliest, at);
      });
    }
  });
  let range = clamp(now - earliest, oneHour, day);
  return { start: now - range, end: now, range };
}

function chooseTickMs(rangeMs) {
  const minute = 60 * 1000;
  const hour = 60 * minute;
  if (rangeMs <= 2 * hour) return 15 * minute;
  if (rangeMs <= 6 * hour) return 30 * minute;
  if (rangeMs <= 12 * hour) return hour;
  return 2 * hour;
}

function formatTimelineTime(ts) {
  return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatTimelineLabel(entry) {
  const repo = entry.repo || '';
  const issueId = entry.issueId || '';
  if (repo && issueId) return `${repo}#${issueId}`;
  return entry.id || 'agent';
}

function buildTimelineTooltip(entry, marker) {
  const title = escapeHtml(formatTimelineLabel(entry));
  const repoIssue = escapeHtml(formatRepoIssue(entry));
  const status = escapeHtml(timelineStatusLabel(entry.status, entry.activity));
  const createdAt = coerceMs(entry.createdAt);
  const endedAt = coerceMs(entry.endedAt);
  const createdLabel = createdAt ? new Date(createdAt).toLocaleString() : '‚Äî';
  const endedLabel = endedAt ? new Date(endedAt).toLocaleString() : '‚Äî';
  const eventLabel = marker ? `${marker.label} ‚Äî ${new Date(marker.at).toLocaleString()}` : '‚Äî';
  return `
    <div class="tooltip-title">
      <span class="status-dot ${statusDotClass(entry)}"></span>
      <span>${title}</span>
    </div>
    <div class="tooltip-row"><span class="tooltip-label">Repo/Issue</span><span class="tooltip-value">${repoIssue}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Status</span><span class="tooltip-value">${status}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Created</span><span class="tooltip-value">${escapeHtml(createdLabel)}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Ended</span><span class="tooltip-value">${escapeHtml(endedLabel)}</span></div>
    <div class="tooltip-row"><span class="tooltip-label">Event</span><span class="tooltip-value">${escapeHtml(eventLabel)}</span></div>
  `;
}

function drawTimelineLegend(x, y) {
  const items = [
    { label: 'Working', color: TIMELINE_COLORS.working },
    { label: 'PR Open', color: TIMELINE_COLORS.pr },
    { label: 'CI Failed', color: TIMELINE_COLORS.ciFailed },
    { label: 'Merged', color: TIMELINE_COLORS.merged },
    { label: 'Dead', color: TIMELINE_COLORS.dead },
  ];
  let cursor = x;
  ctx.font = '10px Courier New';
  ctx.textBaseline = 'middle';
  items.forEach((item) => {
    ctx.fillStyle = item.color;
    ctx.fillRect(cursor, y - 4, 10, 6);
    ctx.fillStyle = TIMELINE_COLORS.label;
    ctx.fillText(item.label, cursor + 14, y + 1);
    cursor += 14 + ctx.measureText(item.label).width + 12;
  });
}

function drawTimeline(now) {
  const entries = timelineEntries;
  const y = TIMELINE_Y;
  ctx.fillStyle = '#12121c';
  ctx.fillRect(0, y, CANVAS_W, TIMELINE_HEIGHT);
  ctx.fillStyle = '#0b0b12';
  ctx.fillRect(0, y, CANVAS_W, TIMELINE_HEADER_HEIGHT);

  drawTimelineLegend(12, y + Math.floor(TIMELINE_HEADER_HEIGHT / 2));

  const { start, end, range } = computeTimelineWindow(entries, now);
  const tickMs = chooseTickMs(range);
  const barX = TIMELINE_LABEL_WIDTH;
  const barW = CANVAS_W - TIMELINE_LABEL_WIDTH - TIMELINE_PADDING;
  const contentTop = y + TIMELINE_HEADER_HEIGHT + TIMELINE_PADDING;
  const contentHeight = TIMELINE_HEIGHT - TIMELINE_HEADER_HEIGHT - TIMELINE_PADDING * 2;

  ctx.save();
  ctx.beginPath();
  ctx.rect(barX, contentTop, barW, contentHeight);
  ctx.clip();

  ctx.strokeStyle = TIMELINE_COLORS.grid;
  ctx.lineWidth = 1;
  for (let t = Math.ceil(start / tickMs) * tickMs; t <= end; t += tickMs) {
    const x = barX + ((t - start) / range) * barW;
    ctx.beginPath();
    ctx.moveTo(x, contentTop);
    ctx.lineTo(x, contentTop + contentHeight);
    ctx.stroke();
  }

  const nowX = barX + ((end - start) / range) * barW;
  ctx.strokeStyle = TIMELINE_COLORS.now;
  ctx.beginPath();
  ctx.moveTo(nowX, contentTop);
  ctx.lineTo(nowX, contentTop + contentHeight);
  ctx.stroke();

  ctx.restore();

  ctx.fillStyle = TIMELINE_COLORS.axis;
  ctx.fillRect(barX, y + TIMELINE_HEADER_HEIGHT - 2, barW, 2);
  ctx.fillRect(barX - 1, contentTop, 1, contentHeight);

  ctx.fillStyle = TIMELINE_COLORS.label;
  ctx.font = '10px Courier New';
  ctx.textBaseline = 'bottom';
  for (let t = Math.ceil(start / tickMs) * tickMs; t <= end; t += tickMs) {
    const x = barX + ((t - start) / range) * barW;
    const label = formatTimelineTime(t);
    ctx.fillText(label, x - ctx.measureText(label).width / 2, y + TIMELINE_HEADER_HEIGHT - 4);
  }

  const visibleEntries = entries.slice(timelineScroll, timelineScroll + TIMELINE_MAX_ROWS);
  const rows = [];

  ctx.font = '10px Courier New';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = TIMELINE_COLORS.label;
  visibleEntries.forEach((entry, rowIndex) => {
    const rowY = contentTop + rowIndex * TIMELINE_ROW_HEIGHT;
    const barY = rowY + Math.floor((TIMELINE_ROW_HEIGHT - TIMELINE_BAR_HEIGHT) / 2);
    const label = fitText(ctx, formatTimelineLabel(entry), TIMELINE_LABEL_WIDTH - 14);
    ctx.fillStyle = TIMELINE_COLORS.label;
    ctx.fillText(label, 8, rowY + TIMELINE_ROW_HEIGHT / 2);

    const segments = buildTimelineSegments(entry, now);
    segments.forEach((segment) => {
      const segStart = Math.max(segment.start, start);
      const segEnd = Math.min(segment.end, end);
      if (segEnd <= segStart) return;
      const segX = barX + ((segStart - start) / range) * barW;
      const segW = Math.max(1, ((segEnd - segStart) / range) * barW);
      ctx.fillStyle = timelineColorForStatus(segment.status, segment.activity);
      ctx.fillRect(segX, barY, segW, TIMELINE_BAR_HEIGHT);
    });

    const events = buildTimelineEvents(entry, now);
    const markers = buildTimelineMarkers(entry, events, now).map((marker) => {
      const mx = barX + ((marker.at - start) / range) * barW;
      const my = barY + Math.floor(TIMELINE_BAR_HEIGHT / 2);
      return { ...marker, x: mx, y: my };
    }).filter(marker => marker.x >= barX && marker.x <= barX + barW);

    markers.forEach((marker) => {
      ctx.fillStyle = marker.color;
      ctx.beginPath();
      ctx.arc(marker.x, marker.y + 1, 3, 0, Math.PI * 2);
      ctx.fill();
    });

    rows.push({
      entry,
      rowY,
      barY,
      barHeight: TIMELINE_BAR_HEIGHT,
      markers,
    });
  });

  timelineLayout = {
    start,
    end,
    range,
    barX,
    barW,
    contentTop,
    contentHeight,
    rows,
  };

  if (entries.length > TIMELINE_MAX_ROWS) {
    const scrollHint = `${timelineScroll + 1}-${Math.min(timelineScroll + TIMELINE_MAX_ROWS, entries.length)} of ${entries.length}`;
    ctx.fillStyle = TIMELINE_COLORS.muted;
    ctx.font = '10px Courier New';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`Scroll ${scrollHint}`, CANVAS_W - ctx.measureText(scrollHint).width - 8, y + TIMELINE_HEIGHT - 4);
  }
}

// === STATUS BAR ===
function drawStatusBar() {
  const y = OFFICE_H + TIMELINE_HEIGHT;
  ctx.fillStyle = '#111';
  ctx.fillRect(0, y, CANVAS_W, S);
  ctx.fillStyle = '#888';
  ctx.font = '11px Courier New';
  const running = agents.filter(a => !isDoneState(mapState(a))).length;
  ctx.fillText(`ü§† Corral | ${agents.length} agents | ${running} active`, 8, y + 20);
  const totalTokens = agents.reduce((sum, agent) => {
    const tokens = getTokensUsed(agent);
    return tokens === null ? sum : sum + tokens;
  }, 0);
  const hasTokens = agents.some(agent => getTokensUsed(agent) !== null);
  const tokensLabel = hasTokens ? `Tokens ${formatTokenCount(totalTokens)}` : 'Tokens ‚Äî';
  const now = new Date().toLocaleTimeString();
  const timeWidth = ctx.measureText(now).width;
  const tokensWidth = ctx.measureText(tokensLabel).width;
  const timeX = CANVAS_W - timeWidth - 8;
  const tokensX = Math.max(8, timeX - tokensWidth - 16);
  ctx.fillText(tokensLabel, tokensX, y + 20);
  ctx.fillText(now, timeX, y + 20);
}

// === MAP LASSO STATE ‚Üí ANIMATION STATE ===
function mapState(agent) {
  if (!agent) return 'idle';
  if (agent.endedAt || agent.ended_at) return 'dead';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  if (status.includes('merged') || activity.includes('merged')) return 'merged';
  if (status.includes('exited') || activity.includes('exited') || status.includes('archived') || activity.includes('archived')) return 'exited';
  if (status.includes('dead') || activity.includes('dead')) return 'dead';
  if (status.includes('pr_review') || status.includes('changes_requested')) return 'reading';
  if (status.includes('pr_open') || status.includes('ci') || activity.includes('stale')) return 'waiting';
  if (status.includes('working') || activity.includes('active')) return 'coding';
  return 'idle';
}

function isDoneState(state) {
  return state === 'dead' || state === 'merged' || state === 'exited';
}

function stateLabel(state, agent) {
  switch(state) {
    case 'coding': return '‚å®Ô∏è coding';
    case 'reading': return 'üìñ review';
    case 'waiting': return '‚è≥ waiting';
    case 'merged': return 'üéâ merged';
    case 'exited': return 'üíÄ exited';
    case 'dead': return 'üíÄ done';
    default: return 'üí§ idle';
  }
}

function getCanvasPoint(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY,
  };
}

function isInTimelineArea(y) {
  return y >= TIMELINE_Y && y < TIMELINE_Y + TIMELINE_HEIGHT;
}

function handleTimelineHover(x, y, clientX, clientY) {
  if (!timelineLayout || !timelineLayout.rows.length) {
    hideTooltip();
    return;
  }
  const relativeY = y - timelineLayout.contentTop;
  if (relativeY < 0) {
    hideTooltip();
    return;
  }
  const rowIndex = Math.floor(relativeY / TIMELINE_ROW_HEIGHT);
  const row = timelineLayout.rows[rowIndex];
  if (!row) {
    hideTooltip();
    return;
  }
  let marker = null;
  const radius = 4;
  for (const m of row.markers) {
    if (Math.abs(x - m.x) <= radius && Math.abs(y - (m.y + 1)) <= radius) {
      marker = m;
      break;
    }
  }
  const signature = `timeline:${row.entry.id}:${marker ? marker.type + marker.at : 'row'}`;
  if (signature !== hoveredSignature) {
    tooltip.innerHTML = buildTimelineTooltip(row.entry, marker);
    hoveredSignature = signature;
  }
  timelineHover = { entry: row.entry, marker };
  tooltip.style.display = 'block';
  tooltip.setAttribute('aria-hidden', 'false');
  positionTooltip(clientX, clientY);
}

function deskIndexAt(x, y) {
  for (let i = 0; i < DESKS.length; i++) {
    const desk = DESKS[i];
    const left = desk.x * S;
    const top = desk.y * S;
    const width = S;
    const height = S * 2;
    if (x >= left && x <= left + width && y >= top && y <= top + height) {
      return i;
    }
  }
  return null;
}

function tooltipSignature(agent) {
  if (!agent) return '';
  const reaction = getReaction(agent);
  return [
    agent.id,
    agent.status,
    agent.activity,
    agent.prNumber,
    agent.prUrl,
    agent.branch,
    agent.issueId,
    agent.issueTitle,
    agent.repo,
    agent.agentType,
    agent.createdAt,
    agent.tokensUsed,
    reaction.ciRetries,
    reaction.ciEscalated,
  ].join('|');
}

function positionTooltip(clientX, clientY) {
  const padding = 12;
  const maxX = window.innerWidth - 8;
  const maxY = window.innerHeight - 8;
  let left = clientX + padding;
  let top = clientY + padding;
  const { offsetWidth: w, offsetHeight: h } = tooltip;
  if (left + w > maxX) left = clientX - w - padding;
  if (top + h > maxY) top = clientY - h - padding;
  tooltip.style.left = `${Math.max(8, left)}px`;
  tooltip.style.top = `${Math.max(8, top)}px`;
}

function showTooltip(agent, clientX, clientY) {
  const signature = tooltipSignature(agent);
  if (signature !== hoveredSignature) {
    tooltip.innerHTML = buildTooltip(agent);
    hoveredSignature = signature;
  }
  tooltip.style.display = 'block';
  tooltip.setAttribute('aria-hidden', 'false');
  positionTooltip(clientX, clientY);
}

function hideTooltip() {
  hoveredDeskIndex = null;
  hoveredSignature = '';
  timelineHover = null;
  tooltip.style.display = 'none';
  tooltip.setAttribute('aria-hidden', 'true');
}

// === MAIN RENDER LOOP ===
let frame = 0;
function render(now) {
  if (lastRenderTime === null) lastRenderTime = now;
  const dt = Math.min(0.05, (now - lastRenderTime) / 1000);
  lastRenderTime = now;
  frame++;
  updateTransitions(now, dt);
  updateCelebrations(now, dt);
  const nowTime = new Date();
  timeState = getTimeState(nowTime.getHours(), nowTime.getMinutes());
  PAL = timeState.palette;
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
  drawFloor();
  drawDoor();

  const layout = buildLayout(agents);
  currentLayout = layout;
  const transitionByKey = new Map(transitions.map(transition => [transition.key, transition]));

  layout.dividers.forEach(divider => drawGroupDivider(divider.left.desk, divider.right.desk));

  // draw desks
  DESKS.forEach((d, i) => {
    const slot = layout.deskAgents[i];
    const agent = slot ? slot.agent : null;
    const transition = slot ? transitionByKey.get(slot.key) : null;
    const deskAgent = transition ? null : agent;
    const state = deskAgent ? mapState(deskAgent) : 'idle';
    const flash = slot ? celebrationFlashIntensity(slot.key, now) : 0;
    drawDesk(d.x, d.y, deskAgent, state, frame, flash);
  });

  // decorative plants
  drawPlant(0, 2);
  drawPlant(0, 8);
  drawPlant(COLS - 1, 5);

  layout.labels.forEach(label => drawGroupLabel(label.desk.x, label.desk.y, label.repo));

  // draw agents at desks
  layout.slots.forEach((slot, i) => {
    const agent = slot.agent;
    const desk = slot.desk;
    const transition = transitionByKey.get(slot.key);
    if (transition) return;
    const state = mapState(agent);
    if (state === 'dead') return; // ghost desk
    drawCharacter(desk.x, desk.y + 1, slot.idx, state, frame, resolveAgentType(agent));
    drawTokenBar(desk.x, desk.y + 1, getTokensUsed(agent));
    const prNumber = agent ? agent.prNumber : null;
    const status = (agent.status || '').toLowerCase();
    if (prNumber !== null && prNumber !== undefined) {
      drawPrBadge(desk.x, desk.y, prNumber, status.includes('merged'));
    }
    // bubble with repo/issue
    const repo = getRepoName(agent);
    const issueId = getIssueId(agent);
    const label = issueId ? `${repo}#${issueId}` : (repo || agent.id || `agent-${i}`);
    drawBubble(desk.x, desk.y, label, state === 'waiting' ? '#ff0' : '#fff');
  });

  // draw transitions
  transitions.forEach(transition => {
    if (now < transition.startAt) return;
    const pos = transitionPosition(transition, now);
    drawCharacter(pos.x, pos.y, transition.colorIdx, 'walking', frame, resolveAgentType(transition.agent));
  });

  drawConfetti();
  drawCelebrationText(now);
  drawTimeline(Date.now());
  drawStatusBar();
  requestAnimationFrame(render);
}

// === DATA LOADING ===
function setHistoryEntries(list) {
  historyEntries = Array.isArray(list) ? list.map(normalizeHistoryEntry).filter(Boolean) : [];
  updateTimelineEntries();
}

function loadDemo() {
  const now = Date.now();
  const demoAgents = [
    {
      id: 'codex-1',
      repo: 'zall',
      issueId: '7',
      issueTitle: 'Tighten input validation',
      status: 'running',
      agentType: 'codex',
      tokensUsed: 24350,
      createdAt: new Date(now - 30 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-2',
      repo: 'zall',
      issueId: '12',
      issueTitle: 'Add rate limiting',
      status: 'pr_open',
      agentType: 'codex',
      prNumber: 42,
      tokensUsed: 61200,
      createdAt: new Date(now - 2.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'claude-3',
      repo: 'lasso',
      issueId: '29',
      issueTitle: 'Refine lasso ingestion',
      status: 'running',
      agentType: 'claude',
      tokensUsed: 128400,
      createdAt: new Date(now - 5.5 * 60 * 60 * 1000).toISOString(),
      reactionState: { ciRetries: 2 },
    },
    {
      id: 'codex-4',
      repo: 'corral',
      issueId: '1',
      issueTitle: 'Rich visuals polish',
      status: 'ci_pending',
      agentType: 'codex',
      reactionState: { ciRetries: 3, ciEscalated: true },
      prNumber: 88,
      tokensUsed: 85400,
      createdAt: new Date(now - 4.5 * 60 * 60 * 1000).toISOString(),
    },
    {
      id: 'codex-5',
      repo: 'zall',
      issueId: '15',
      status: 'merged',
      agentType: 'codex',
      prNumber: 61,
      tokensUsed: 3220,
      createdAt: new Date(now - 90 * 60 * 1000).toISOString(),
    },
  ];
  const demoHistory = demoAgents.map((agent) => {
    const createdAt = agent.createdAt;
    const createdTs = Date.parse(createdAt);
    const statusHistory = [
      { status: 'working', activity: '', at: createdAt },
    ];
    if ((agent.status || '').includes('pr_open')) {
      statusHistory.push({ status: 'pr_open', activity: '', at: new Date(createdTs + 45 * 60 * 1000).toISOString() });
    }
    if ((agent.status || '').includes('ci')) {
      statusHistory.push({ status: 'ci_failed', activity: '', at: new Date(createdTs + 75 * 60 * 1000).toISOString() });
    }
    if ((agent.status || '').includes('merged')) {
      statusHistory.push({ status: 'merged', activity: '', at: new Date(createdTs + 70 * 60 * 1000).toISOString() });
    }
    const endedAt = statusHistory[statusHistory.length - 1].status === 'merged'
      ? statusHistory[statusHistory.length - 1].at
      : null;
    return {
      id: agent.id,
      repo: agent.repo,
      issueId: agent.issueId,
      issueTitle: agent.issueTitle,
      status: agent.status,
      agentType: agent.agentType,
      createdAt,
      endedAt,
      prNumber: agent.prNumber,
      statusHistory,
    };
  });
  setAgents(demoAgents);
  setHistoryEntries(demoHistory);
}

function loadAgentsFile() {
  document.getElementById('fileInput').click();
}

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
      setAgents(nextAgents);
      setHistoryEntries([]);
    } catch(err) { alert('Invalid JSON'); }
  };
  reader.readAsText(file);
}

async function refreshFromLasso() {
  try {
    const [agentsResp, historyResp] = await Promise.all([
      fetch('/api/agents'),
      fetch('/api/history'),
    ]);
    const data = await agentsResp.json();
    const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
    setAgents(nextAgents);
    if (historyResp.ok) {
      const historyData = await historyResp.json();
      const historyList = Array.isArray(historyData) ? historyData : (historyData.history || []);
      setHistoryEntries(historyList);
    }
    return true;
  } catch(e) {
    document.getElementById('info').textContent = 'Server not running ‚Äî start with: node server.js';
    return false;
  }
}

// Auto-poll every 5s
let polling = false;
async function startPolling() {
  if (polling) return;
  polling = true;
  document.getElementById('info').textContent = 'üîÑ Live mode ‚Äî polling every 5s';
  while (polling) {
    await refreshFromLasso();
    await new Promise(r => setTimeout(r, 5000));
  }
}
function stopPolling() { polling = false; }

function updateAgentsList() {
  const el = document.getElementById('agents-list');
  el.innerHTML = agents.map((a, i) => {
    const state = mapState(a);
    const repo = getRepoName(a);
    const issueId = getIssueId(a);
    return `<div class="agent-row">
      <span class="agent-name">${a.id || a.label || 'agent-' + i}</span>
      <span class="agent-repo">${repo}${issueId ? '#' + issueId : ''}</span>
      <span class="agent-status">${stateLabel(state, a)}</span>
    </div>`;
  }).join('');
  document.getElementById('info').textContent = `${agents.length} agents loaded`;
}

// drag & drop
document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        const nextAgents = Array.isArray(data) ? data : (data.sessions || []);
        setAgents(nextAgents);
        setHistoryEntries([]);
      } catch(err) { alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  }
});

canvas.addEventListener('mousemove', e => {
  const { x, y } = getCanvasPoint(e);
  if (isInTimelineArea(y)) {
    handleTimelineHover(x, y, e.clientX, e.clientY);
    return;
  }
  if (!currentLayout) return;
  const idx = deskIndexAt(x, y);
  if (idx === null) {
    hideTooltip();
    return;
  }
  const slot = currentLayout.deskAgents[idx];
  if (!slot || !slot.agent) {
    hideTooltip();
    return;
  }
  if (transitions.some(transition => transition.key === slot.key)) {
    hideTooltip();
    return;
  }
  hoveredDeskIndex = idx;
  showTooltip(slot.agent, e.clientX, e.clientY);
});

canvas.addEventListener('mouseleave', () => hideTooltip());

canvas.addEventListener('click', e => {
  const pt = getCanvasPoint(e);
  if (isInTimelineArea(pt.y)) {
    if (timelineHover && timelineHover.entry) {
      const url = getAgentUrl(timelineHover.entry.source || timelineHover.entry);
      if (url) window.open(url, '_blank');
    }
    return;
  }
  const idx = deskIndexAt(pt.x, pt.y);
  if (idx === null || idx === undefined) return;
  const agent = agents[idx];
  if (!agent) return;
  if (currentLayout) {
    const slot = currentLayout.deskAgents[idx];
    if (slot && transitions.some(transition => transition.key === slot.key)) return;
  }
  const url = getAgentUrl(agent);
  if (url) window.open(url, '_blank');
});

canvas.addEventListener('wheel', e => {
  const { x, y } = getCanvasPoint(e);
  if (!isInTimelineArea(y)) return;
  if (timelineEntries.length <= TIMELINE_MAX_ROWS) return;
  e.preventDefault();
  const direction = e.deltaY > 0 ? 1 : -1;
  const maxScroll = Math.max(0, timelineEntries.length - TIMELINE_MAX_ROWS);
  timelineScroll = clamp(timelineScroll + direction, 0, maxScroll);
}, { passive: false });

// start
updateSoundButton();
requestAnimationFrame(render);
// auto-connect to live server if available
refreshFromLasso().then(ok => { if (ok) startPolling(); });
</script>
</body>
</html>
