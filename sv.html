<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ü§† ‚Äî SV Mode</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://unpkg.com/snes.css@1.0.1/dist/snes.min.css" rel="stylesheet" />
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0c0c1a;
    font-family: 'Press Start 2P', cursive;
    color: #c0c0c0;
    overflow: hidden;
    height: 100vh;
  }

  /* === TOP BAR === */
  .top-bar {
    background: linear-gradient(180deg, #1e1e3a, #14142a);
    border-bottom: 3px solid #2a2a4a;
    padding: 0 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 44px;
  }
  .top-title {
    color: #f0c040;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 10px;
    text-shadow: 2px 2px 0 #000;
  }
  .top-title .ver { color: #555; font-size: 7px; font-weight: normal; }
  .top-stats {
    display: flex;
    gap: 18px;
    font-size: 7px;
    color: #666;
    align-items: center;
  }
  .top-stats .val { color: #5dfc5d; text-shadow: 0 0 6px #5dfc5d33; }
  .top-stats .val-warn { color: #d1a128; }
  .top-stats .val-bad { color: #e76e55; }
  .top-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .conn-dot {
    width: 9px; height: 9px;
    border-radius: 50%;
    border: 2px solid #0b0b12;
  }
  .conn-dot.connected { background: #2f9a3d; box-shadow: 0 0 6px #2f9a3d88; }
  .conn-dot.connecting { background: #d1a128; box-shadow: 0 0 6px #d1a12888; }
  .conn-dot.disconnected { background: #6c6c6c; }
  .top-btn {
    background: #1b1b2b;
    color: #ccc;
    border: 2px solid #3a3a5c;
    padding: 2px 8px;
    font-family: inherit;
    font-size: 9px;
    cursor: pointer;
  }
  .top-btn:hover { background: #24243a; }
  .top-btn.active { color: #f0c040; border-color: #6d6d8f; }

  /* === MAIN LAYOUT === */
  .main {
    display: flex;
    height: calc(100vh - 44px);
  }

  /* === SIDEBAR === */
  .sidebar {
    width: 300px;
    min-width: 200px;
    max-width: 600px;
    background: linear-gradient(180deg, rgba(18,18,38,0.97), rgba(10,10,22,0.99));
    border-right: 3px solid #2a2a4a;
    overflow-y: auto;
    font-size: 8px;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  /* Drag handle */
  .resize-handle {
    position: absolute;
    top: 0; right: -5px;
    width: 10px;
    height: 100%;
    cursor: col-resize;
    z-index: 20;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .resize-handle::after {
    content: '';
    width: 3px;
    height: 40px;
    background: #3a3a5c;
    border-radius: 2px;
    transition: background 0.2s, height 0.2s;
  }
  .resize-handle:hover::after,
  .resize-handle.dragging::after {
    background: #f0c040;
    height: 60px;
    box-shadow: 0 0 8px #f0c04044;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

  .sb-section {
    padding: 10px 12px;
    border-bottom: 2px solid #1a1a30;
  }
  .sb-section:last-child { border-bottom: none; flex: 1; }

  .sb-header {
    color: #f0c040;
    font-size: 9px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    text-shadow: 0 0 8px #f0c04022;
  }
  .sb-header .count { color: #666; font-size: 7px; }

  /* Agent cards */
  .agent-card {
    background: linear-gradient(135deg, #1a1a30, #141428);
    border: 2px solid #2a2a4a;
    border-radius: 3px;
    padding: 8px 10px;
    margin-bottom: 8px;
    position: relative;
    overflow: hidden;
  }
  .agent-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 3px; height: 100%;
  }
  .agent-card.st-coding::before { background: #2f9a3d; box-shadow: 0 0 6px #2f9a3d88; }
  .agent-card.st-coding { border-color: #2a5a2a; }
  .agent-card.st-pr::before { background: #3b7cff; box-shadow: 0 0 6px #3b7cff88; }
  .agent-card.st-pr { border-color: #2a3a6a; }
  .agent-card.st-ci::before { background: #e76e55; box-shadow: 0 0 6px #e76e5588; }
  .agent-card.st-ci { border-color: #6a2a2a; }
  .agent-card.st-merged::before { background: #f0c040; box-shadow: 0 0 6px #f0c04088; }
  .agent-card.st-merged { border-color: #6a5a20; opacity: 0.85; }
  .agent-card.st-dead::before { background: #6c6c6c; }
  .agent-card.st-dead { border-color: #3a3a3a; opacity: 0.7; }
  .agent-card.st-closed::before { background: #8855aa; box-shadow: 0 0 6px #8855aa88; }
  .agent-card.st-closed { border-color: #4a2a5a; opacity: 0.8; }

  .ac-top {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
  }
  .ac-pulse {
    width: 7px; height: 7px;
    border-radius: 50%;
    display: inline-block;
  }
  .ac-pulse.green { background: #2f9a3d; box-shadow: 0 0 4px #2f9a3d; animation: pulse 2s infinite; }
  .ac-pulse.blue { background: #3b7cff; box-shadow: 0 0 4px #3b7cff; animation: pulse 2s infinite; }
  .ac-pulse.red { background: #e76e55; box-shadow: 0 0 4px #e76e55; animation: pulse-fast 0.8s infinite; }
  .ac-pulse.gold { background: #f0c040; animation: none; }
  .ac-pulse.gray { background: #6c6c6c; animation: none; }
  .ac-pulse.purple { background: #8855aa; animation: none; }
  @keyframes pulse { 0%,100% { opacity:1 } 50% { opacity:0.4 } }
  @keyframes pulse-fast { 0%,100% { opacity:1 } 50% { opacity:0.2 } }

  .ac-name { font-size: 9px; }
  .ac-time { color: #444; font-size: 7px; margin-left: auto; }

  .ac-detail { color: #666; line-height: 2; }
  .ac-detail .repo { color: #88aaff; }
  .ac-detail .issue { color: #999; }

  .v-green { color: #5dfc5d; }
  .v-blue { color: #3b7cff; }
  .v-red { color: #e76e55; }
  .v-gold { color: #f0c040; }
  .v-gray { color: #6c6c6c; }
  .v-purple { color: #8855aa; }
  .v-cyan { color: #00e5ff; }

  /* === NOTIFICATION BALLOONS === */
  #notificationArea {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-bottom: 8px;
  }
  .notif-balloon {
    font-size: 7px;
    line-height: 1.8;
    padding: 8px 10px;
    animation: notifIn 0.3s ease-out;
    transition: opacity 0.5s ease, transform 0.5s ease;
    word-break: break-word;
  }
  .notif-balloon.fade-out {
    opacity: 0;
    transform: translateY(-8px);
  }
  @keyframes notifIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .notif-balloon .notif-text-blue { color: #3b7cff; }
  .notif-balloon .notif-text-red { color: #e76e55; }
  .notif-balloon .notif-text-gold { color: #f0c040; }
  .notif-balloon .notif-text-gray { color: #6c6c6c; }
  .notif-balloon .notif-text-green { color: #5dfc5d; }

  .progress-bar {
    height: 3px;
    background: #1a1a30;
    margin-top: 6px;
    border-radius: 2px;
    overflow: hidden;
  }
  .progress-bar .fill { height: 100%; border-radius: 2px; }
  .fill-green { background: linear-gradient(90deg, #1a5a1a, #2f9a3d); }
  .fill-blue { background: linear-gradient(90deg, #1a2a5a, #3b7cff); }
  .fill-red { background: linear-gradient(90deg, #5a1a1a, #e76e55); }
  .fill-gold { background: linear-gradient(90deg, #5a4a10, #f0c040); }

  /* Usage section */
  .usage-card {
    background: #0f0f1a;
    border: 1px solid #2a2a3f;
    padding: 8px;
    margin-bottom: 6px;
    border-radius: 2px;
  }
  .usage-card.warn { border-color: #d1a128; }
  .usage-card.alert { border-color: #c13c3c; }
  .usage-card.exhausted { border-color: #c13c3c; background: #1a0a0a; }
  .uc-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    font-size: 8px;
  }
  .uc-pill {
    font-size: 6px;
    padding: 1px 5px;
    border: 1px solid #2a2a3f;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .pill-ok { border-color: #2f9a3d; color: #bfe6c7; }
  .pill-warn { border-color: #d1a128; color: #f3e2a2; }
  .pill-alert { border-color: #c13c3c; color: #f5b3b3; }
  .pill-est { border-color: #666; color: #aaa; }
  .pill-exhausted { border-color: #c13c3c; color: #f5b3b3; background: #3a1010; }
  .uc-row {
    display: flex;
    justify-content: space-between;
    color: #999;
    font-size: 7px;
    margin-bottom: 3px;
  }
  .uc-bar {
    height: 5px;
    background: #1b1b2b;
    border: 1px solid #222;
    margin-top: 2px;
    overflow: hidden;
  }
  .uc-fill { height: 100%; }
  .uf-green { background: linear-gradient(90deg, #1a4a1a, #2f9a3d); }
  .uf-yellow { background: linear-gradient(90deg, #5a4a10, #d1a128); }
  .uf-red { background: linear-gradient(90deg, #5a1a1a, #e76e55); }
  .uc-note { color: #555; font-size: 6px; margin-top: 4px; }

  /* Quest Log feed */
  .ql-feed {
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #333 #111;
  }
  .ql-feed::-webkit-scrollbar { width: 4px; }
  .ql-feed::-webkit-scrollbar-track { background: #111; }
  .ql-feed::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
  .ql-entry {
    display: flex;
    align-items: flex-start;
    gap: 6px;
    padding: 4px 0;
    border-bottom: 1px solid #1a1a2e;
    font-size: 7px;
  }
  .ql-entry:last-child { border-bottom: none; }
  .ql-icon { flex-shrink: 0; font-size: 9px; line-height: 1; }
  .ql-body { flex: 1; min-width: 0; }
  .ql-head { display: flex; align-items: baseline; gap: 4px; }
  .ql-name { color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .ql-status { white-space: nowrap; font-size: 6px; }
  .ql-time { flex-shrink: 0; color: #555; font-size: 6px; margin-left: auto; }
  .ql-title { color: #666; font-size: 6px; margin-top: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

  /* Queue */
  .queue-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    background: #0f0f1a;
    border: 1px dashed #2a2a3f;
    margin-bottom: 4px;
    font-size: 7px;
    color: #666;
  }
  .qi-num { color: #88aaff; }

  /* === SCENE AREA === */
  .scene-wrap {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .canvas-area {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: radial-gradient(ellipse at 50% 40%, #151530, #0c0c1a 70%);
    min-height: 0;
  }
  .canvas-area canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  .scanlines {
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0,0,0,0.03) 3px, rgba(0,0,0,0.03) 6px);
    pointer-events: none;
  }

  /* Mock tooltip */
  .mock-tooltip {
    position: absolute;
    top: 55%;
    right: 8%;
    padding: 8px 10px;
    font-size: 8px;
    line-height: 1.7;
    color: #e6e6e6;
    background: #15151fee;
    border: 3px solid #4a4a62;
    box-shadow: 0 0 0 3px #0b0b12, 4px 4px 0 #0b0b12;
    z-index: 10;
    min-width: 180px;
    display: none;
  }
  .tt-title { color: #f0c040; font-size: 9px; margin-bottom: 5px; display: flex; align-items: center; gap: 6px; }
  .tt-dot { width: 7px; height: 7px; border-radius: 50%; display: inline-block; }
  .tt-row { display: flex; gap: 6px; }
  .tt-lbl { color: #7b8096; min-width: 54px; }

  /* Canvas hover tooltip */
  #canvasTooltip {
    position: fixed;
    z-index: 50;
    display: none;
    max-width: 280px;
    padding: 8px 10px;
    font-size: 8px;
    line-height: 1.7;
    color: #e6e6e6;
    background: #1a1a2eee;
    border: 3px solid #f0c040;
    box-shadow: 0 0 0 3px #0b0b12, 4px 4px 0 #0b0b12;
    pointer-events: none;
    font-family: 'Press Start 2P', cursive;
  }

  /* === STATUS BAR === */
  .status-bar {
    background: linear-gradient(180deg, #1a1a30, #121228);
    border-top: 3px solid #2a2a4a;
    padding: 0 14px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 7px;
    color: #555;
  }
  .sb-log {
    color: #5dfc5d;
    text-shadow: 0 0 4px #5dfc5d22;
    overflow: hidden;
    white-space: nowrap;
    max-width: 60%;
  }

  /* No-data message */
  .no-data { color: #555; font-size: 7px; text-align: center; padding: 12px; }

  /* === SNES.CSS DARK THEME OVERRIDES === */
  .snes-container {
    background: #1a1a2e;
    padding: 8px 10px;
    margin-bottom: 0;
    position: relative;
    border-image-outset: 3px;
    border-width: 6px;
  }
  .snes-container::before {
    background-color: rgba(0,0,0,0.3);
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-container::after {
    background-color: rgba(100,100,160,0.25);
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-container > .snes-container-title {
    color: #f0c040;
    font-size: 9px;
    text-shadow: 0 0 8px #f0c04022;
    letter-spacing: 0;
    word-spacing: normal;
    margin-bottom: 8px;
  }
  .snes-container > .snes-container-title::after {
    background-color: #f0c040;
    height: 3px;
    bottom: -4px;
  }
  /* Custom badges (SNES.css has no badge component) */
  .snes-badge { white-space: nowrap; display: inline-block; }
  .snes-badge span {
    font-family: 'Press Start 2P', cursive;
    font-size: 6px;
    padding: 2px 6px;
    border: 2px solid;
    display: inline-block;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .snes-badge .is-success { border-color: #4bb244; color: #4bb244; background: rgba(75,178,68,0.15); }
  .snes-badge .is-primary { border-color: #4eb6d9; color: #4eb6d9; background: rgba(78,182,217,0.15); }
  .snes-badge .is-warning { border-color: #f2c019; color: #f2c019; background: rgba(242,192,25,0.15); }
  .snes-badge .is-error { border-color: #ff6f00; color: #ff6f00; background: rgba(255,111,0,0.15); }
  /* SNES-styled progress bars (RPG stat bars) */
  .snes-progress {
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    width: 100%;
    border: 2px solid #2a2a4a;
    background: #0f0f1a;
    display: block;
  }
  .snes-progress::-webkit-progress-bar { background: #0f0f1a; }
  .snes-progress::-webkit-progress-value { transition: width 0.3s ease; }
  .snes-progress.is-success::-webkit-progress-value { background: linear-gradient(90deg, #1a4a1a, #4bb244); }
  .snes-progress.is-primary::-webkit-progress-value { background: linear-gradient(90deg, #1a2a5a, #4eb6d9); }
  .snes-progress.is-warning::-webkit-progress-value { background: linear-gradient(90deg, #5a4a10, #f2c019); }
  .snes-progress.is-error::-webkit-progress-value { background: linear-gradient(90deg, #5a1a1a, #ff6f00); }
  .snes-progress::-moz-progress-bar { transition: width 0.3s ease; }
  .snes-progress.is-success::-moz-progress-bar { background: linear-gradient(90deg, #1a4a1a, #4bb244); }
  .snes-progress.is-primary::-moz-progress-bar { background: linear-gradient(90deg, #1a2a5a, #4eb6d9); }
  .snes-progress.is-warning::-moz-progress-bar { background: linear-gradient(90deg, #5a4a10, #f2c019); }
  .snes-progress.is-error::-moz-progress-bar { background: linear-gradient(90deg, #5a1a1a, #ff6f00); }
  /* SNES button overrides for compact dark UI */
  .snes-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 8px;
    padding: 4px 10px;
    border-image-outset: 3px;
    border-width: 6px;
    line-height: 1;
    color: #fff;
  }
  .snes-button::before {
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-button::after {
    height: 9px;
    width: calc(100% + 9px);
  }
  /* SNES blockquote overrides for notification balloons */
  .snes-blockquote.notif-balloon {
    text-align: left;
    border-image-outset: 3px;
    border-width: 6px;
    padding: 8px 10px;
    margin-bottom: 0;
  }
  .snes-blockquote.notif-balloon::before {
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-blockquote.notif-balloon::after {
    height: 9px;
    width: calc(100% + 9px);
  }

  /* Mobile menu button ‚Äî hidden on desktop */
  .mobile-menu-btn { display: none; }

  /* Mobile overlay backdrop ‚Äî hidden by default */
  .mobile-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 49;
  }

  /* === MOBILE (<768px) === */
  @media (max-width: 767px) {
    body {
      overflow-y: auto;
      height: auto;
      min-height: 100vh;
    }

    .mobile-menu-btn { display: none; }
    .mobile-overlay { display: none !important; }

    /* Top bar: wrap stats to next line */
    .top-bar {
      flex-wrap: wrap;
      height: auto;
      padding: 6px 10px;
      gap: 4px;
    }
    .top-title { font-size: 11px; }
    .top-stats {
      order: 3;
      width: 100%;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px 14px;
      padding: 4px 0 2px;
      border-top: 1px solid #2a2a4a;
      margin-top: 2px;
    }

    /* Main layout: vertical stack */
    .main {
      flex-direction: column;
      height: auto;
      min-height: calc(100vh - 70px);
    }

    /* Canvas first on mobile, sidebar below */
    .scene-wrap { order: 1; }
    .sidebar {
      order: 2;
      position: static;
      width: 100%;
      max-width: none;
      min-width: 0;
      height: auto;
      z-index: auto;
      transform: none;
      transition: none;
      border-right: none;
      border-top: 2px solid #f0c040;
      overflow-y: visible;
      display: flex;
      flex-direction: column;
    }

    /* Sidebar section order: PARTY ‚Üí QUEST LOG ‚Üí INVENTORY */
    .sidebar > .sb-section:nth-child(2) { order: 3; } /* INVENTORY ‚Üí last */
    .sidebar > .sb-section:nth-child(3) { order: 2; } /* QUEST LOG ‚Üí middle */
    .sidebar > .sb-section:nth-child(4) { order: 1; } /* PARTY ‚Üí first */

    /* Hide desktop resize handle on mobile */
    .resize-handle { display: none; }

    /* Agent cards: larger touch targets */
    .agent-card {
      padding: 10px 12px !important;
      margin-bottom: 10px;
    }
    .ac-detail { font-size: 9px; line-height: 2.2; }

    /* SNES.css mobile overrides */
    .snes-container {
      padding: 8px 10px;
    }
    .snes-container > .snes-container-title {
      font-size: 8px;
    }
    .snes-badge span { font-size: 5px; }
    .snes-button { font-size: 7px; padding: 3px 6px; }
    .snes-progress { height: 6px; }

    /* Sidebar sections: more padding */
    .sb-section { padding: 10px 12px; }
    .sb-header { font-size: 10px; margin-bottom: 12px; }

    /* Scene area: responsive ‚Äî fill width, auto height from aspect ratio */
    .scene-wrap {
      flex: none;
      width: 100%;
      min-height: 200px;
    }
    .canvas-area {
      width: 100%;
      height: 0;
      padding-bottom: 60%; /* 384/640 = 60% aspect ratio */
      position: relative;
      overflow: hidden;
    }
    .canvas-area canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Status bar: wrap text, fixed at bottom */
    .status-bar {
      flex-wrap: wrap;
      height: auto;
      padding: 6px 10px;
      gap: 4px;
      font-size: 6px;
    }
    .sb-log {
      max-width: 100%;
      white-space: normal;
      word-break: break-word;
    }

    /* Usage cards: slightly larger text */
    .usage-card { padding: 10px; }
    .uc-title { font-size: 9px; }
    .uc-row { font-size: 8px; }

    /* Quest Log feed: slightly larger on mobile */
    .ql-feed { max-height: 240px; }
    .ql-entry { font-size: 8px; gap: 8px; padding: 5px 0; }
    .ql-status { font-size: 7px; }
    .ql-time { font-size: 7px; }
    .ql-title { font-size: 7px; }

    /* Agent card tap-to-expand */
    .agent-card .ac-detail { max-height: 2.2em; overflow: hidden; transition: max-height 0.2s ease; }
    .agent-card.mobile-expanded .ac-detail { max-height: 20em; }
    .agent-card.mobile-expanded { border-color: #f0c040; }
  }

  /* === SMALL MOBILE (<480px) === */
  @media (max-width: 479px) {
    .top-title { font-size: 9px; }
    .top-title .ver { font-size: 6px; }
    .top-stats { font-size: 6px; gap: 6px 10px; }
    .snes-button { font-size: 6px; padding: 2px 4px; }

    .sb-header { font-size: 9px; }
    .agent-card { padding: 8px 10px !important; }
    .ac-detail { font-size: 8px; }

    .status-bar { font-size: 5px; }
  }
</style>
</head>
<body>

<!-- UI MODE REDIRECT -->
<script>
(function() {
  var pref = null;
  try { pref = localStorage.getItem('corral-ui-mode'); } catch(e) {}
  if (pref === 'classic') {
    window.location.replace('/');
    return;
  }
  // Set preference to sv if not already set
  try { localStorage.setItem('corral-ui-mode', 'sv'); } catch(e) {}
})();
</script>

<!-- TOP BAR -->
<div class="top-bar">
  <div class="top-title">
    <span style="font-size:16px">ü§†</span>
    <span>CORRAL</span>
    <span class="ver">sv</span>
  </div>
  <div class="top-stats" id="topStats">
    <span>AGENTS <span class="val" id="statAgents">0</span>/<span style="color:#555">12</span></span>
    <span>PRs <span class="val" id="statPRs">0</span></span>
    <span>MERGED <span class="val" id="statMerged">0</span></span>
    <span>DEAD <span class="val-bad" id="statDead">0</span></span>
    <span>UPTIME <span class="val" id="statUptime">0:00:00</span></span>
  </div>
  <div class="top-controls">
    <div class="conn-dot connecting" id="connDot" title="Connecting"></div>
    <button class="snes-button" id="soundToggleBtn" onclick="toggleSound()" title="Sound off (S)">üîá</button>
    <button class="snes-button has-ocean-color" id="toggleViewBtn" onclick="switchToClassic()" title="Switch to Classic view">üì∫ Classic</button>
    <button class="snes-button has-ember-color" id="cleanBtn" onclick="cleanAgents()">üßπ</button>
    <button class="snes-button mobile-menu-btn" id="mobileMenuBtn" onclick="toggleMobileSidebar()" title="Toggle sidebar">‚ò∞</button>
  </div>
</div>

<div class="main">

  <!-- Mobile overlay -->
  <div class="mobile-overlay" id="mobileOverlay" onclick="toggleMobileSidebar()"></div>

  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar">
    <div class="resize-handle" id="resizeHandle"></div>

    <!-- Usage / Inventory -->
    <div class="sb-section">
      <section class="snes-container">
        <p class="snes-container-title has-ember-underline">‚öîÔ∏è INVENTORY <span class="count" id="usageUpdated" style="font-size:7px;color:#666">‚Äî</span></p>
        <div id="usageCards">
          <div class="no-data">Loading usage data...</div>
        </div>
      </section>
    </div>

    <!-- Timeline / Quest Log -->
    <div class="sb-section">
      <section class="snes-container">
        <p class="snes-container-title has-sunshine-underline">üìú QUEST LOG <span class="count" id="timelineRange" style="font-size:7px;color:#666">‚Äî</span></p>

        <div id="timelineRows" class="ql-feed">
          <div class="no-data">No quests yet...</div>
        </div>
      </section>
    </div>

    <!-- Agents / Party -->
    <div class="sb-section">
      <section class="snes-container">
        <p class="snes-container-title has-nature-underline">‚ö° PARTY <span class="count" id="agentCount" style="font-size:7px;color:#666">‚Äî</span></p>
        <div id="notificationArea"></div>
        <div id="agentCards">
          <div class="no-data">Waiting for agent data...</div>
        </div>
      </section>
    </div>
  </div>

  <!-- SCENE -->
  <div class="scene-wrap">
    <div class="canvas-area">
      <canvas id="office" width="640" height="384"></canvas>
      <div class="scanlines"></div>
    </div>
    <div class="status-bar" style="padding:0 14px;margin:0">
      <span class="sb-log" id="statusLog">‚ñ∏ Connecting to server...</span>
      <span>POLL 5s ‚îÇ <span id="agentCountBar">0</span> agents ‚îÇ <span id="clock"></span></span>
    </div>
  </div>
</div>

<div id="canvasTooltip" role="tooltip" aria-hidden="true"></div>

<script>
// ============================================================
// SV UI ‚Äî Live data integration
// ============================================================

// --- State ---
let agents = [];
let historyData = [];
let usageData = null;
let connectionState = 'connecting';
let polling = false;
const startTime = Date.now();

// --- Sound state ---
let soundEnabled = false;
let audioCtx = null;
const soundedNewAgent = new Set();
const soundedPrOpen = new Set();
const soundedCiFailed = new Set();
const soundedDead = new Set();
const soundedMerged = new Set();
const previousAgentsByKey = new Map();

// --- Walk animation state ---
let transitions = [];    // { key, deskIdx, path, progress, colorIdx, startTime }
let prevAgentKeys = new Set();
let hasInitialized = false;

// --- Notification balloon state ---
let prevAgentStates = new Map(); // agentId -> { state, prNumber, ciFailing }
const MAX_BALLOONS = 3;
const BALLOON_DURATION = 8000;

function showNotification(emoji, message, colorClass) {
  const area = document.getElementById('notificationArea');
  if (!area) return;

  // Enforce max 3 balloons ‚Äî remove oldest first
  while (area.children.length >= MAX_BALLOONS) {
    area.removeChild(area.firstChild);
  }

  const balloon = document.createElement('div');
  balloon.className = 'snes-blockquote has-phantom-bg notif-balloon';
  balloon.innerHTML = '<span class="' + colorClass + '">' + emoji + ' ' + escapeHtml(message) + '</span>';
  area.appendChild(balloon);

  setTimeout(() => {
    balloon.classList.add('fade-out');
    setTimeout(() => { if (balloon.parentNode) balloon.parentNode.removeChild(balloon); }, 500);
  }, BALLOON_DURATION);
}

function detectStateChanges() {
  if (!hasInitialized) return; // skip initial load
  const currentStates = new Map();

  agents.forEach(agent => {
    const id = agent.id || '';
    if (!id) return;
    const state = mapState(agent);
    const prNum = getPrNumber(agent);
    const ciFail = isCiFailing(agent);
    const repo = getRepoName(agent);
    const name = id.length > 16 ? id.slice(0, 16) + '..' : id;
    const repoLabel = repo ? repo + (prNum ? '#' + prNum : '') : name;

    currentStates.set(id, { state, prNumber: prNum, ciFailing: ciFail });

    const prev = prevAgentStates.get(id);
    if (!prev) {
      // New agent appeared (not on first load since hasInitialized check above)
      showNotification('\u{1F6B6}', 'New agent: ' + name, 'notif-text-green');
      return;
    }

    // Detect state transitions
    if (state === 'merged' && prev.state !== 'merged') {
      showNotification('\u2705', repoLabel + ' PR merged!', 'notif-text-gold');
    } else if (ciFail && !prev.ciFailing) {
      showNotification('\u274C', repoLabel + ' CI failed', 'notif-text-red');
    } else if (prNum && !prev.prNumber) {
      showNotification('\u{1F500}', repoLabel + ' PR opened', 'notif-text-blue');
    } else if ((state === 'dead' || state === 'exited') && prev.state !== 'dead' && prev.state !== 'exited') {
      showNotification('\u{1F480}', name + ' died', 'notif-text-gray');
    }
  });

  prevAgentStates = currentStates;
}

// --- Helpers ---
function escapeHtml(value) {
  return String(value ?? '').replace(/[&<>"']/g, c => {
    switch (c) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return c;
    }
  });
}

function getRepoName(agent) {
  if (!agent) return '';
  return (agent.repo || '').split('/').pop() || '';
}

function getIssueId(agent) {
  if (!agent) return '';
  return agent.issueId ?? agent.issue ?? agent.issueID ?? '';
}

function resolveAgentType(agent) {
  if (!agent) return '';
  return (agent.agentType || agent.agent || agent.type || '').toLowerCase();
}

function mapState(agent) {
  if (!agent) return 'idle';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  // Check explicit status FIRST, before endedAt
  if (status.includes('merged') || activity.includes('merged')) return 'merged';
  if (status.includes('pr_closed') || activity.includes('pr_closed')) return 'pr_closed';
  if (status.includes('exited') || activity.includes('exited') ||
      status.includes('archived') || activity.includes('archived')) return 'exited';
  if (status.includes('dead') || activity.includes('dead')) return 'dead';
  // endedAt as fallback for agents with no clear status
  if (agent.endedAt || agent.ended_at) return 'exited';
  if (status.includes('pr_review') || status.includes('changes_requested')) return 'reading';
  if (status.includes('pr_open') && agent.alive === false) return 'review_waiting';
  if (status.includes('pr_open') || status.includes('ci') || activity.includes('stale')) return 'waiting';
  if (status.includes('working') || activity.includes('active')) return 'coding';
  return 'idle';
}

function stateLabel(state) {
  switch(state) {
    case 'coding': return 'coding';
    case 'reading': return 'review';
    case 'review_waiting': return 'needs review';
    case 'waiting': return 'PR open';
    case 'merged': return 'merged ‚úì';
    case 'pr_closed': return 'PR closed';
    case 'exited': return 'exited';
    case 'dead': return 'dead';
    default: return 'idle';
  }
}

function isDoneState(state) {
  return state === 'dead' || state === 'merged' || state === 'exited' || state === 'pr_closed';
}

function stateToCardClass(state) {
  if (state === 'coding') return 'st-coding';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'st-pr';
  if (state === 'merged') return 'st-merged';
  if (state === 'exited' || state === 'dead') return 'st-dead';
  if (state === 'pr_closed') return 'st-closed';
  return '';
}

function stateToPulseClass(state) {
  if (state === 'coding') return 'green';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'blue';
  if (state === 'merged') return 'gold';
  if (state === 'exited' || state === 'dead') return 'gray';
  if (state === 'pr_closed') return 'purple';
  return 'gray';
}

function stateToColorClass(state) {
  if (state === 'coding') return 'v-green';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'v-blue';
  if (state === 'merged') return 'v-gold';
  if (state === 'exited' || state === 'dead') return 'v-gray';
  if (state === 'pr_closed') return 'v-purple';
  return 'v-gray';
}

function stateToFillClass(state) {
  if (state === 'coding') return 'fill-green';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'fill-blue';
  if (state === 'merged') return 'fill-gold';
  return '';
}

function stateToBadgeClass(state) {
  if (state === 'coding') return 'is-success';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'is-primary';
  if (state === 'merged') return 'is-warning';
  if (state === 'exited' || state === 'dead') return 'is-error';
  if (state === 'pr_closed') return 'is-error';
  return 'is-primary';
}

function stateToProgressClass(state) {
  if (state === 'coding') return 'is-success';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'is-primary';
  if (state === 'merged') return 'is-warning';
  return 'is-success';
}

function formatDuration(ms) {
  const totalMins = Math.max(0, Math.floor(ms / 60000));
  const hours = Math.floor(totalMins / 60);
  const mins = totalMins % 60;
  if (hours > 0) return hours + 'h ' + mins + 'm';
  return mins + 'm';
}

function getCreatedAt(agent) {
  const keys = ['createdAt','created_at','startedAt','started_at','startTime','start_time','spawnedAt','spawned_at'];
  for (const k of keys) { if (agent[k]) return new Date(agent[k]).getTime(); }
  return null;
}

function coffeeCount(agent) {
  const created = getCreatedAt(agent);
  if (!created) return 0;
  const hours = (Date.now() - created) / 3600000;
  if (hours < 0.5) return 0;
  if (hours < 1) return 1;
  if (hours < 2) return 2;
  return 3;
}

function getTokens(agent) {
  return agent.tokensUsed || agent.tokens_used || agent.tokens || 0;
}

function getPrNumber(agent) {
  return agent.prNumber || agent.pr_number || agent.pr || null;
}

function isCiFailing(agent) {
  const status = (agent.status || '').toLowerCase();
  return status.includes('ci_failed') || status.includes('failed');
}

// --- Connection indicator ---
function setConnection(state) {
  connectionState = state;
  const dot = document.getElementById('connDot');
  if (!dot) return;
  dot.className = 'conn-dot ' + state;
  dot.title = state === 'connected' ? 'Connected' : state === 'connecting' ? 'Connecting...' : 'Disconnected';
}

// --- View toggle ---
function switchToClassic() {
  try { localStorage.setItem('corral-ui-mode', 'classic'); } catch(e) {}
  window.location.href = '/';
}

// --- Clean button ---
async function cleanAgents() {
  const btn = document.getElementById('cleanBtn');
  if (btn) btn.disabled = true;
  try {
    await fetch('/api/clean', { method: 'POST' });
    await refreshFromLasso();
  } catch(e) {}
  if (btn) btn.disabled = false;
}

// --- Sound ---
function initAudio() {
  if (!audioCtx) {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = AC ? new AC() : null;
  }
}

function updateSoundButton() {
  const btn = document.getElementById('soundToggleBtn');
  if (!btn) return;
  btn.textContent = soundEnabled ? 'üîä' : 'üîá';
  btn.title = soundEnabled ? 'Sound on (S)' : 'Sound off (S)';
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  try { localStorage.setItem('corral-sound', soundEnabled ? '1' : '0'); } catch {}
  updateSoundButton();
  if (soundEnabled) {
    initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    playConfirmation();
  }
}

function playTone(freq, endFreq, duration, type, vol, delay) {
  initAudio();
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime + (delay || 0);
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type || 'square';
  osc.frequency.setValueAtTime(freq, t);
  osc.frequency.exponentialRampToValueAtTime(endFreq, t + duration * 0.4);
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(vol || 0.08, t + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + duration + 0.01);
}

function playConfirmation() {
  playTone(660, 880, 0.15, 'square', 0.05);
}

// New agent arrives ‚Äî ascending chiptune arpeggio (~0.5s)
function playNewAgent() {
  if (!soundEnabled) return;
  playTone(523, 523, 0.12, 'square', 0.06, 0);
  playTone(659, 659, 0.12, 'square', 0.06, 0.12);
  playTone(784, 784, 0.12, 'square', 0.06, 0.24);
  playTone(1047, 1047, 0.12, 'square', 0.05, 0.36);
}

// PR opened ‚Äî 3 rising notes, Zelda item get (~0.8s)
function playPrCreated() {
  if (!soundEnabled) return;
  playTone(587, 587, 0.2, 'square', 0.06, 0);
  playTone(740, 740, 0.2, 'square', 0.06, 0.22);
  playTone(880, 880, 0.35, 'triangle', 0.07, 0.44);
}

// CI failed ‚Äî descending minor chord, warning (~0.5s)
function playCiFailed() {
  if (!soundEnabled) return;
  playTone(440, 330, 0.25, 'sawtooth', 0.05, 0);
  playTone(330, 220, 0.25, 'sawtooth', 0.05, 0.2);
}

// Agent died ‚Äî low rumble + descending tone (~1s)
function playAgentDied() {
  if (!soundEnabled) return;
  playTone(260, 100, 0.6, 'sine', 0.06, 0);
  playTone(180, 80, 0.5, 'sawtooth', 0.03, 0.3);
}

// PR merged ‚Äî victory fanfare, celebration arpeggio (~1.5s)
function playPrMerged() {
  if (!soundEnabled) return;
  playTone(523, 523, 0.15, 'square', 0.06, 0);
  playTone(659, 659, 0.15, 'square', 0.06, 0.15);
  playTone(784, 784, 0.15, 'square', 0.06, 0.30);
  playTone(1047, 1047, 0.3, 'square', 0.07, 0.45);
  playTone(880, 880, 0.15, 'triangle', 0.05, 0.80);
  playTone(1047, 1047, 0.5, 'triangle', 0.07, 0.95);
}

// --- Top stats bar ---
function updateTopStats() {
  const active = agents.filter(a => !isDoneState(mapState(a)));
  const prs = agents.filter(a => {
    const s = mapState(a);
    return s === 'waiting' || s === 'reading' || s === 'review_waiting';
  });
  const merged = agents.filter(a => mapState(a) === 'merged');
  const dead = agents.filter(a => {
    const s = mapState(a);
    return s === 'dead' || s === 'exited';
  });

  const el = (id, val) => { const e = document.getElementById(id); if (e) e.textContent = val; };
  el('statAgents', active.length);
  el('statPRs', prs.length);
  el('statMerged', merged.length);
  el('statDead', dead.length);
  el('agentCountBar', agents.length);

  // Uptime
  const upMs = Date.now() - startTime;
  const h = Math.floor(upMs / 3600000);
  const m = Math.floor((upMs % 3600000) / 60000);
  const s = Math.floor((upMs % 60000) / 1000);
  el('statUptime', h + ':' + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0'));
}

// --- Agent cards ---
function renderAgentCards() {
  const container = document.getElementById('agentCards');
  const countEl = document.getElementById('agentCount');
  if (!container) return;

  if (agents.length === 0) {
    container.innerHTML = '<div class="no-data">No agents connected</div>';
    if (countEl) countEl.textContent = '‚Äî';
    return;
  }

  const active = agents.filter(a => !isDoneState(mapState(a)));
  const terminal = agents.filter(a => isDoneState(mapState(a)));
  if (countEl) countEl.textContent = active.length + ' active' + (terminal.length ? ' ¬∑ ' + terminal.length + ' terminal' : '');

  container.innerHTML = agents.map(agent => {
    const state = mapState(agent);
    const cardClass = stateToCardClass(state);
    const colorClass = stateToColorClass(state);
    const badgeClass = stateToBadgeClass(state);
    const progressClass = stateToProgressClass(state);
    const name = escapeHtml(agent.id || 'agent');
    const repo = escapeHtml(getRepoName(agent));
    const issueId = getIssueId(agent);
    const issueTitle = escapeHtml(agent.issueTitle || '');
    const tokens = getTokens(agent);
    const tokensLabel = tokens > 1000 ? Math.round(tokens / 1000) + 'K' : tokens;
    const prNum = getPrNumber(agent);
    const created = getCreatedAt(agent);
    const elapsed = created ? formatDuration(Date.now() - created) : '‚Äî';
    const failing = isCiFailing(agent);
    const tokenPct = Math.min(100, Math.max(0, tokens / 2000));
    const agentType = resolveAgentType(agent);
    const typeIcon = agentType.includes('codex') ? 'ü™ô' :
                     agentType.includes('claude') ? '‚≠ê' : '';

    const titleLabel = repo && issueId ? repo + '#' + escapeHtml(String(issueId)) : (repo || name);

    let detailLine = '';
    if (issueTitle) detailLine += `<span style="color:#999">${issueTitle}</span><br>`;
    if (prNum) detailLine += `PR <span class="v-green">#${escapeHtml(String(prNum))}</span> ¬∑ `;
    if (failing) detailLine += `<span class="v-red">CI ‚úó</span> ¬∑ `;
    detailLine += `<span style="color:#666">${elapsed}</span>`;
    if (tokens) detailLine += ` ¬∑ ${tokensLabel} tok`;

    return `
      <section class="snes-container agent-card ${cardClass}" style="margin-bottom:8px;padding:6px 8px">
        <p class="snes-container-title" style="font-size:8px">${typeIcon} ${escapeHtml(titleLabel)}</p>
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px">
          <span class="snes-badge"><span class="${badgeClass}">${escapeHtml(stateLabel(state).toUpperCase())}</span></span>
        </div>
        <div class="ac-detail" style="margin-bottom:4px">${detailLine}</div>
        ${tokens ? `<progress class="snes-progress ${progressClass}" value="${Math.round(tokenPct)}" max="100" style="height:8px"></progress>` : ''}
      </section>
    `;
  }).join('');
}

// --- Usage panel ---
function renderUsageCards() {
  const container = document.getElementById('usageCards');
  const updatedEl = document.getElementById('usageUpdated');
  if (!container) return;

  if (!usageData || (!Array.isArray(usageData.providers) && !Array.isArray(usageData.usage))) {
    container.innerHTML = '<div class="no-data">Usage unavailable</div>';
    if (updatedEl) updatedEl.textContent = '‚Äî';
    return;
  }

  const providers = Array.isArray(usageData.providers) ? usageData.providers : usageData.usage;
  if (!providers || providers.length === 0) {
    container.innerHTML = '<div class="no-data">' + escapeHtml(usageData.error || 'No usage data') + '</div>';
    return;
  }

  if (updatedEl && usageData.fetchedAt) {
    const d = new Date(usageData.fetchedAt);
    const ago = Math.round((Date.now() - d.getTime()) / 60000);
    updatedEl.textContent = ago <= 1 ? 'just now' : ago + 'm ago';
  }

  container.innerHTML = providers.map(provider => {
    const name = escapeHtml(provider.name || provider.id || 'Usage');
    const isExhausted = provider.quotaStatus && provider.quotaStatus.exhausted;

    if (isExhausted) {
      const resetLabel = provider.quotaStatus.resetAt
        ? 'Resets ' + new Date(provider.quotaStatus.resetAt).toLocaleString()
        : 'Reset time unknown';
      return `
        <div class="usage-card exhausted">
          <div class="uc-title"><span>${name}</span><span class="snes-badge"><span class="is-error">EXHAUSTED</span></span></div>
          <div class="uc-row" style="color:#f5b3b3">üíÄ HP: 0/100</div>
          <progress class="snes-progress is-error" value="100" max="100" style="height:8px"></progress>
          <div class="uc-note">${escapeHtml(resetLabel)}</div>
        </div>`;
    }

    const metrics = Array.isArray(provider.metrics) ? provider.metrics : [];
    const percents = metrics.map(m => {
      if (m.utilization !== null && m.utilization !== undefined) return Number(m.utilization) / 100;
      if (m.used == null || m.limit == null || m.limit === 0) return null;
      return Math.min(1, Math.max(0, m.used / m.limit));
    }).filter(p => p !== null);
    const highest = percents.length ? Math.max(...percents) : null;
    const level = highest === null ? 'unknown' : highest >= 0.95 ? 'alert' : highest >= 0.8 ? 'warn' : 'ok';
    const badgeClass = level === 'alert' ? 'is-error' : level === 'warn' ? 'is-warning' : 'is-success';
    const resetNote = provider.resetAt ? 'Resets ' + new Date(provider.resetAt).toLocaleString() : '';

    const metricsHtml = metrics.map(m => {
      const label = escapeHtml(m.label || m.id || 'Metric');
      let pct = null;
      if (m.utilization !== null && m.utilization !== undefined) pct = Number(m.utilization) / 100;
      else if (m.used != null && m.limit != null && m.limit > 0) pct = Math.min(1, m.used / m.limit);
      const fillWidth = pct === null ? 0 : Math.round(pct * 100);
      const progressClass = pct === null ? 'is-success' : pct >= 0.95 ? 'is-error' : pct >= 0.8 ? 'is-warning' : 'is-success';
      const remaining = pct !== null ? Math.max(0, Math.round((1 - pct) * 100)) : 100;
      const hearts = remaining >= 75 ? '‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è' : remaining >= 50 ? '‚ù§Ô∏è‚ù§Ô∏èüñ§' : remaining >= 25 ? '‚ù§Ô∏èüñ§üñ§' : 'üñ§üñ§üñ§';

      let valStr = '‚Äî';
      if (m.unit === '%' && m.limit === 100 && m.used != null) valStr = 'HP: ' + (100 - m.used) + '/100';
      else if (m.limit != null) valStr = 'HP: ' + (m.limit - (m.used || 0)) + '/' + m.limit + (m.unit ? ' ' + m.unit : '');
      else if (m.used != null) valStr = m.used + (m.unit ? ' ' + m.unit : '');

      return `
        <div class="uc-row"><span>${label}</span><span>${hearts} ${escapeHtml(valStr)}</span></div>
        <progress class="snes-progress ${progressClass}" value="${fillWidth}" max="100" style="height:8px"></progress>`;
    }).join('');

    return `
      <div class="usage-card" style="border:none;background:transparent">
        <div class="uc-title"><span>${name}</span><span class="snes-badge"><span class="${badgeClass}">${level.toUpperCase()}</span></span></div>
        ${metricsHtml || '<div class="uc-note">No metrics</div>'}
        ${resetNote ? '<div class="uc-note">' + escapeHtml(resetNote) + '</div>' : ''}
      </div>`;
  }).join('');
}

// --- Timeline (Quest Log event feed) ---
function questIcon(state) {
  switch (state) {
    case 'merged': return 'üéâ';
    case 'pr_closed': return 'üö´';
    case 'exited': case 'dead': return 'üíÄ';
    case 'waiting': return 'üîÄ';
    case 'review_waiting': return 'üîÄ';
    case 'reading': return 'üîÄ';
    case 'coding': return '‚òï';
    default: return '‚òï';
  }
}

function questStatusLabel(state) {
  switch (state) {
    case 'merged': return 'MERGED';
    case 'pr_closed': return 'CLOSED';
    case 'exited': return 'EXITED';
    case 'dead': return 'DEAD';
    case 'waiting': return 'PR OPEN';
    case 'review_waiting': return 'REVIEW';
    case 'reading': return 'REVIEW';
    case 'coding': return 'WORKING';
    default: return 'IDLE';
  }
}

function questTimeAgo(ms) {
  if (ms < 60000) return 'just now';
  const mins = Math.floor(ms / 60000);
  if (mins < 60) return mins + 'm ago';
  const hours = Math.floor(mins / 60);
  if (hours < 24) return hours + 'h ago';
  const days = Math.floor(hours / 24);
  return days + 'd ago';
}

function renderTimeline() {
  const container = document.getElementById('timelineRows');
  const rangeEl = document.getElementById('timelineRange');
  if (!container) return;

  const items = historyData.length ? historyData : agents;
  if (!items.length) {
    container.innerHTML = '<div class="no-data">No quests yet...</div>';
    return;
  }

  const now = Date.now();
  if (rangeEl) rangeEl.textContent = 'last 6h';

  // Build event list: extract most recent event time for each item
  const events = items.map(item => {
    const state = mapState(item);
    const statusHistory = item.statusHistory || [];
    // Most recent event time: last statusHistory entry, or lastUpdatedAt, or createdAt
    let eventTime = null;
    if (statusHistory.length) {
      const last = statusHistory[statusHistory.length - 1];
      if (last.at) eventTime = new Date(last.at).getTime();
    }
    if (!eventTime) {
      const updated = item.lastUpdatedAt || item.updatedAt || item.updated_at;
      if (updated) eventTime = new Date(updated).getTime();
    }
    if (!eventTime) eventTime = getCreatedAt(item) || now;

    const repoName = getRepoName(item);
    const issueId = getIssueId(item);
    const name = repoName && issueId ? repoName + '#' + issueId : (repoName || escapeHtml((item.id || '').substring(0, 12)));
    const title = item.issueTitle || item.issue_title || '';

    return { state, eventTime, name, title, item };
  });

  // Sort by most recent event first
  events.sort((a, b) => b.eventTime - a.eventTime);

  const rows = events.slice(0, 12).map(ev => {
    const icon = questIcon(ev.state);
    const label = questStatusLabel(ev.state);
    const color = timelineColor(ev.item.status || '');
    const timeAgo = questTimeAgo(now - ev.eventTime);
    const titleLine = ev.title
      ? `<div class="ql-title">${escapeHtml(ev.title)}</div>`
      : '';

    return `<div class="ql-entry">
      <span class="ql-icon">${icon}</span>
      <div class="ql-body">
        <div class="ql-head">
          <span class="ql-name">${escapeHtml(ev.name)}</span>
          <span class="ql-status" style="color:${color}">${label}</span>
          <span class="ql-time">${timeAgo}</span>
        </div>
        ${titleLine}
      </div>
    </div>`;
  });

  container.innerHTML = rows.join('');
}

function timelineColor(status) {
  const s = (status || '').toLowerCase();
  if (s.includes('merged')) return '#f0c040';
  if (s.includes('pr_closed')) return '#8855aa';
  if (s.includes('exited') || s.includes('dead') || s.includes('archived')) return '#6c6c6c';
  if (s.includes('ci_failed') || s.includes('failed')) return '#ff5c5c';
  if (s.includes('pr_open') || s.includes('ci')) return '#3adf7a';
  if (s.includes('working') || s.includes('coding') || s.includes('active')) return '#3b7cff';
  return '#3b7cff';
}

// --- Status log ---
const logMessages = [];
function addLog(msg) {
  logMessages.push(msg);
  if (logMessages.length > 20) logMessages.shift();
  const el = document.getElementById('statusLog');
  if (el) el.textContent = msg;
}

// --- Data fetching ---
async function refreshFromLasso() {
  try {
    const [agentsResp, historyResp] = await Promise.all([
      fetch('/api/agents'),
      fetch('/api/history'),
    ]);
    if (!agentsResp.ok) throw new Error('Agents fetch failed');
    const data = await agentsResp.json();
    agents = Array.isArray(data) ? data : (data.sessions || []);
    detectStateChanges();
    detectNewAgents();
    detectSoundEvents();

    if (historyResp.ok) {
      const hData = await historyResp.json();
      historyData = Array.isArray(hData.history) ? hData.history : [];
    }

    setConnection('connected');
    updateAll();

    // Log latest agent activity
    if (agents.length) {
      const a = agents[0];
      addLog('‚ñ∏ ' + (a.id || 'agent') + ' ‚Äî ' + (a.status || 'active') + ' ‚Äî poll OK');
    } else {
      addLog('‚ñ∏ Poll OK ‚Äî no active agents');
    }
  } catch(err) {
    setConnection('disconnected');
    addLog('‚ñ∏ Connection failed ‚Äî ' + err.message);
  }
}

async function refreshUsage() {
  try {
    const resp = await fetch('/api/usage');
    if (!resp.ok) throw new Error('Usage fetch failed');
    usageData = await resp.json();
    renderUsageCards();
  } catch(err) {
    usageData = { error: err.message, providers: [] };
    renderUsageCards();
  }
}

function updateAll() {
  updateTopStats();
  renderAgentCards();
  renderTimeline();
}

async function startPolling() {
  if (polling) return;
  polling = true;
  setConnection('connecting');
  // Initial fetch
  await refreshFromLasso();
  await refreshUsage();
  // Poll loop
  while (polling) {
    await new Promise(r => setTimeout(r, 5000));
    await refreshFromLasso();
    // Usage less frequently
    if (Date.now() % 30000 < 6000) await refreshUsage();
  }
}

// --- Clock ---
setInterval(() => {
  const el = document.getElementById('clock');
  if (el) el.textContent = new Date().toLocaleTimeString('en-US', { hour12: false });
  updateTopStats(); // update uptime counter
}, 1000);

// ============================================================
// Canvas ‚Äî reuse mockup rendering (pixel art office)
// ============================================================
const canvas = document.getElementById('office');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const TILE = 16, SCALE = 2, S = TILE * SCALE;
const COLS = 20, ROWS = 12;
let frame = 0;

const PAL = {
  floor1: '#3d3550', floor2: '#352e48', floor3: '#302a42',
  floorCrack: '#2a2440',
  beam: '#6a5040', beamDark: '#5a4030', beamLight: '#7a6050', nail: '#999',
  wall: '#4a4a72', wallDark: '#3e3e64', wallLight: '#5a5a82', wallPanel: '#424268',
  desk: '#8b6914', deskTop: '#c49b2a', deskDark: '#6a5010',
  monitor: '#1a1a1a', monitorBezel: '#2a2a2a',
  chair: '#3a3a3a', chairDark: '#2a2a2a', chairLight: '#4a4a4a',
  plant: '#2d5a1e', plantLight: '#3a7a2a', plantPot: '#8b5e3c', plantPotDark: '#6a4a2a',
  cup: '#e0e0e0', cupDark: '#ccc', coffee: '#5a3a1a',
  fire1: '#ff0044', fire2: '#ff6600', fire3: '#ffaa00', fire4: '#ffee44',
  tombstone: '#6c6c6c', tombstoneLight: '#8b8b8b',
  divider: '#26263b',
  neonPink: '#ff2d7b', neonPinkGlow: 'rgba(255,45,123,0.12)',
  neonCyan: '#00e5ff', neonCyanGlow: 'rgba(0,229,255,0.08)',
  wb: '#d8d8c8', wbFrame: '#888',
  pizza: '#c49b2a', pizzaDark: '#8b6914',
  // SV environment upgrades
  svFloor1: '#3a3648', svFloor2: '#363244', svFloor3: '#332f40', svFloor4: '#38344a',
  svFloorWarm: 'rgba(255,200,100,0.03)',
  svBrick: '#6a3a2a', svBrickDark: '#5a2e20', svBrickMortar: '#4a3830',
  svConduit: '#555', svConduitLight: '#666',
  svFluor: '#c8e8ff', svFluorGlow: 'rgba(200,232,255,0.06)',
  svDeskFrame: '#606060', svDeskFrameLight: '#707070', svDeskFrameDark: '#505050',
  svDeskSurface: '#d4c8b0', svDeskSurfaceDark: '#b8aa90',
  svKeyboard: '#2a2a2a', svKeyboardKey: '#3a3a3a',
  svMouse: '#333', svCable: '#2a2a2a',
  svMonitor2: '#222', svMonitor2Bezel: '#2e2e2e',
  svLaptop: '#2a2a2a', svLaptopScreen: '#1a1a2e',
  svChairMesh: '#3a3a3a', svChairFrame: '#555', svChairWheel: '#444',
  svChairColors: ['#2e5a2e', '#2e2e5a', '#5a2e2e', '#5a5a2e', '#2e5a5a', '#5a2e5a'],
  svPizzaBox: '#b08030', svPizzaBoxDark: '#8a6020',
  svEnergy: '#40e060', svEnergyDark: '#30b048', svEnergyCan: '#ccc',
  svSticky: ['#ffee55', '#55eeff', '#ff88aa', '#88ff88'],
  svPoster: '#e8e0d0', svPosterText: '#222',
  svSkateDeck: '#8844aa', svSkateWheel: '#ddd', svSkateTruck: '#999',
  svCardboard: '#b09060', svCardboardDark: '#907040',
  svBeanBag: '#cc4466',  svBeanBagDark: '#aa3350',
  svFridge: '#ddd', svFridgeDark: '#bbb', svFridgeHandle: '#999',
};

const CHARS = [
  { skin: '#f5c6a0', skinD: '#d4a080', hair: '#4a2800', shirt: '#3fbf3f', shirtD: '#2a8a2a', pants: '#3050a0' },
  { skin: '#d4a373', skinD: '#b88855', hair: '#1a1a2e', shirt: '#3fbf3f', shirtD: '#2a8a2a', pants: '#2a2a4e' },
  { skin: '#f5deb3', skinD: '#d4bc90', hair: '#c04000', shirt: '#f08b2e', shirtD: '#c06a18', pants: '#404040' },
  { skin: '#c49b6a', skinD: '#a07a48', hair: '#222',    shirt: '#f08b2e', shirtD: '#c06a18', pants: '#3a3a5c' },
  { skin: '#f0d0b0', skinD: '#d0b090', hair: '#604020', shirt: '#3fbf3f', shirtD: '#2a8a2a', pants: '#333' },
  { skin: '#e8c090', skinD: '#c8a070', hair: '#802020', shirt: '#f08b2e', shirtD: '#c06a18', pants: '#2a2a4e' },
];

const CHARS_SV = [
  { skin: '#f5c6a0', skinH: '#ffe0c8', skinD: '#d4a080', hair: '#4a2800', hairH: '#6a4820', hairStyle: 0 },
  { skin: '#d4a373', skinH: '#e8b888', skinD: '#b88855', hair: '#1a1a2e', hairH: '#3a3a4e', hairStyle: 1 },
  { skin: '#f5deb3', skinH: '#fff0d0', skinD: '#d4bc90', hair: '#c04000', hairH: '#e06020', hairStyle: 2 },
  { skin: '#c49b6a', skinH: '#d8b080', skinD: '#a07a48', hair: '#222',    hairH: '#444',    hairStyle: 3 },
  { skin: '#f0d0b0', skinH: '#ffe8d0', skinD: '#d0b090', hair: '#604020', hairH: '#806040', hairStyle: 4 },
  { skin: '#e8c090', skinH: '#f8d8a8', skinD: '#c8a070', hair: '#802020', hairH: '#a04040', hairStyle: 5 },
];

const DESKS = [];
for (let r = 0; r < 3; r++)
  for (let c = 0; c < 4; c++)
    DESKS.push({ x: 2 + c * 5, y: 2 + r * 3 });

// --- Walk animation ---
const DOOR_TILE = { x: 0, y: 1 };
const WALK_SPEED = 2; // tiles per second
const ENTER_STAGGER = 0.5; // seconds between multiple entering agents

function agentKey(agent, fallbackIndex) {
  if (!agent) return 'agent-' + fallbackIndex;
  const id = (agent.id || agent.label || agent.agentId || agent.name || '').toString().trim();
  return id || ('agent-' + fallbackIndex);
}

function buildPath(start, end) {
  const mid = { x: end.x, y: start.y };
  const seg1 = Math.abs(mid.x - start.x) + Math.abs(mid.y - start.y);
  const seg2 = Math.abs(end.x - mid.x) + Math.abs(end.y - mid.y);
  return { start: { ...start }, mid, end: { ...end }, seg1, seg2, total: seg1 + seg2 };
}

function positionAlongPath(path, dist) {
  if (path.total === 0) return { x: path.end.x, y: path.end.y };
  if (dist <= path.seg1) {
    const dx = path.mid.x - path.start.x;
    const dy = path.mid.y - path.start.y;
    return {
      x: path.start.x + (dx === 0 ? 0 : Math.sign(dx) * dist),
      y: path.start.y + (dy === 0 ? 0 : Math.sign(dy) * dist),
    };
  }
  const remaining = dist - path.seg1;
  const dx = path.end.x - path.mid.x;
  const dy = path.end.y - path.mid.y;
  return {
    x: path.mid.x + (dx === 0 ? 0 : Math.sign(dx) * remaining),
    y: path.mid.y + (dy === 0 ? 0 : Math.sign(dy) * remaining),
  };
}

function updateTransitions() {
  if (!transitions.length) return;
  const now = Date.now();
  const next = [];
  transitions.forEach(t => {
    if (t.path.total === 0) return;
    const elapsed = Math.max(0, now - t.startTime) / 1000;
    t.progress = Math.min(t.path.total, elapsed * WALK_SPEED);
    if (t.progress >= t.path.total) return;
    next.push(t);
  });
  transitions = next;
}

function detectNewAgents() {
  const currentKeys = new Set();
  agents.slice(0, 12).forEach((a, i) => currentKeys.add(agentKey(a, i)));

  if (hasInitialized) {
    let staggerIdx = 0;
    const now = Date.now();
    const existingTransitionKeys = new Set(transitions.map(t => t.key));
    agents.slice(0, 12).forEach((agent, idx) => {
      const key = agentKey(agent, idx);
      if (!prevAgentKeys.has(key) && !existingTransitionKeys.has(key)) {
        const desk = DESKS[idx];
        if (!desk) return;
        transitions.push({
          key,
          deskIdx: idx,
          path: buildPath(DOOR_TILE, { x: desk.x, y: desk.y }),
          progress: 0,
          colorIdx: idx % CHARS.length,
          startTime: now + staggerIdx * ENTER_STAGGER * 1000,
          agentType: resolveAgentType(agent),
        });
        staggerIdx++;
      }
    });
  }

  hasInitialized = true;
  prevAgentKeys = currentKeys;
}

function hasPrOpen(agent) {
  const s = mapState(agent);
  return s === 'waiting' || s === 'reading' || s === 'review_waiting';
}

function detectSoundEvents() {
  if (!hasInitialized || previousAgentsByKey.size === 0) {
    // First load ‚Äî store state but don't play sounds
    agents.slice(0, 12).forEach((a, i) => previousAgentsByKey.set(agentKey(a, i), a));
    return;
  }

  let soundToPlay = null;
  agents.slice(0, 12).forEach((agent, idx) => {
    const key = agentKey(agent, idx);
    const prev = previousAgentsByKey.get(key);

    // New agent arrived (no previous state for this key)
    if (!prev && !soundedNewAgent.has(key)) {
      soundedNewAgent.add(key);
      if (!soundToPlay) soundToPlay = 'new';
    }

    if (!prev) return;

    // PR merged
    if (!soundedMerged.has(key) && mapState(prev) !== 'merged' && mapState(agent) === 'merged') {
      soundedMerged.add(key);
      soundToPlay = 'merged'; // highest priority
    }

    // Agent died
    if (!soundedDead.has(key) && mapState(prev) !== 'dead' && mapState(agent) === 'dead') {
      soundedDead.add(key);
      if (!soundToPlay || soundToPlay === 'new') soundToPlay = 'dead';
    }

    // CI failed
    if (!soundedCiFailed.has(key) && !isCiFailing(prev) && isCiFailing(agent)) {
      soundedCiFailed.add(key);
      if (!soundToPlay || soundToPlay === 'pr' || soundToPlay === 'new') soundToPlay = 'ci';
    }

    // PR opened
    if (!soundedPrOpen.has(key) && !hasPrOpen(prev) && hasPrOpen(agent)) {
      soundedPrOpen.add(key);
      if (!soundToPlay || soundToPlay === 'new') soundToPlay = 'pr';
    }
  });

  if (soundToPlay === 'merged') playPrMerged();
  else if (soundToPlay === 'dead') playAgentDied();
  else if (soundToPlay === 'ci') playCiFailed();
  else if (soundToPlay === 'pr') playPrCreated();
  else if (soundToPlay === 'new') playNewAgent();

  // Store current state for next comparison
  previousAgentsByKey.clear();
  agents.slice(0, 12).forEach((a, i) => previousAgentsByKey.set(agentKey(a, i), a));
}

function R(x, y, w, h, color) { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); }
function tileRect(tx, ty, tw, th, color) { R(tx * S, ty * S, tw * S, th * S, color); }

// === DAY/NIGHT CYCLE ===
function getTimeOfDay() {
  const now = new Date();
  const h = now.getHours() + now.getMinutes() / 60;
  // nightFactor: 0 = full day, 1 = full night
  // Smooth sine-based transitions during dawn (6-8) and dusk (18-20)
  let nightFactor;
  if (h >= 8 && h < 18) {
    nightFactor = 0; // day
  } else if (h >= 20 || h < 6) {
    nightFactor = 1; // night
  } else if (h >= 6 && h < 8) {
    // dawn: 1 ‚Üí 0 over 2 hours
    nightFactor = 0.5 + 0.5 * Math.cos((h - 6) / 2 * Math.PI);
  } else {
    // dusk (18-20): 0 ‚Üí 1 over 2 hours
    nightFactor = 0.5 - 0.5 * Math.cos((h - 18) / 2 * Math.PI);
  }
  // warmFactor peaks during dawn/dusk
  let warmFactor = 0;
  if (h >= 6 && h < 8) warmFactor = Math.sin((h - 6) / 2 * Math.PI);
  else if (h >= 18 && h < 20) warmFactor = Math.sin((h - 18) / 2 * Math.PI);
  return { nightFactor, warmFactor, hour: h };
}

function drawDayNightOverlay() {
  const { nightFactor, warmFactor } = getTimeOfDay();
  if (nightFactor <= 0 && warmFactor <= 0) return;
  ctx.save();
  // Night blue overlay
  if (nightFactor > 0) {
    ctx.fillStyle = 'rgba(10,10,40,' + (0.3 * nightFactor).toFixed(3) + ')';
    ctx.fillRect(0, 0, COLS * TILE * SCALE, ROWS * TILE * SCALE);
  }
  // Dawn/dusk warm overlay
  if (warmFactor > 0) {
    ctx.fillStyle = 'rgba(255,160,50,' + (0.1 * warmFactor).toFixed(3) + ')';
    ctx.fillRect(0, 0, COLS * TILE * SCALE, ROWS * TILE * SCALE);
  }
  ctx.restore();
}

function drawFloor() {
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      const hash = ((c * 7 + r * 13) % 3);
      tileRect(c, r, 1, 1, hash === 0 ? PAL.floor1 : hash === 1 ? PAL.floor2 : PAL.floor3);
    }
  ctx.save(); ctx.scale(SCALE, SCALE);
  ctx.fillStyle = PAL.floorCrack;
  for (let i = 0; i < 15; i++) ctx.fillRect(40 + i * 2, 100 + Math.sin(i) * 2 | 0, 2, 1);
  for (let i = 0; i < 10; i++) ctx.fillRect(180 + i * 2, 150 + (i % 3 === 0 ? 1 : 0), 1, 1);
  ctx.fillStyle = '#2e2845';
  ctx.fillRect(90, 130, 4, 3);
  ctx.fillRect(200, 110, 3, 4);
  ctx.restore();
}

function drawWalls() {
  for (let c = 0; c < COLS; c++) tileRect(c, 0, 1, 1, PAL.wall);
  ctx.save(); ctx.scale(SCALE, SCALE);
  ctx.fillStyle = PAL.wallLight; ctx.fillRect(0, 0, COLS * TILE, 2);
  ctx.fillStyle = PAL.wallDark; ctx.fillRect(0, 2, COLS * TILE, 1);
  for (let x = 0; x < COLS * TILE; x += 40) { ctx.fillStyle = PAL.wallPanel; ctx.fillRect(x, 3, 1, TILE - 3); }
  ctx.fillStyle = '#3a3028'; ctx.fillRect(0, TILE - 2, COLS * TILE, 2);
  ctx.fillStyle = '#4a4038'; ctx.fillRect(0, TILE - 2, COLS * TILE, 1);
  ctx.restore();
}

function drawGarageFrame() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  R(0, 0, COLS * TILE, 3, PAL.beam); R(0, 0, COLS * TILE, 1, PAL.beamLight); R(0, 2, COLS * TILE, 1, PAL.beamDark);
  R(0, 0, 3, ROWS * TILE, PAL.beam); R(0, 0, 1, ROWS * TILE, PAL.beamLight); R(2, 0, 1, ROWS * TILE, PAL.beamDark);
  R(COLS * TILE - 3, 0, 3, ROWS * TILE, PAL.beam); R(COLS * TILE - 3, 0, 1, ROWS * TILE, PAL.beamLight);
  [[6,1],[6,80],[6,160],[COLS*TILE-5,1],[COLS*TILE-5,80],[COLS*TILE-5,160]].forEach(([nx, ny]) => {
    ctx.fillStyle = PAL.nail; ctx.fillRect(nx, ny, 2, 2);
    ctx.fillStyle = '#777'; ctx.fillRect(nx, ny, 1, 1);
  });
  ctx.restore();
}

function drawWindow() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = 120, y = 2, w = 64, h = 12;
  const { nightFactor, warmFactor, hour } = getTimeOfDay();
  // Sky color: lerp between day blue and night dark
  const skyR = Math.round(10 + (1 - nightFactor) * 60 + warmFactor * 80);
  const skyG = Math.round(16 + (1 - nightFactor) * 80 + warmFactor * 40);
  const skyB = Math.round(41 + (1 - nightFactor) * 100);
  const skyColor = 'rgb(' + Math.min(skyR,255) + ',' + Math.min(skyG,255) + ',' + Math.min(skyB,255) + ')';
  R(x, y, w, h, skyColor);
  // Building silhouette color: darker at night, slightly lighter during day
  const bldR = Math.round(12 + (1 - nightFactor) * 30);
  const bldG = Math.round(21 + (1 - nightFactor) * 30);
  const bldB = Math.round(48 + (1 - nightFactor) * 30);
  const bldColor = 'rgb(' + bldR + ',' + bldG + ',' + bldB + ')';
  const buildings = [[x+2,y+6,6,6],[x+10,y+4,4,8],[x+16,y+7,5,5],[x+24,y+3,8,9],[x+34,y+5,6,7],[x+42,y+6,4,6],[x+48,y+4,5,8],[x+55,y+7,6,5]];
  // Building window lights: more visible at night
  const windowChance = 0.3 + nightFactor * 0.4;
  buildings.forEach(([bx,by,bw,bh]) => {
    ctx.fillStyle = bldColor; ctx.fillRect(bx, by, bw, bh);
    for (let wx = bx + 1; wx < bx + bw - 1; wx += 2)
      for (let wy = by + 1; wy < by + bh - 1; wy += 2)
        if (Math.random() > (1 - windowChance)) {
          ctx.fillStyle = ['#f0d060','#5dfc5d','#00e5ff','#ff8844','#fff'][Math.floor(Math.random()*5)];
          ctx.fillRect(wx, wy, 1, 1);
        }
  });
  // Stars: only visible at night
  if (nightFactor > 0.3) {
    ctx.fillStyle = 'rgba(255,255,255,' + (nightFactor * 0.8).toFixed(2) + ')';
    [[x+5,y+1],[x+20,y+2],[x+45,y+1],[x+55,y+2],[x+35,y+1],[x+15,y+1],[x+60,y+2]].forEach(([sx,sy]) => ctx.fillRect(sx, sy, 1, 1));
  }
  // Moon/sun
  if (nightFactor > 0.3) {
    // Moon at night
    ctx.fillStyle = 'rgba(255,240,200,' + (nightFactor * 0.9).toFixed(2) + ')';
    ctx.fillRect(x+50, y+1, 4, 4);
    ctx.fillStyle = 'rgba(220,210,160,' + (nightFactor * 0.7).toFixed(2) + ')';
    ctx.fillRect(x+51, y+1, 2, 2);
  } else {
    // Sun during day
    ctx.fillStyle = '#ffe39a'; ctx.fillRect(x+50, y+1, 4, 4);
    ctx.fillStyle = '#d8d060'; ctx.fillRect(x+51, y+1, 2, 2);
  }
  // Window frame
  ctx.fillStyle = '#5a5040';
  ctx.fillRect(x-1, y-1, w+2, 1); ctx.fillRect(x-1, y+h, w+2, 1);
  ctx.fillRect(x-1, y-1, 1, h+2); ctx.fillRect(x+w, y-1, 1, h+2);
  ctx.fillRect(x+w/2, y, 1, h); ctx.fillRect(x, y + h/2, w, 1);
  ctx.restore();
}

function drawDoor() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = 4, y = TILE + 2;
  R(x, y, 14, 28, '#3a3028'); R(x+1, y+1, 12, 26, '#2a2218');
  R(x+2, y+2, 10, 10, '#2e2620'); R(x+2, y+14, 10, 12, '#2e2620');
  R(x+10, y+15, 2, 2, '#c49b2a'); R(x+10, y+15, 1, 1, '#dab84a');
  R(x-1, y-1, 16, 1, PAL.beam); R(x-1, y-1, 1, 30, PAL.beam); R(x+14, y-1, 1, 30, PAL.beam);
  ctx.restore();
}

function drawNeonSign() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const nx = 55, ny = 3;
  const { nightFactor } = getTimeOfDay();
  // Glow radius and intensity increase at night
  const glowMult = 1 + nightFactor * 1.5;
  const maxR = Math.round(8 * glowMult);
  for (let r = maxR; r > 0; r -= 2) R(nx-r, ny-r, 56+r*2, 10+r*2, 'rgba(255,45,123,' + (0.008 * glowMult * (maxR-r) / maxR * 8).toFixed(4) + ')');
  const L = [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,5],[2,5],[3,5]];
  const A = [[5,1],[5,2],[5,3],[5,4],[5,5],[6,0],[7,0],[8,0],[8,1],[8,2],[8,3],[8,4],[8,5],[6,3],[7,3]];
  const S1 = [[10,0],[11,0],[12,0],[13,0],[10,1],[10,2],[11,2],[12,2],[13,2],[13,3],[13,4],[10,5],[11,5],[12,5],[13,5],[10,4]];
  const S2 = S1.map(([x,y]) => [x+5, y]);
  const O = [[20,0],[21,0],[22,0],[20,1],[23,1],[20,2],[23,2],[20,3],[23,3],[20,4],[23,4],[21,5],[22,5]];
  [L, A, S1, S2, O].forEach(letter => { letter.forEach(([lx, ly]) => R(nx+lx*2, ny+ly, 2, 1, PAL.neonPink)); });
  R(nx, ny+7, 48, 1, PAL.neonCyan);
  for (let i = 0; i < 48; i += 3) R(nx+i, ny+7, 1, 1, '#005a6a');
  // Stronger underglow at night
  const underGlowAlpha = (0.12 + nightFactor * 0.15).toFixed(3);
  R(nx-4, ny+8, 56, 4, 'rgba(255,45,123,' + underGlowAlpha + ')');
  ctx.restore();
}

function drawWhiteboard() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = 220, y = 2;
  R(x, y, 40, 12, PAL.wb); R(x, y, 40, 1, PAL.wbFrame); R(x, y+11, 40, 1, PAL.wbFrame);
  R(x, y, 1, 12, PAL.wbFrame); R(x+39, y, 1, 12, PAL.wbFrame);
  ctx.fillStyle = '#444'; ctx.font = '3px "Press Start 2P"';
  ctx.fillText('DAYS WITHOUT', x+3, y+4); ctx.fillText('INCIDENT:', x+3, y+8);
  ctx.fillStyle = '#e04040'; ctx.font = '6px "Press Start 2P"'; ctx.fillText('0', x+30, y+9);
  ctx.fillStyle = '#aaa'; ctx.font = '4px "Press Start 2P"'; ctx.fillText('3', x+26, y+5);
  ctx.fillStyle = '#e04040'; R(x+25, y+3, 6, 1, '#e04040');
  R(x+10, y+12, 20, 1, '#666'); R(x+11, y+12, 2, 1, '#e04040');
  R(x+14, y+12, 2, 1, '#4040e0'); R(x+17, y+12, 2, 1, '#40c040');
  ctx.restore();
}

function drawDesk(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE + 8;
  R(x, y, TILE, 2, PAL.deskTop); R(x, y, TILE, 1, '#d4ab3a');
  for (let gx = x + 2; gx < x + TILE - 1; gx += 3) R(gx, y+1, 2, 1, PAL.desk);
  R(x, y+2, TILE, 4, PAL.desk); R(x, y+2, TILE, 1, PAL.deskDark);
  R(x+1, y+6, 2, 6, PAL.deskDark); R(x+TILE-3, y+6, 2, 6, PAL.deskDark);
  ctx.restore();
}

function drawChair(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = d.y * TILE + 10;
  R(x, y, 10, 2, PAL.chairLight); R(x+1, y, 8, 1, PAL.chair);
  R(x, y-6, 10, 2, PAL.chairLight); R(x+1, y-6, 8, 1, PAL.chair);
  R(x, y-4, 1, 4, PAL.chairDark); R(x+9, y-4, 1, 4, PAL.chairDark);
  R(x, y-2, 2, 1, PAL.chair); R(x+8, y-2, 2, 1, PAL.chair);
  R(x+4, y+2, 2, 3, PAL.chairDark); R(x+1, y+5, 8, 1, PAL.chair);
  R(x+1, y+6, 2, 1, '#555'); R(x+7, y+6, 2, 1, '#555');
  ctx.restore();
}

function drawMonitor(d, state, monitorText) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = d.y * TILE;
  R(x, y, 10, 7, PAL.monitorBezel); R(x+1, y, 8, 1, PAL.monitor);
  const sc = state === 'ci_failed' ? '#3a0808' : (state === 'coding' ? '#0a200a' : '#0a0a0a');
  R(x+1, y+1, 8, 5, sc);
  if (state === 'coding') {
    const colors = ['#4ae04a', '#2a8a2a', '#6af06a', '#3aaa3a'];
    for (let line = 0; line < 4; line++) {
      const indent = line === 2 ? 2 : 0;
      const len = 2 + (line * 3 + frame) % 4;
      R(x+2+indent, y+1+line, Math.min(len, 6-indent), 1, colors[line % colors.length]);
    }
    if (frame % 10 < 5) R(x+7, y+4, 1, 1, '#4ae04a');
  } else if (state === 'ci_failed') {
    const bright = Math.sin(frame * 0.1) > 0;
    const c = bright ? '#ff3b3b' : '#aa2222';
    R(x+2,y+1,1,1,c); R(x+6,y+1,1,1,c);
    R(x+3,y+2,1,1,c); R(x+5,y+2,1,1,c); R(x+4,y+3,1,1,c);
    R(x+3,y+4,1,1,c); R(x+5,y+4,1,1,c); R(x+2,y+5,1,1,c); R(x+6,y+5,1,1,c);
    R(x+2, y+1, 6, 1, '#3a0808');
    R(x+2, y+2, 1, 1, '#aa2222'); R(x+3, y+2, 2, 1, '#ff3b3b');
  } else if (state === 'merged') {
    R(x+4,y+1,2,1,'#f0c040'); R(x+3,y+2,4,1,'#f0c040');
    R(x+2,y+3,6,1,'#d8a820'); R(x+3,y+4,4,1,'#f0c040');
  } else {
    R(x+3,y+3,1,1,'#4ae04a'); R(x+4,y+4,1,1,'#4ae04a');
    R(x+5,y+3,1,1,'#4ae04a'); R(x+6,y+2,1,1,'#4ae04a'); R(x+7,y+1,1,1,'#2a8a2a');
  }
  // Scrolling issue title text on monitor screen
  if (monitorText) {
    ctx.restore(); // exit SCALE transform for text rendering
    const sx = (x + 1) * SCALE, sy = (y + 1) * SCALE, sw = 8 * SCALE, sh = 5 * SCALE;
    ctx.save();
    ctx.beginPath(); ctx.rect(sx, sy, sw, sh); ctx.clip();
    ctx.fillStyle = state === 'ci_failed' ? '#ff6666' : (state === 'coding' ? '#4ae04a' : '#8888ff');
    ctx.font = '5px "Press Start 2P", monospace';
    ctx.textBaseline = 'middle';
    const textWidth = ctx.measureText(monitorText).width;
    const totalScroll = textWidth + sw + 4;
    const scroll = (frame * 0.6) % totalScroll;
    ctx.fillText(monitorText, sx + sw - scroll, sy + sh / 2);
    ctx.restore();
    ctx.save(); ctx.scale(SCALE, SCALE); // re-enter SCALE for remaining drawing
  }
  R(x+3, y+7, 4, 1, '#333'); R(x+2, y+8, 6, 1, '#2a2a2a');
  if (state === 'coding' || state === 'ci_failed') {
    R(x-1, y+7, 12, 3, state === 'ci_failed' ? 'rgba(255,59,59,0.05)' : 'rgba(74,224,74,0.05)');
  }
  ctx.restore();
}

function drawCharacter(d, colorIdx, state) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const c = CHARS[colorIdx % CHARS.length];
  const x = d.x * TILE, y = (d.y + 1) * TILE;
  const sleeping = state === 'sleeping';
  const sitting = ['coding','reading','waiting','merged','exited','pr_closed','sleeping'].includes(state);
  const celeb = state === 'merged';
  const slumped = state === 'exited' || sleeping;
  const walk = state === 'walking';
  const bob = sitting ? 0 : (Math.sin(frame * 0.15) > 0 ? 0 : 1);
  const oy = sitting ? (celeb ? -3 : slumped ? -1 : -2) : bob;

  if (!sitting) { ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(x+3, y+14+bob, 10, 2); }
  ctx.fillStyle = c.pants;
  if (sitting) R(x+4, y+11+oy, 8, 2, c.pants);
  else {
    const lo = walk ? (Math.sin(frame*0.3) > 0 ? 1 : -1) : 0;
    R(x+5, y+11+oy, 2, 4, c.pants); R(x+9, y+11+oy+lo, 2, 4, c.pants);
    R(x+4, y+15+oy, 3, 1, '#222'); R(x+9, y+15+oy+lo, 3, 1, '#222');
  }
  R(x+4, y+6+oy, 8, 5, c.shirt); R(x+4, y+6+oy, 8, 1, c.shirtD); R(x+4, y+10+oy, 8, 1, c.shirtD);
  R(x+7, y+7+oy, 1, 3, c.shirtD);
  R(x+5, y+1+oy, 6, 5, c.skin); R(x+5, y+5+oy, 6, 1, c.skinD);
  R(x+4, y+3+oy, 1, 2, c.skinD); R(x+11, y+3+oy, 1, 2, c.skinD);
  R(x+5, y+oy, 6, 2, c.hair); R(x+4, y+oy+1, 1, 1, c.hair); R(x+11, y+oy+1, 1, 1, c.hair);
  R(x+4, y+3+oy, 1, 3, c.shirt); R(x+11, y+3+oy, 1, 3, c.shirt);

  if (state === 'coding') {
    R(x+3, y+2+oy, 1, 3, '#333'); R(x+12, y+2+oy, 1, 3, '#333');
    R(x+3, y+3+oy, 1, 2, '#555'); R(x+12, y+3+oy, 1, 2, '#555');
    R(x+4, y+oy, 8, 1, '#444');
  }

  if (sleeping) {
    const zf = frame % 90;
    ctx.fillStyle = '#aaddff'; ctx.font = '3px "Press Start 2P"';
    if (zf < 30) ctx.fillText('z', x+13, y+oy);
    else if (zf < 60) ctx.fillText('zZ', x+12, y+oy-2);
    else ctx.fillText('zZz', x+11, y+oy-4);
  }

  if (state === 'coding') {
    const ab = frame % 6 < 3 ? 0 : 1;
    R(x+2, y+7+oy, 2, 3, c.shirt); R(x+12, y+7+oy+ab, 2, 3, c.shirt);
    R(x+2, y+10+oy, 2, 1, c.skin); R(x+12, y+10+oy+ab, 2, 1, c.skin);
  } else if (celeb) {
    R(x+2, y+1+oy, 2, 4, c.shirt); R(x+12, y+1+oy, 2, 4, c.shirt);
    R(x+2, y+oy, 2, 1, c.skin); R(x+12, y+oy, 2, 1, c.skin);
  } else if (slumped) {
    R(x+2, y+8+oy, 2, 4, c.shirt); R(x+12, y+8+oy, 2, 4, c.shirt);
  } else {
    R(x+2, y+6+oy, 2, 4, c.shirt); R(x+12, y+6+oy, 2, 4, c.shirt);
  }

  const blink = frame % 60 < 3;
  if (slumped) { R(x+6, y+4+oy, 2, 1, '#222'); R(x+9, y+4+oy, 2, 1, '#222'); }
  else if (!blink) {
    R(x+6, y+3+oy, 2, 2, '#fff'); R(x+9, y+3+oy, 2, 2, '#fff');
    const px = state === 'coding' ? 0 : (Math.sin(frame*0.02) > 0 ? 0 : 1);
    R(x+6+px, y+3+oy, 1, 1, '#111'); R(x+9+px, y+3+oy, 1, 1, '#111');
    R(x+6, y+3+oy, 1, 1, '#ddf'); R(x+9, y+3+oy, 1, 1, '#ddf');
  }
  ctx.restore();
}

function drawCharacterSV(d, colorIdx, state, agentType) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const ch = CHARS_SV[colorIdx % CHARS_SV.length];
  const x = d.x * TILE;
  const y = (d.y + 1) * TILE;
  const isCodex = (agentType || '').includes('codex');
  // Hoodie palette by agent type (orange=Claude, green=Codex)
  const hM = isCodex ? '#3fbf3f' : '#e87030';
  const hL = isCodex ? '#5fdf5f' : '#ff9050';
  const hD = isCodex ? '#2a8a2a' : '#c05020';
  const hX = isCodex ? '#1e6e1e' : '#a03818';
  const f = Math.floor(frame / 8) % 4;
  const sleeping = state === 'sleeping';
  const sitting = ['coding','reading','waiting','merged','exited','pr_closed','sleeping'].includes(state);
  const celeb = state === 'merged';
  const slumped = state === 'exited' || sleeping;
  const walk = state === 'walking';
  const coding = state === 'coding';
  const bob = sitting ? 0 : [0, -1, 0, -1][f];
  const oy = sitting ? (celeb ? -6 : slumped ? -2 : -4) : bob;
  // Shadow for standing/walking
  if (!sitting) { ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(x+2, y+19, 12, 2); }
  // --- LEGS ---
  if (sitting) {
    R(x+4, y+13+oy, 3, 2, '#3050a0'); R(x+9, y+13+oy, 3, 2, '#3050a0');
    R(x+4, y+14+oy, 3, 1, '#283e80'); R(x+9, y+14+oy, 3, 1, '#283e80');
  } else if (walk) {
    const wc = [[0,0,0,0],[-1,-1,1,0],[0,0,0,0],[1,0,-1,-1]][f];
    R(x+4+wc[0], y+14+oy, 3, 4, '#3050a0'); R(x+4+wc[0], y+14+oy, 3, 1, '#283e80');
    R(x+9+wc[2], y+14+oy, 3, 4, '#3050a0'); R(x+9+wc[2], y+14+oy, 3, 1, '#283e80');
    R(x+3+wc[0], y+18+oy+wc[1], 5, 1, '#333'); R(x+8+wc[2], y+18+oy+wc[3], 5, 1, '#333');
  } else {
    R(x+4, y+14+oy, 3, 4, '#3050a0'); R(x+4, y+14+oy, 3, 1, '#283e80');
    R(x+9, y+14+oy, 3, 4, '#3050a0'); R(x+9, y+14+oy, 3, 1, '#283e80');
    R(x+3, y+18+oy, 5, 1, '#333'); R(x+8, y+18+oy, 5, 1, '#333');
  }
  // --- TORSO (Hoodie) ---
  R(x+3, y+7+oy, 10, 6, hM);
  R(x+3, y+7+oy, 10, 1, hL);
  R(x+3, y+12+oy, 10, 1, hD);
  R(x+4, y+8+oy, 1, 4, hL);
  R(x+12, y+8+oy, 1, 4, hD);
  R(x+5, y+7+oy, 6, 1, hD);
  R(x+7, y+8+oy, 1, 4, hD); R(x+8, y+8+oy, 1, 4, hX);
  R(x+6, y+8+oy, 1, 2, hX); R(x+9, y+8+oy, 1, 2, hX);
  if (isCodex) { R(x+10, y+9+oy, 2, 2, '#f0c040'); R(x+10, y+9+oy, 1, 1, '#d4a020'); }
  else { R(x+10, y+9+oy, 1, 1, '#f0c040'); R(x+9, y+10+oy, 3, 1, '#f0c040'); R(x+10, y+11+oy, 1, 1, '#f0c040'); }
  // --- HEAD ---
  R(x+4, y+2+oy, 8, 5, ch.skin);
  R(x+4, y+2+oy, 8, 1, ch.skinH);
  R(x+4, y+6+oy, 8, 1, ch.skinD);
  R(x+3, y+3+oy, 1, 2, ch.skin); R(x+3, y+3+oy, 1, 1, ch.skinH);
  R(x+12, y+3+oy, 1, 2, ch.skinD);
  // --- EYES (2px tall) ---
  const blink = frame % 80 < 3;
  if (slumped) {
    R(x+5, y+4+oy, 2, 1, '#222'); R(x+9, y+4+oy, 2, 1, '#222');
  } else if (!blink) {
    R(x+5, y+3+oy, 2, 2, '#fff'); R(x+9, y+3+oy, 2, 2, '#fff');
    const px = coding ? 0 : (Math.sin(frame * 0.02) > 0 ? 0 : 1);
    R(x+5+px, y+3+oy, 1, 2, '#111'); R(x+9+px, y+3+oy, 1, 2, '#111');
    R(x+5, y+3+oy, 1, 1, '#ddf'); R(x+9, y+3+oy, 1, 1, '#ddf');
    if (celeb) { R(x+5, y+2+oy, 2, 1, ch.hair); R(x+9, y+2+oy, 2, 1, ch.hair); }
  }
  if (celeb) R(x+7, y+5+oy, 2, 1, '#c06060');
  else if (slumped) R(x+7, y+5+oy, 2, 1, '#888');
  else if (coding) R(x+7, y+5+oy, 1, 1, ch.skinD);
  // --- HAIR (per hairStyle) ---
  const hs = ch.hairStyle;
  R(x+4, y+1+oy, 8, 2, ch.hair); R(x+4, y+1+oy, 8, 1, ch.hairH);
  R(x+3, y+2+oy, 1, 1, ch.hair); R(x+12, y+2+oy, 1, 1, ch.hair);
  if (hs === 0) {
    R(x+5, y+oy, 2, 1, ch.hair); R(x+8, y+oy, 2, 1, ch.hair);
    R(x+6, y+oy-1, 1, 1, ch.hairH); R(x+9, y+oy-1, 1, 1, ch.hairH); R(x+11, y+oy, 1, 1, ch.hair);
  } else if (hs === 1) {
    R(x+12, y+1+oy, 2, 1, ch.hair); R(x+13, y+2+oy, 2, 2, ch.hair); R(x+13, y+2+oy, 1, 1, ch.hairH);
  } else if (hs === 2) {
    R(x+3, y+oy, 10, 2, '#cc3333'); R(x+3, y+oy, 10, 1, '#ee5555'); R(x+2, y+1+oy, 12, 1, '#aa2222');
  } else if (hs === 3) {
    R(x+3, y+oy, 10, 2, ch.hair);
    R(x+2, y+2+oy, 2, 3, '#555'); R(x+2, y+2+oy, 2, 1, '#777');
    R(x+12, y+2+oy, 2, 3, '#555'); R(x+12, y+2+oy, 2, 1, '#777');
    R(x+3, y+oy, 10, 1, '#666');
  } else if (hs === 4) {
    R(x+4, y+oy, 8, 1, '#4a4a8a'); R(x+3, y+1+oy, 10, 1, '#3a3a7a');
    R(x+5, y+oy-1, 6, 1, '#5a5a9a'); R(x+7, y+oy-2, 2, 1, '#4a4a8a');
  } else {
    R(x+4, y+oy, 8, 2, ch.hair); R(x+4, y+oy, 8, 1, ch.hairH);
  }
  // --- ARMS ---
  if (coding) {
    const ab = f % 2;
    R(x+1, y+8+oy, 2, 4, hM); R(x+1, y+8+oy, 2, 1, hL); R(x+1, y+12+oy, 2, 1, ch.skin);
    R(x+13, y+8+oy, 2, 4, hM); R(x+13, y+8+oy, 2, 1, hL); R(x+13, y+12+oy+ab, 2, 1, ch.skin);
  } else if (celeb) {
    R(x+1, y+2+oy, 2, 5, hM); R(x+1, y+2+oy, 2, 1, hL); R(x+1, y+1+oy, 2, 1, ch.skin);
    R(x+13, y+2+oy, 2, 5, hM); R(x+13, y+2+oy, 2, 1, hL); R(x+13, y+1+oy, 2, 1, ch.skin);
  } else if (slumped) {
    R(x+1, y+8+oy, 2, 6, hM); R(x+13, y+8+oy, 2, 6, hM);
  } else if (walk) {
    const as = [1, 0, -1, 0][f];
    R(x+1, y+8+oy, 2, 4+as, hM); R(x+1, y+8+oy, 2, 1, hL); R(x+1, y+12+oy+as, 2, 1, ch.skin);
    R(x+13, y+8+oy, 2, 4-as, hM); R(x+13, y+8+oy, 2, 1, hL); R(x+13, y+12+oy-as, 2, 1, ch.skin);
  } else if (state === 'reading' || state === 'waiting') {
    R(x+1, y+8+oy, 2, 4, hM); R(x+1, y+8+oy, 2, 1, hL);
    R(x+13, y+7+oy, 2, 2, hM); R(x+13, y+5+oy, 2, 2, hM); R(x+12, y+5+oy, 1, 1, ch.skin);
  } else {
    R(x+1, y+8+oy, 2, 4, hM); R(x+1, y+8+oy, 2, 1, hL);
    R(x+13, y+8+oy, 2, 4, hM); R(x+13, y+8+oy, 2, 1, hL);
  }
  // Coding headset
  if (coding && hs !== 3) {
    R(x+3, y+2+oy, 1, 3, '#555'); R(x+3, y+2+oy, 1, 1, '#777');
    R(x+12, y+2+oy, 1, 3, '#555'); R(x+12, y+2+oy, 1, 1, '#777');
    R(x+4, y+oy, 8, 1, '#444');
  }
  // Sleeping ZZZ
  if (sleeping) {
    const zf = frame % 90;
    ctx.fillStyle = '#aaddff'; ctx.font = '3px "Press Start 2P"';
    if (zf < 30) ctx.fillText('z', x+14, y+oy+2);
    else if (zf < 60) ctx.fillText('zZ', x+13, y+oy);
    else ctx.fillText('zZz', x+12, y+oy-2);
  }
  ctx.restore();
}

function drawFire(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE - 6;
  [[PAL.fire1,'#cc0033',4,4,4],[PAL.fire2,'#dd5500',5,2,6],[PAL.fire3,PAL.fire4,4,0,4]].forEach(([c1,c2,cnt,yOff,h]) => {
    for (let i = 0; i < cnt; i++) {
      ctx.fillStyle = Math.random() > 0.5 ? c1 : c2;
      ctx.fillRect(x + 2 + Math.floor(Math.random() * 12), y + yOff + Math.floor(Math.random() * h), 2, 2);
    }
  });
  for (let i = 0; i < 4; i++) {
    const age = (frame * 2 + i * 37) % 60;
    if (age < 30) {
      ctx.fillStyle = `rgba(255,136,0,${0.6 - age/50})`;
      ctx.fillRect(x + 4 + Math.sin(age * 0.3 + i) * 4, y - age / 4, 1, 1);
    }
  }
  R(x-2, y+8, TILE+4, 4, 'rgba(255,68,0,0.04)');
  ctx.restore();
}

function drawTombstone(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = (d.y + 1) * TILE + 2;
  R(x+1, y+11, 10, 1, 'rgba(0,0,0,0.2)');
  R(x+2, y, 8, 10, PAL.tombstone); R(x+3, y-1, 6, 1, PAL.tombstone);
  R(x+4, y-2, 4, 1, PAL.tombstoneLight); R(x+3, y, 6, 1, PAL.tombstoneLight);
  R(x+2, y+9, 8, 1, '#555');
  R(x+5, y+1, 2, 1, '#888'); R(x+4, y+2, 4, 1, '#888'); R(x+5, y+3, 2, 3, '#888');
  ctx.fillStyle = '#e0dfd8'; ctx.font = '4px "Press Start 2P"'; ctx.fillText('RIP', x+3, y+9);
  ctx.restore();
}

function drawBubble(d, text, color) {
  const px = d.x * S, py = (d.y * TILE - 10) * SCALE;
  R(px - 1, py - 13, text.length * 5.5 + 12, 13, 'rgba(0,0,0,0.8)');
  R(px + S/2 - 2, py, 4, 3, 'rgba(0,0,0,0.8)');
  ctx.fillStyle = color || '#fff'; ctx.font = '8px "Press Start 2P"';
  ctx.textAlign = 'center'; ctx.fillText(text, px + S/2, py - 3); ctx.textAlign = 'left';
}

function drawConfetti(d) {
  const cx = d.x * S + S/2, cy = d.y * S;
  const colors = ['#f0c040', '#4ae04a', '#fff', '#d1a128', '#ff5a9a', '#00e5ff'];
  for (let i = 0; i < 15; i++) {
    const a = (i / 15) * Math.PI * 2 + frame * 0.04;
    const dist = 20 + Math.sin(frame * 0.08 + i * 1.3) * 14;
    ctx.fillStyle = colors[i % colors.length];
    ctx.fillRect(cx + Math.cos(a) * dist, cy + Math.sin(a) * dist - 10, 2 + (i % 2), 2 + (i % 2));
  }
}

function drawCoffeeCups(d, count) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const baseX = d.x * TILE + TILE + 1;
  const baseY = d.y * TILE + 10;
  for (let i = 0; i < count; i++) {
    const cx = baseX + i * 5;
    R(cx, baseY, 3, 4, PAL.cup);
    R(cx, baseY + 4, 3, 1, PAL.cupDark);
    R(cx + 1, baseY + 1, 1, 2, PAL.coffee);
    R(cx + 3, baseY + 1, 1, 2, PAL.cupDark);
  }
  if (count > 0) {
    const lastX = baseX + (count - 1) * 5 + 1;
    const phase = frame % 20 < 10 ? 0 : 1;
    R(lastX, baseY - 1 - phase, 1, 1, 'rgba(255,255,255,0.4)');
  }
  ctx.restore();
}

function drawPrBadge(d, num, merged) {
  const x = d.x * S + S - 6, y = d.y * S - 2;
  R(x, y, 22, 12, merged ? '#d1a128' : '#2f9a3d');
  R(x, y, 22, 1, merged ? '#e8c848' : '#4ae04a');
  ctx.fillStyle = '#111'; ctx.font = '7px "Press Start 2P"'; ctx.fillText(`#${num}`, x + 2, y + 9);
}

function drawTokenBar(d, pct) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 1, y = (d.y + 1) * TILE + TILE - 2, w = TILE - 2;
  R(x, y, w, 2, '#0b0b12');
  const color = pct > 80 ? '#c13c3c' : pct > 50 ? '#d1a128' : '#2f9a3d';
  R(x, y, Math.floor(w * pct / 100), 2, color);
  ctx.restore();
}

function drawPlant(tx, ty) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = tx * TILE + 4, y = ty * TILE;
  R(x+2, y+10, 8, 6, PAL.plantPot); R(x+1, y+10, 10, 2, PAL.plantPotDark); R(x+3, y+10, 6, 1, PAL.plantPot);
  R(x+4, y+4, 4, 6, PAL.plant); R(x+2, y+2, 8, 4, PAL.plant);
  R(x, y+4, 3, 3, PAL.plant); R(x+9, y+3, 3, 4, PAL.plant);
  R(x+3, y+2, 2, 1, PAL.plantLight); R(x+7, y+3, 2, 1, PAL.plantLight); R(x+1, y+4, 1, 1, PAL.plantLight);
  ctx.restore();
}

function drawServerRack(px, py) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  R(px, py, 8, 16, '#1a1a1a'); R(px+1, py+1, 6, 14, '#111');
  for (let i = 0; i < 5; i++) {
    R(px+2, py+2+i*3, 1, 1, ((frame + i * 17) % 30) < 15 ? '#2f9a3d' : '#1a3a1a');
    R(px+4, py+2+i*3, 1, 1, ((frame + i * 23) % 40) < 20 ? '#3b7cff' : '#1a1a3a');
    R(px+2, py+3+i*3, 4, 1, '#222');
  }
  ctx.restore();
}

function drawDivider(col) {
  const x = (2 + col * 5 - 1) * S + S/2;
  ctx.strokeStyle = PAL.divider; ctx.lineWidth = 2; ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(x, S); ctx.lineTo(x, ROWS * S - S); ctx.stroke(); ctx.setLineDash([]);
}

function drawLampGlow(tx, ty) {
  const cx = tx * S + S/2, cy = ty * S;
  const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy + 60, 60);
  grad.addColorStop(0, 'rgba(255,240,200,0.06)'); grad.addColorStop(1, 'rgba(255,240,200,0)');
  ctx.fillStyle = grad; ctx.fillRect(cx - 60, cy, 120, 80);
}

// Tumbleweed
let tumbleX = -20;
function drawTumbleweed() {
  tumbleX = (tumbleX + 0.4) % (COLS * S + 40);
  const ty = (ROWS - 1) * S - 8 + Math.sin(tumbleX * 0.03) * 4;
  ctx.save(); ctx.translate(tumbleX, ty); ctx.rotate(frame * 0.06);
  ctx.fillStyle = '#6a5a30'; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#8a7a40'; ctx.lineWidth = 1;
  for (let i = 0; i < 5; i++) { const a = i * Math.PI / 2.5; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a)*5, Math.sin(a)*5); ctx.stroke(); }
  ctx.restore();
}

// ============================================================
// SV Environment Upgrade ‚Äî new draw functions
// ============================================================

function drawFloorSV() {
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      // Concrete/epoxy floor with subtle checkerboard + noise texture
      const checker = (c + r) % 2;
      const noise = Math.sin(c * 7 + r * 13) * 0.5 + 0.5;
      let base;
      if (checker === 0) base = noise > 0.3 ? PAL.svFloor1 : PAL.svFloor2;
      else base = noise > 0.5 ? PAL.svFloor3 : PAL.svFloor4;
      tileRect(c, r, 1, 1, base);
    }
  ctx.save(); ctx.scale(SCALE, SCALE);
  // Warm ambient tint
  ctx.fillStyle = PAL.svFloorWarm;
  ctx.fillRect(0, 0, COLS * TILE, ROWS * TILE);
  // Concrete cracks
  ctx.fillStyle = '#2e2845';
  for (let i = 0; i < 18; i++) ctx.fillRect(30 + i * 2, 95 + (Math.sin(i * 1.3) * 2 | 0), 2, 1);
  for (let i = 0; i < 12; i++) ctx.fillRect(170 + i * 2, 140 + (i % 3 === 0 ? 1 : 0), 1, 1);
  for (let i = 0; i < 8; i++) ctx.fillRect(100 + i * 3, 60 + (Math.sin(i * 0.7) | 0), 2, 1);
  // Floor stains (spilled coffee, etc)
  ctx.fillStyle = 'rgba(60,40,20,0.12)';
  ctx.fillRect(85, 125, 6, 5);
  ctx.fillRect(195, 105, 5, 4);
  ctx.fillRect(145, 160, 4, 3);
  // Epoxy shine spots
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(50, 80, 20, 15);
  ctx.fillRect(150, 50, 15, 12);
  ctx.fillRect(240, 120, 18, 10);
  ctx.restore();
}

function drawWallsSV() {
  // Base wall
  for (let c = 0; c < COLS; c++) tileRect(c, 0, 1, 1, PAL.wall);
  ctx.save(); ctx.scale(SCALE, SCALE);
  // Exposed brick sections on left and right walls
  const brickW = 4, brickH = 2;
  for (let section = 0; section < 3; section++) {
    const sx = [8, 140, 260][section];
    const sw = [40, 50, 40][section];
    for (let by = 1; by < TILE - 3; by += brickH + 1) {
      const offset = (by % 4 === 1) ? 0 : 2;
      for (let bx = sx + offset; bx < sx + sw; bx += brickW + 1) {
        const bColor = Math.random() > 0.3 ? PAL.svBrick : PAL.svBrickDark;
        ctx.fillStyle = bColor;
        ctx.fillRect(bx, by, Math.min(brickW, sx + sw - bx), brickH);
        // Mortar
        ctx.fillStyle = PAL.svBrickMortar;
        ctx.fillRect(bx + brickW, by, 1, brickH);
        ctx.fillRect(bx, by + brickH, brickW + 1, 1);
      }
    }
  }
  // Baseboard
  ctx.fillStyle = '#3a3028'; ctx.fillRect(0, TILE - 2, COLS * TILE, 2);
  ctx.fillStyle = '#4a4038'; ctx.fillRect(0, TILE - 2, COLS * TILE, 1);
  // Electrical conduit lines running along wall
  ctx.fillStyle = PAL.svConduit;
  ctx.fillRect(0, TILE - 4, COLS * TILE, 1);
  ctx.fillStyle = PAL.svConduitLight;
  for (let x = 0; x < COLS * TILE; x += 30) {
    ctx.fillRect(x, TILE - 5, 1, 3); // conduit brackets
  }
  // Fluorescent light strips on ceiling ‚Äî brighter at night
  const { nightFactor: wallNF } = getTimeOfDay();
  const flourGlowAlpha = (0.06 + wallNF * 0.12).toFixed(3);
  for (let i = 0; i < 4; i++) {
    const lx = 30 + i * 70, ly = 0;
    ctx.fillStyle = PAL.svFluor;
    ctx.fillRect(lx, ly, 30, 2);
    ctx.fillStyle = wallNF > 0.3 ? 'rgba(255,255,255,' + (0.8 + wallNF * 0.2).toFixed(2) + ')' : '#fff';
    ctx.fillRect(lx + 2, ly, 26, 1);
    // Glow below
    ctx.fillStyle = 'rgba(200,232,255,' + flourGlowAlpha + ')';
    ctx.fillRect(lx - 4, ly + 2, 38, 8);
  }
  ctx.restore();
}

function drawDeskSV(d, idx) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE + 8;
  const isStanding = idx % 3 === 0; // every 3rd desk is standing
  const isLaptop = idx % 4 === 1; // every 4th desk has laptop combo

  if (isStanding) {
    // Standing desk ‚Äî taller frame, adjustable legs
    R(x, y - 2, TILE, 2, PAL.svDeskSurface); R(x, y - 2, TILE, 1, PAL.svDeskFrameLight);
    R(x, y, TILE, 1, PAL.svDeskSurfaceDark);
    // Height-adjustable frame legs (double lines)
    R(x + 1, y + 1, 1, 10, PAL.svDeskFrame); R(x + 2, y + 1, 1, 10, PAL.svDeskFrameDark);
    R(x + TILE - 3, y + 1, 1, 10, PAL.svDeskFrame); R(x + TILE - 2, y + 1, 1, 10, PAL.svDeskFrameDark);
    // Crossbar
    R(x + 2, y + 6, TILE - 4, 1, PAL.svDeskFrameDark);
  } else {
    // Regular desk ‚Äî wider, L-shaped modern desk
    R(x, y, TILE, 2, PAL.svDeskSurface); R(x, y, TILE, 1, '#d8ccb4');
    for (let gx = x + 2; gx < x + TILE - 1; gx += 3) R(gx, y + 1, 2, 1, PAL.svDeskSurfaceDark);
    R(x, y + 2, TILE, 3, PAL.svDeskFrame); R(x, y + 2, TILE, 1, PAL.svDeskFrameLight);
    // Metal legs
    R(x + 1, y + 5, 1, 7, PAL.svDeskFrameDark); R(x + TILE - 2, y + 5, 1, 7, PAL.svDeskFrameDark);
    R(x + 1, y + 11, 3, 1, PAL.svDeskFrame); R(x + TILE - 4, y + 11, 3, 1, PAL.svDeskFrame);
  }

  // Keyboard on desk surface
  const ky = isStanding ? y - 1 : y + 1;
  R(x + 3, ky, 6, 2, PAL.svKeyboard);
  for (let kx = x + 3; kx < x + 9; kx += 2) R(kx, ky, 1, 1, PAL.svKeyboardKey);
  // Mouse
  R(x + 11, ky, 2, 2, PAL.svMouse);
  R(x + 11, ky, 2, 1, '#444');

  // Cable mess under desk
  ctx.fillStyle = PAL.svCable;
  const cableY = isStanding ? y + 8 : y + 8;
  for (let i = 0; i < 4; i++) {
    const cx = x + 3 + i * 3;
    const cy = cableY + Math.sin(i * 2.1) * 1.5;
    ctx.fillRect(cx, cy, 2, 1);
    ctx.fillRect(cx + 1, cy + 1, 2, 1);
  }
  ctx.restore();
}

function drawMonitorSV(d, state, monitorText, idx) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 1, y = d.y * TILE;
  const isLaptop = idx % 4 === 1;

  // Primary monitor ‚Äî slightly wider
  R(x, y, 12, 8, PAL.monitorBezel); R(x + 1, y, 10, 1, PAL.monitor);
  const sc = state === 'ci_failed' ? '#3a0808' : (state === 'coding' ? '#0a200a' : '#0a0a0a');
  R(x + 1, y + 1, 10, 6, sc);
  // Monitor stand
  R(x + 4, y + 8, 4, 1, '#333'); R(x + 3, y + 9, 6, 1, '#2a2a2a');

  if (isLaptop) {
    // Laptop beside primary monitor
    R(x + 13, y + 5, 3, 3, PAL.svLaptop);
    R(x + 13, y + 5, 3, 2, PAL.svLaptopScreen);
    R(x + 13, y + 4, 4, 1, PAL.svLaptop); // lid
  } else {
    // Secondary monitor (smaller, slightly offset)
    R(x + 13, y + 1, 3, 5, PAL.svMonitor2Bezel);
    R(x + 13, y + 1, 3, 1, PAL.svMonitor2);
    R(x + 13, y + 2, 3, 3, sc === '#0a0a0a' ? '#0c0c0c' : sc);
    R(x + 14, y + 6, 1, 1, '#333');
  }

  // Screen content on primary monitor
  if (state === 'coding') {
    const colors = ['#4ae04a', '#2a8a2a', '#6af06a', '#3aaa3a'];
    for (let line = 0; line < 5; line++) {
      const indent = line === 2 ? 2 : (line === 4 ? 1 : 0);
      const len = 2 + (line * 3 + frame) % 5;
      R(x + 2 + indent, y + 1 + line, Math.min(len, 8 - indent), 1, colors[line % colors.length]);
    }
    if (frame % 10 < 5) R(x + 9, y + 5, 1, 1, '#4ae04a');
  } else if (state === 'ci_failed') {
    const bright = Math.sin(frame * 0.1) > 0;
    const c = bright ? '#ff3b3b' : '#aa2222';
    R(x + 3, y + 1, 1, 1, c); R(x + 7, y + 1, 1, 1, c);
    R(x + 4, y + 2, 1, 1, c); R(x + 6, y + 2, 1, 1, c); R(x + 5, y + 3, 1, 1, c);
    R(x + 4, y + 4, 1, 1, c); R(x + 6, y + 4, 1, 1, c);
    R(x + 3, y + 5, 1, 1, c); R(x + 7, y + 5, 1, 1, c);
  } else if (state === 'merged') {
    R(x + 5, y + 1, 2, 1, '#f0c040'); R(x + 4, y + 2, 4, 1, '#f0c040');
    R(x + 3, y + 3, 6, 1, '#d8a820'); R(x + 4, y + 4, 4, 1, '#f0c040');
  } else {
    R(x + 4, y + 3, 1, 1, '#4ae04a'); R(x + 5, y + 4, 1, 1, '#4ae04a');
    R(x + 6, y + 3, 1, 1, '#4ae04a'); R(x + 7, y + 2, 1, 1, '#4ae04a');
  }

  // Scrolling issue title text on monitor screen
  if (monitorText) {
    ctx.restore();
    const sx = (x + 1) * SCALE, sy = (y + 1) * SCALE, sw = 10 * SCALE, sh = 6 * SCALE;
    ctx.save();
    ctx.beginPath(); ctx.rect(sx, sy, sw, sh); ctx.clip();
    ctx.fillStyle = state === 'ci_failed' ? '#ff6666' : (state === 'coding' ? '#4ae04a' : '#8888ff');
    ctx.font = '5px "Press Start 2P", monospace';
    ctx.textBaseline = 'middle';
    const textWidth = ctx.measureText(monitorText).width;
    const totalScroll = textWidth + sw + 4;
    const scroll = (frame * 0.6) % totalScroll;
    ctx.fillText(monitorText, sx + sw - scroll, sy + sh / 2);
    ctx.restore();
    ctx.save(); ctx.scale(SCALE, SCALE);
  }

  // Monitor glow on desk/floor
  if (state === 'coding' || state === 'ci_failed') {
    const glowColor = state === 'ci_failed' ? 'rgba(255,59,59,0.06)' : 'rgba(74,224,74,0.06)';
    R(x - 1, y + 9, 14, 4, glowColor);
  }
  ctx.restore();
}

function drawChairSV(d, idx) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = d.y * TILE + 10;
  const chairColor = PAL.svChairColors[idx % PAL.svChairColors.length];
  const chairDark = '#1a1a1a';

  // Seat (mesh texture - striped)
  R(x, y, 10, 2, chairColor);
  for (let mx = x; mx < x + 10; mx += 2) R(mx, y, 1, 2, chairDark + '44');
  R(x, y, 10, 1, chairColor);

  // Backrest (mesh outline with pattern)
  R(x, y - 7, 10, 3, chairColor);
  for (let mx = x + 1; mx < x + 9; mx += 2) R(mx, y - 6, 1, 2, chairDark + '44');
  R(x, y - 7, 10, 1, PAL.svChairFrame); // top edge
  R(x, y - 4, 10, 1, PAL.svChairFrame); // bottom edge

  // Armrests
  R(x - 1, y - 2, 2, 1, PAL.svChairFrame);
  R(x + 9, y - 2, 2, 1, PAL.svChairFrame);
  // Side supports
  R(x, y - 4, 1, 5, chairDark);
  R(x + 9, y - 4, 1, 5, chairDark);

  // Center post
  R(x + 4, y + 2, 2, 2, PAL.svChairFrame);
  // Star base
  R(x + 1, y + 4, 8, 1, PAL.svChairFrame);
  // Wheels (small dots at base)
  R(x, y + 5, 2, 1, PAL.svChairWheel);
  R(x + 4, y + 5, 2, 1, PAL.svChairWheel);
  R(x + 8, y + 5, 2, 1, PAL.svChairWheel);
  ctx.restore();
}

function drawPropsSV() {
  ctx.save(); ctx.scale(SCALE, SCALE);

  // 1. Pizza boxes ‚Äî stacked near bottom-left corner
  const pzX = 22, pzY = TILE * (ROWS - 2) + 4;
  for (let i = 0; i < 3; i++) {
    R(pzX, pzY - i * 3, 12, 3, PAL.svPizzaBox);
    R(pzX, pzY - i * 3, 12, 1, PAL.svPizzaBoxDark);
    R(pzX + 1, pzY - i * 3 + 1, 10, 1, '#c89838'); // lid line
  }
  // Top box slightly open
  R(pzX + 1, pzY - 8, 10, 1, '#d8a848');

  // 2. Energy drink cans ‚Äî scattered
  const cans = [[75, 42], [190, 75], [135, 108], [250, 42]];
  cans.forEach(([cx, cy], i) => {
    const canColor = i % 2 === 0 ? PAL.svEnergy : '#40c0ff';
    R(cx, cy, 3, 5, PAL.svEnergyCan);
    R(cx, cy + 1, 3, 3, canColor);
    R(cx, cy, 3, 1, '#999'); // top rim
  });

  // 3. Sticky notes ‚Äî colored squares on wall near whiteboard
  const stickyX = 270, stickyY = 3;
  PAL.svSticky.forEach((color, i) => {
    const sx = stickyX + (i % 2) * 6;
    const sy = stickyY + Math.floor(i / 2) * 6;
    R(sx, sy, 5, 5, color);
    // Tiny scribble lines
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(sx + 1, sy + 1, 3, 1);
    ctx.fillRect(sx + 1, sy + 3, 2, 1);
  });

  // 4. "MOVE FAST" poster on wall
  const postX = 200, postY = 2;
  R(postX, postY, 16, 10, PAL.svPoster);
  R(postX, postY, 16, 1, '#ccc');
  ctx.fillStyle = PAL.svPosterText;
  ctx.font = '2px "Press Start 2P"';
  ctx.fillText('MOVE', postX + 2, postY + 5);
  ctx.fillText('FAST', postX + 3, postY + 8);

  // 5. Skateboard ‚Äî leaning against wall near door
  const skX = 22, skY = TILE - 1;
  R(skX, skY, 10, 2, PAL.svSkateDeck);
  R(skX + 1, skY + 2, 2, 1, PAL.svSkateTruck);
  R(skX + 7, skY + 2, 2, 1, PAL.svSkateTruck);
  R(skX, skY + 3, 2, 1, PAL.svSkateWheel);
  R(skX + 8, skY + 3, 2, 1, PAL.svSkateWheel);

  // 6. Cardboard boxes ‚Äî stacked near entrance
  const bxX = 28, bxY = TILE + 6;
  R(bxX, bxY, 10, 8, PAL.svCardboard);
  R(bxX, bxY, 10, 1, PAL.svCardboardDark);
  R(bxX + 1, bxY + 3, 8, 1, PAL.svCardboardDark); // tape
  // Second box on top, slightly offset
  R(bxX + 2, bxY - 6, 8, 6, PAL.svCardboard);
  R(bxX + 2, bxY - 6, 8, 1, PAL.svCardboardDark);
  R(bxX + 3, bxY - 3, 6, 1, PAL.svCardboardDark);
  // Arrow marking
  ctx.fillStyle = '#666';
  ctx.fillRect(bxX + 4, bxY + 4, 2, 3);
  ctx.fillRect(bxX + 3, bxY + 4, 4, 1);

  // 7. Bean bag ‚Äî bottom-right corner area
  const bbX = (COLS - 2) * TILE + 2, bbY = (ROWS - 2) * TILE + 2;
  R(bbX + 1, bbY + 2, 10, 6, PAL.svBeanBag);
  R(bbX, bbY + 4, 12, 4, PAL.svBeanBag);
  R(bbX + 2, bbY + 1, 8, 2, PAL.svBeanBag);
  R(bbX + 2, bbY + 2, 6, 1, PAL.svBeanBagDark);
  R(bbX + 1, bbY + 6, 10, 2, PAL.svBeanBagDark);
  // Highlight
  R(bbX + 3, bbY + 2, 3, 1, '#dd5577');

  // 8. Mini fridge ‚Äî near server rack
  const frX = (COLS - 1) * TILE - 14, frY = 6 * TILE + 2;
  R(frX, frY, 8, 12, PAL.svFridge);
  R(frX, frY, 8, 1, PAL.svFridgeDark);
  R(frX, frY + 11, 8, 1, PAL.svFridgeDark);
  R(frX + 7, frY + 3, 1, 4, PAL.svFridgeHandle);
  // Magnetic sticker
  R(frX + 2, frY + 2, 3, 3, '#ff5566');
  R(frX + 2, frY + 6, 3, 3, '#55aaff');

  ctx.restore();
}

function drawLightingSV() {
  const { nightFactor } = getTimeOfDay();
  // Neon sign extended glow on nearby walls/floor ‚Äî stronger at night
  const neonCX = (55 + 24) * SCALE;
  const neonCY = 5 * SCALE;
  const neonAlpha1 = (0.07 + nightFactor * 0.08).toFixed(3);
  const neonAlpha2 = (0.03 + nightFactor * 0.04).toFixed(3);
  const neonGrad = ctx.createRadialGradient(neonCX, neonCY, 10, neonCX, neonCY + 80, 140);
  neonGrad.addColorStop(0, 'rgba(255,45,123,' + neonAlpha1 + ')');
  neonGrad.addColorStop(0.5, 'rgba(0,229,255,' + neonAlpha2 + ')');
  neonGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = neonGrad;
  ctx.fillRect(neonCX - 140, neonCY - 10, 280, 200);

  // Fluorescent ceiling light glow pools on floor ‚Äî brighter at night
  const ceilAlpha = (0.04 + nightFactor * 0.08).toFixed(3);
  for (let i = 0; i < 4; i++) {
    const lx = (30 + i * 70 + 15) * SCALE;
    const ly = 3 * S;
    const flGrad = ctx.createRadialGradient(lx, ly, 5, lx, ly + 40, 80);
    flGrad.addColorStop(0, 'rgba(200,232,255,' + ceilAlpha + ')');
    flGrad.addColorStop(1, 'rgba(200,232,255,0)');
    ctx.fillStyle = flGrad;
    ctx.fillRect(lx - 80, ly, 160, 100);
  }

  // Night: draw visible ceiling light rectangles
  if (nightFactor > 0.2) {
    ctx.save(); ctx.scale(SCALE, SCALE);
    const lightAlpha = (nightFactor * 0.6).toFixed(3);
    ctx.fillStyle = 'rgba(220,240,255,' + lightAlpha + ')';
    for (let i = 0; i < 4; i++) {
      const lx = 30 + i * 70;
      ctx.fillRect(lx + 4, 0, 22, 2);
    }
    ctx.restore();
  }

  // Night: monitor screens cast visible light pools on nearby floor
  if (nightFactor > 0.2) {
    const monGlowAlpha = (nightFactor * 0.05).toFixed(3);
    DESKS.forEach(d => {
      const mx = (d.x * TILE + 6) * SCALE;
      const my = (d.y * TILE + 10) * SCALE;
      const mGrad = ctx.createRadialGradient(mx, my, 2, mx, my + 20, 40);
      mGrad.addColorStop(0, 'rgba(74,224,74,' + monGlowAlpha + ')');
      mGrad.addColorStop(1, 'rgba(74,224,74,0)');
      ctx.fillStyle = mGrad;
      ctx.fillRect(mx - 40, my - 5, 80, 50);
    });
  }
}

// Map live agents to desk positions for canvas rendering
function buildCanvasAgents() {
  return agents.slice(0, 12).map((agent, idx) => {
    const state = mapState(agent);
    const canvasState = state === 'waiting' || state === 'reading' ? 'reading' :
                        state === 'review_waiting' ? 'reading' :
                        state === 'dead' ? 'exited' :
                        state === 'pr_closed' ? 'sleeping' :
                        state;
    return {
      desk: idx,
      ci: idx % CHARS.length,
      state: canvasState,
      pr: getPrNumber(agent),
      tokens: Math.min(100, Math.max(0, getTokens(agent) / 2000 * 100)),
      dead: state === 'dead' || state === 'exited',
      label: getRepoName(agent) + (getIssueId(agent) ? '#' + getIssueId(agent) : ''),
      monitorText: (function() {
        const title = (agent.issueTitle || '').toString().trim();
        const repo = getRepoName(agent);
        const id = getIssueId(agent);
        const prefix = repo && id ? repo + '#' + id : (repo || '');
        return title && prefix ? prefix + ' ‚Äî ' + title : (title || prefix || '');
      })(),
      failing: isCiFailing(agent),
      coffees: coffeeCount(agent),
      agentType: resolveAgentType(agent),
    };
  });
}

function render() {
  frame++;
  ctx.clearRect(0, 0, 640, 384);

  drawFloorSV(); drawWallsSV(); drawGarageFrame(); drawWindow(); drawDoor();
  drawNeonSign(); drawWhiteboard();
  drawLightingSV();
  drawLampGlow(5, 0); drawLampGlow(15, 0);
  drawDivider(2); drawDivider(3);
  drawPropsSV();

  DESKS.forEach((d, idx) => { drawDeskSV(d, idx); drawChairSV(d, idx); });

  // Update walking transitions
  updateTransitions();
  const walkingDesks = new Set(transitions.map(t => t.deskIdx));

  const canvasAgents = buildCanvasAgents();
  canvasAgents.forEach(a => {
    const d = DESKS[a.desk];
    if (!d) return;
    const isWalking = walkingDesks.has(a.desk);
    const screenState = isWalking ? 'pr_open' :
      a.failing ? 'ci_failed' :
      a.state === 'coding' ? 'coding' :
      a.state === 'merged' ? 'merged' : 'pr_open';
    drawMonitorSV(d, screenState, a.monitorText, a.desk);

    if (isWalking) return;

    if (a.dead) { drawTombstone(d); drawCharacterSV(d, a.ci, 'exited', a.agentType); }
    else drawCharacterSV(d, a.ci, a.state, a.agentType);

    drawTokenBar(d, a.tokens);
    if (a.coffees > 0) drawCoffeeCups(d, a.coffees);
    if (a.failing) drawFire(d);
    if (a.pr) drawPrBadge(d, a.pr, a.state === 'merged');
    if (a.label) {
      const bc = a.failing ? '#f66' : (a.state === 'merged' ? '#f0c040' : '#fff');
      drawBubble(d, a.label, bc);
    }
    if (a.state === 'merged') drawConfetti(d);
  });

  // Draw walking agents at interpolated positions
  transitions.forEach(t => {
    const now = Date.now();
    if (now < t.startTime) return;
    const pos = positionAlongPath(t.path, t.progress);
    drawCharacterSV(pos, t.colorIdx, 'walking', t.agentType);
  });

  // Click glow feedback
  if (clickedDesk >= 0 && Date.now() - clickedAt < 300) {
    const gd = DESKS[clickedDesk];
    if (gd) {
      const alpha = 0.3 * (1 - (Date.now() - clickedAt) / 300);
      ctx.fillStyle = 'rgba(240, 192, 64, ' + alpha + ')';
      ctx.fillRect(gd.x * S - 2, gd.y * S - 4, S + 4, S * 2 + 8);
    }
  }

  drawTumbleweed();
  drawPlant(0, 2); drawPlant(0, 9); drawPlant(COLS - 1, 4);
  drawServerRack((COLS - 1) * TILE - 4, 6 * TILE);

  // Day/night overlay ‚Äî applied last, over entire scene
  drawDayNightOverlay();

  requestAnimationFrame(render);
}

// === SIDEBAR RESIZE ===
(function() {
  const sidebar = document.getElementById('sidebar');
  const handle = document.getElementById('resizeHandle');
  let dragging = false, startX, startW;
  handle.addEventListener('mousedown', (e) => {
    e.preventDefault(); dragging = true; startX = e.clientX; startW = sidebar.offsetWidth;
    handle.classList.add('dragging'); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    sidebar.style.width = Math.max(200, Math.min(600, startW + (e.clientX - startX))) + 'px';
  });
  document.addEventListener('mouseup', () => {
    if (!dragging) return; dragging = false;
    handle.classList.remove('dragging'); document.body.style.cursor = ''; document.body.style.userSelect = '';
    try { localStorage.setItem('corral-sidebar-w', sidebar.offsetWidth); } catch {}
  });
  try { const saved = localStorage.getItem('corral-sidebar-w'); if (saved) sidebar.style.width = saved + 'px'; } catch {}
})();

// === MOBILE SIDEBAR TOGGLE ===
function toggleMobileSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('mobileOverlay');
  const isOpen = sidebar.classList.contains('mobile-open');
  if (isOpen) {
    sidebar.classList.remove('mobile-open');
    overlay.classList.remove('visible');
  } else {
    sidebar.classList.add('mobile-open');
    overlay.classList.add('visible');
  }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const sidebar = document.getElementById('sidebar');
    if (sidebar.classList.contains('mobile-open')) toggleMobileSidebar();
  }
  if ((e.key === 's' || e.key === 'S') && !e.ctrlKey && !e.metaKey && !e.altKey) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    toggleSound();
  }
});

// Agent card tap-to-expand on mobile (touch devices)
document.addEventListener('click', (e) => {
  if (window.innerWidth >= 768) return;
  const card = e.target.closest('.agent-card');
  if (!card) return;
  // Toggle expanded state
  const wasExpanded = card.classList.contains('mobile-expanded');
  // Collapse all other cards first
  document.querySelectorAll('.agent-card.mobile-expanded').forEach(c => c.classList.remove('mobile-expanded'));
  if (!wasExpanded) card.classList.add('mobile-expanded');
});

// === CANVAS CLICK ‚Äî open agent URL ===
let clickedDesk = -1, clickedAt = 0;

function getAgentUrl(agent) {
  if (!agent) return null;
  if (agent.prUrl) return agent.prUrl;
  const prNum = getPrNumber(agent);
  if (prNum && agent.repo) return 'https://github.com/' + agent.repo + '/pull/' + prNum;
  const issueId = getIssueId(agent);
  if (agent.repo && issueId) return 'https://github.com/' + agent.repo + '/issues/' + issueId;
  return null;
}

function hitTestAgent(cx, cy) {
  const canvasAgents = buildCanvasAgents();
  for (const a of canvasAgents) {
    const desk = DESKS[a.desk];
    if (!desk) continue;
    // Hit region centered on desk+character area
    const dx = desk.x * S + S / 2;
    const dy = (desk.y + 1) * S;
    if (Math.abs(cx - dx) < S * 0.7 && Math.abs(cy - dy) < S) {
      return a.desk;
    }
  }
  return -1;
}

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  const idx = hitTestAgent(cx, cy);
  if (idx >= 0 && idx < agents.length) {
    const url = getAgentUrl(agents[idx]);
    if (url) {
      clickedDesk = idx;
      clickedAt = Date.now();
      window.open(url, '_blank', 'noopener');
    }
  }
});

// === CANVAS HOVER TOOLTIP ===
const canvasTooltip = document.getElementById('canvasTooltip');
let hoveredDeskIdx = -1;
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

function buildCanvasTooltip(agent) {
  if (!agent) return '';
  const repoName = getRepoName(agent);
  const issueId = getIssueId(agent);
  const label = repoName && issueId ? escapeHtml(repoName + '#' + issueId) : escapeHtml(repoName || agent.id || 'agent');
  const state = mapState(agent);
  const statusText = escapeHtml(stateLabel(state));
  const pulseClass = stateToPulseClass(state);
  const agentType = escapeHtml(resolveAgentType(agent) || 'unknown');
  const created = getCreatedAt(agent);
  const uptime = created ? escapeHtml(formatDuration(Date.now() - created)) : '‚Äî';
  const prNum = getPrNumber(agent);
  const prUrl = agent.prUrl || '';
  const prDisplay = prNum ? `PR #${escapeHtml(prNum)}` : '‚Äî';
  const prLink = prUrl && prNum ? `<a href="${escapeHtml(prUrl)}" target="_blank" rel="noopener" style="color:#88aaff;pointer-events:auto">${prDisplay}</a>` : prDisplay;
  const issueTitle = agent.issueTitle ? escapeHtml(agent.issueTitle) : '';
  const titleRow = issueTitle ? `<div class="tt-row"><span class="tt-lbl">Issue</span><span style="color:#999">${issueTitle}</span></div>` : '';
  return `
    <div class="tt-title"><span class="ac-pulse ${pulseClass}"></span><span>${label}</span></div>
    <div class="tt-row"><span class="tt-lbl">Status</span><span class="${stateToColorClass(state)}">${statusText}</span></div>
    <div class="tt-row"><span class="tt-lbl">Type</span><span>${agentType}</span></div>
    <div class="tt-row"><span class="tt-lbl">Uptime</span><span>${uptime}</span></div>
    <div class="tt-row"><span class="tt-lbl">PR</span><span>${prLink}</span></div>
    ${titleRow}
  `;
}

function positionCanvasTooltip(clientX, clientY) {
  const pad = 14;
  let left = clientX + pad;
  let top = clientY + pad;
  const { offsetWidth: w, offsetHeight: h } = canvasTooltip;
  if (left + w > window.innerWidth - 8) left = clientX - w - pad;
  if (top + h > window.innerHeight - 8) top = clientY - h - pad;
  canvasTooltip.style.left = Math.max(8, left) + 'px';
  canvasTooltip.style.top = Math.max(8, top) + 'px';
}

function showCanvasTooltip(agent, clientX, clientY) {
  canvasTooltip.innerHTML = buildCanvasTooltip(agent);
  canvasTooltip.style.display = 'block';
  canvasTooltip.setAttribute('aria-hidden', 'false');
  positionCanvasTooltip(clientX, clientY);
}

function hideCanvasTooltip() {
  hoveredDeskIdx = -1;
  canvasTooltip.style.display = 'none';
  canvasTooltip.setAttribute('aria-hidden', 'true');
}

canvas.addEventListener('mousemove', (e) => {
  if (isTouchDevice) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  const idx = hitTestAgent(cx, cy);
  if (idx >= 0 && idx < agents.length) {
    canvas.style.cursor = 'pointer';
    if (idx !== hoveredDeskIdx) {
      hoveredDeskIdx = idx;
      showCanvasTooltip(agents[idx], e.clientX, e.clientY);
    } else {
      positionCanvasTooltip(e.clientX, e.clientY);
    }
  } else {
    canvas.style.cursor = '';
    if (hoveredDeskIdx >= 0) hideCanvasTooltip();
  }
});

canvas.addEventListener('mouseleave', () => {
  if (hoveredDeskIdx >= 0) hideCanvasTooltip();
});

// === START ===
try { soundEnabled = localStorage.getItem('corral-sound') === '1'; } catch {}
updateSoundButton();
requestAnimationFrame(render);
startPolling();
</script>
</body>
</html>
