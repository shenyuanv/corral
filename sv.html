<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corral ü§† ‚Äî SV Mode</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://unpkg.com/snes.css@1.0.1/dist/snes.min.css" rel="stylesheet" />
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0c0c1a;
    font-family: 'Press Start 2P', cursive;
    color: #c0c0c0;
    overflow: hidden;
    height: 100vh;
  }

  /* === TOP BAR === */
  .top-bar {
    background: linear-gradient(180deg, #1e1e3a, #14142a);
    border-bottom: 3px solid #2a2a4a;
    padding: 0 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 44px;
  }
  .top-title {
    color: #f0c040;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 10px;
    text-shadow: 2px 2px 0 #000;
  }
  .top-title .ver { color: #555; font-size: 7px; font-weight: normal; }
  .top-stats {
    display: flex;
    gap: 18px;
    font-size: 7px;
    color: #666;
    align-items: center;
  }
  .top-stats .val { color: #5dfc5d; text-shadow: 0 0 6px #5dfc5d33; }
  .top-stats .val-warn { color: #d1a128; }
  .top-stats .val-bad { color: #e76e55; }
  .top-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .conn-dot {
    width: 9px; height: 9px;
    border-radius: 50%;
    border: 2px solid #0b0b12;
  }
  .conn-dot.connected { background: #2f9a3d; box-shadow: 0 0 6px #2f9a3d88; }
  .conn-dot.connecting { background: #d1a128; box-shadow: 0 0 6px #d1a12888; }
  .conn-dot.disconnected { background: #6c6c6c; }
  .top-btn {
    background: #1b1b2b;
    color: #ccc;
    border: 2px solid #3a3a5c;
    padding: 2px 8px;
    font-family: inherit;
    font-size: 9px;
    cursor: pointer;
  }
  .top-btn:hover { background: #24243a; }
  .top-btn.active { color: #f0c040; border-color: #6d6d8f; }

  /* === MAIN LAYOUT === */
  .main {
    display: flex;
    height: calc(100vh - 44px);
  }

  /* === SIDEBAR === */
  .sidebar {
    width: 300px;
    min-width: 200px;
    max-width: 600px;
    background: linear-gradient(180deg, rgba(18,18,38,0.97), rgba(10,10,22,0.99));
    border-right: 3px solid #2a2a4a;
    overflow-y: auto;
    font-size: 8px;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  /* Drag handle */
  .resize-handle {
    position: absolute;
    top: 0; right: -5px;
    width: 10px;
    height: 100%;
    cursor: col-resize;
    z-index: 20;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .resize-handle::after {
    content: '';
    width: 3px;
    height: 40px;
    background: #3a3a5c;
    border-radius: 2px;
    transition: background 0.2s, height 0.2s;
  }
  .resize-handle:hover::after,
  .resize-handle.dragging::after {
    background: #f0c040;
    height: 60px;
    box-shadow: 0 0 8px #f0c04044;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

  .sb-section {
    padding: 10px 12px;
    border-bottom: 2px solid #1a1a30;
  }
  .sb-section:last-child { border-bottom: none; flex: 1; }

  .sb-header {
    color: #f0c040;
    font-size: 9px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    text-shadow: 0 0 8px #f0c04022;
  }
  .sb-header .count { color: #666; font-size: 7px; }

  /* Agent cards */
  .agent-card {
    background: linear-gradient(135deg, #1a1a30, #141428);
    border: 2px solid #2a2a4a;
    border-radius: 3px;
    padding: 8px 10px;
    margin-bottom: 8px;
    position: relative;
    overflow: hidden;
  }
  .agent-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 3px; height: 100%;
  }
  .agent-card.st-coding::before { background: #2f9a3d; box-shadow: 0 0 6px #2f9a3d88; }
  .agent-card.st-coding { border-color: #2a5a2a; }
  .agent-card.st-pr::before { background: #3b7cff; box-shadow: 0 0 6px #3b7cff88; }
  .agent-card.st-pr { border-color: #2a3a6a; }
  .agent-card.st-ci::before { background: #e76e55; box-shadow: 0 0 6px #e76e5588; }
  .agent-card.st-ci { border-color: #6a2a2a; }
  .agent-card.st-merged::before { background: #f0c040; box-shadow: 0 0 6px #f0c04088; }
  .agent-card.st-merged { border-color: #6a5a20; opacity: 0.85; }
  .agent-card.st-dead::before { background: #6c6c6c; }
  .agent-card.st-dead { border-color: #3a3a3a; opacity: 0.7; }
  .agent-card.st-closed::before { background: #8855aa; box-shadow: 0 0 6px #8855aa88; }
  .agent-card.st-closed { border-color: #4a2a5a; opacity: 0.8; }

  .ac-top {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
  }
  .ac-pulse {
    width: 7px; height: 7px;
    border-radius: 50%;
    display: inline-block;
  }
  .ac-pulse.green { background: #2f9a3d; box-shadow: 0 0 4px #2f9a3d; animation: pulse 2s infinite; }
  .ac-pulse.blue { background: #3b7cff; box-shadow: 0 0 4px #3b7cff; animation: pulse 2s infinite; }
  .ac-pulse.red { background: #e76e55; box-shadow: 0 0 4px #e76e55; animation: pulse-fast 0.8s infinite; }
  .ac-pulse.gold { background: #f0c040; animation: none; }
  .ac-pulse.gray { background: #6c6c6c; animation: none; }
  .ac-pulse.purple { background: #8855aa; animation: none; }
  @keyframes pulse { 0%,100% { opacity:1 } 50% { opacity:0.4 } }
  @keyframes pulse-fast { 0%,100% { opacity:1 } 50% { opacity:0.2 } }

  .ac-name { font-size: 9px; }
  .ac-time { color: #444; font-size: 7px; margin-left: auto; }

  .ac-detail { color: #666; line-height: 2; }
  .ac-detail .repo { color: #88aaff; }
  .ac-detail .issue { color: #999; }

  .v-green { color: #5dfc5d; }
  .v-blue { color: #3b7cff; }
  .v-red { color: #e76e55; }
  .v-gold { color: #f0c040; }
  .v-gray { color: #6c6c6c; }
  .v-purple { color: #8855aa; }
  .v-cyan { color: #00e5ff; }

  /* === NOTIFICATION BALLOONS === */
  #notificationArea {
    display: flex;
    flex-direction: column;
    gap: 6px;
    margin-bottom: 8px;
  }
  .notif-balloon {
    font-size: 7px;
    line-height: 1.8;
    padding: 8px 10px;
    animation: notifIn 0.3s ease-out;
    transition: opacity 0.5s ease, transform 0.5s ease;
    word-break: break-word;
  }
  .notif-balloon.fade-out {
    opacity: 0;
    transform: translateY(-8px);
  }
  @keyframes notifIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .notif-balloon .notif-text-blue { color: #3b7cff; }
  .notif-balloon .notif-text-red { color: #e76e55; }
  .notif-balloon .notif-text-gold { color: #f0c040; }
  .notif-balloon .notif-text-gray { color: #6c6c6c; }
  .notif-balloon .notif-text-green { color: #5dfc5d; }

  .progress-bar {
    height: 3px;
    background: #1a1a30;
    margin-top: 6px;
    border-radius: 2px;
    overflow: hidden;
  }
  .progress-bar .fill { height: 100%; border-radius: 2px; }
  .fill-green { background: linear-gradient(90deg, #1a5a1a, #2f9a3d); }
  .fill-blue { background: linear-gradient(90deg, #1a2a5a, #3b7cff); }
  .fill-red { background: linear-gradient(90deg, #5a1a1a, #e76e55); }
  .fill-gold { background: linear-gradient(90deg, #5a4a10, #f0c040); }

  /* Usage section */
  .usage-card {
    background: #0f0f1a;
    border: 1px solid #2a2a3f;
    padding: 8px;
    margin-bottom: 6px;
    border-radius: 2px;
  }
  .usage-card.warn { border-color: #d1a128; }
  .usage-card.alert { border-color: #c13c3c; }
  .usage-card.exhausted { border-color: #c13c3c; background: #1a0a0a; }
  .uc-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    font-size: 8px;
  }
  .uc-pill {
    font-size: 6px;
    padding: 1px 5px;
    border: 1px solid #2a2a3f;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .pill-ok { border-color: #2f9a3d; color: #bfe6c7; }
  .pill-warn { border-color: #d1a128; color: #f3e2a2; }
  .pill-alert { border-color: #c13c3c; color: #f5b3b3; }
  .pill-est { border-color: #666; color: #aaa; }
  .pill-exhausted { border-color: #c13c3c; color: #f5b3b3; background: #3a1010; }
  .uc-row {
    display: flex;
    justify-content: space-between;
    color: #999;
    font-size: 7px;
    margin-bottom: 3px;
  }
  .uc-bar {
    height: 5px;
    background: #1b1b2b;
    border: 1px solid #222;
    margin-top: 2px;
    overflow: hidden;
  }
  .uc-fill { height: 100%; }
  .uf-green { background: linear-gradient(90deg, #1a4a1a, #2f9a3d); }
  .uf-yellow { background: linear-gradient(90deg, #5a4a10, #d1a128); }
  .uf-red { background: linear-gradient(90deg, #5a1a1a, #e76e55); }
  .uc-note { color: #555; font-size: 6px; margin-top: 4px; }

  /* Quest Log feed */
  .ql-feed {
    max-height: 200px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #333 #111;
  }
  .ql-feed::-webkit-scrollbar { width: 4px; }
  .ql-feed::-webkit-scrollbar-track { background: #111; }
  .ql-feed::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
  .ql-entry {
    display: flex;
    align-items: flex-start;
    gap: 6px;
    padding: 4px 0;
    border-bottom: 1px solid #1a1a2e;
    font-size: 7px;
  }
  a.ql-entry {
    text-decoration: none;
    color: inherit;
    cursor: pointer;
    -webkit-tap-highlight-color: rgba(136, 170, 255, 0.3);
    touch-action: manipulation;
    min-height: 44px;
  }
  a.ql-entry:hover { background: rgba(136, 170, 255, 0.08); }
  a.ql-entry .ql-name { color: #88aaff; }
  a.ql-entry:hover .ql-name { color: #aaccff; text-decoration: underline; }
  .ql-entry:last-child { border-bottom: none; }
  .ql-icon { flex-shrink: 0; font-size: 9px; line-height: 1; }
  .ql-body { flex: 1; min-width: 0; }
  .ql-head { display: flex; align-items: baseline; gap: 4px; }
  .ql-name { color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .ql-status { white-space: nowrap; font-size: 6px; }
  .ql-time { flex-shrink: 0; color: #555; font-size: 6px; margin-left: auto; }
  .ql-title { color: #666; font-size: 6px; margin-top: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

  /* Queue */
  .queue-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    background: #0f0f1a;
    border: 1px dashed #2a2a3f;
    margin-bottom: 4px;
    font-size: 7px;
    color: #666;
  }
  .qi-num { color: #88aaff; }

  /* === SCENE AREA === */
  .scene-wrap {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .canvas-area {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: radial-gradient(ellipse at 50% 40%, #151530, #0c0c1a 70%);
    min-height: 0;
  }
  .canvas-area canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  .scanlines {
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0,0,0,0.03) 3px, rgba(0,0,0,0.03) 6px);
    pointer-events: none;
  }

  /* Mock tooltip */
  .mock-tooltip {
    position: absolute;
    top: 55%;
    right: 8%;
    padding: 8px 10px;
    font-size: 8px;
    line-height: 1.7;
    color: #e6e6e6;
    background: #15151fee;
    border: 3px solid #4a4a62;
    box-shadow: 0 0 0 3px #0b0b12, 4px 4px 0 #0b0b12;
    z-index: 10;
    min-width: 180px;
    display: none;
  }
  .tt-title { color: #f0c040; font-size: 9px; margin-bottom: 5px; display: flex; align-items: center; gap: 6px; }
  .tt-dot { width: 7px; height: 7px; border-radius: 50%; display: inline-block; }
  .tt-row { display: flex; gap: 6px; }
  .tt-lbl { color: #7b8096; min-width: 54px; }

  /* Canvas hover tooltip */
  #canvasTooltip {
    position: fixed;
    z-index: 50;
    display: none;
    max-width: 280px;
    padding: 8px 10px;
    font-size: 8px;
    line-height: 1.7;
    color: #e6e6e6;
    background: #1a1a2eee;
    border: 3px solid #f0c040;
    box-shadow: 0 0 0 3px #0b0b12, 4px 4px 0 #0b0b12;
    pointer-events: none;
    font-family: 'Press Start 2P', cursive;
  }

  /* === STATUS BAR === */
  .status-bar {
    background: linear-gradient(180deg, #1a1a30, #121228);
    border-top: 3px solid #2a2a4a;
    padding: 0 14px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 7px;
    color: #555;
  }
  .sb-log {
    color: #5dfc5d;
    text-shadow: 0 0 4px #5dfc5d22;
    overflow: hidden;
    white-space: nowrap;
    max-width: 60%;
  }

  /* No-data message */
  .no-data { color: #555; font-size: 7px; text-align: center; padding: 12px; }

  /* === SNES.CSS DARK THEME OVERRIDES === */
  .snes-container {
    background: #1a1a2e;
    padding: 8px 10px;
    margin-bottom: 0;
    position: relative;
    border-image-outset: 3px;
    border-width: 6px;
  }
  .snes-container::before {
    background-color: rgba(0,0,0,0.3);
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-container::after {
    background-color: rgba(100,100,160,0.25);
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-container > .snes-container-title {
    color: #f0c040;
    font-size: 9px;
    text-shadow: 0 0 8px #f0c04022;
    letter-spacing: 0;
    word-spacing: normal;
    margin-bottom: 8px;
  }
  .snes-container > .snes-container-title::after {
    background-color: #f0c040;
    height: 3px;
    bottom: -4px;
  }
  /* Custom badges (SNES.css has no badge component) */
  .snes-badge { white-space: nowrap; display: inline-block; }
  .snes-badge span {
    font-family: 'Press Start 2P', cursive;
    font-size: 6px;
    padding: 2px 6px;
    border: 2px solid;
    display: inline-block;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .snes-badge .is-success { border-color: #4bb244; color: #4bb244; background: rgba(75,178,68,0.15); }
  .snes-badge .is-primary { border-color: #4eb6d9; color: #4eb6d9; background: rgba(78,182,217,0.15); }
  .snes-badge .is-warning { border-color: #f2c019; color: #f2c019; background: rgba(242,192,25,0.15); }
  .snes-badge .is-error { border-color: #ff6f00; color: #ff6f00; background: rgba(255,111,0,0.15); }
  /* SNES-styled progress bars (RPG stat bars) */
  .snes-progress {
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    width: 100%;
    border: 2px solid #2a2a4a;
    background: #0f0f1a;
    display: block;
  }
  .snes-progress::-webkit-progress-bar { background: #0f0f1a; }
  .snes-progress::-webkit-progress-value { transition: width 0.3s ease; }
  .snes-progress.is-success::-webkit-progress-value { background: linear-gradient(90deg, #1a4a1a, #4bb244); }
  .snes-progress.is-primary::-webkit-progress-value { background: linear-gradient(90deg, #1a2a5a, #4eb6d9); }
  .snes-progress.is-warning::-webkit-progress-value { background: linear-gradient(90deg, #5a4a10, #f2c019); }
  .snes-progress.is-error::-webkit-progress-value { background: linear-gradient(90deg, #5a1a1a, #ff6f00); }
  .snes-progress::-moz-progress-bar { transition: width 0.3s ease; }
  .snes-progress.is-success::-moz-progress-bar { background: linear-gradient(90deg, #1a4a1a, #4bb244); }
  .snes-progress.is-primary::-moz-progress-bar { background: linear-gradient(90deg, #1a2a5a, #4eb6d9); }
  .snes-progress.is-warning::-moz-progress-bar { background: linear-gradient(90deg, #5a4a10, #f2c019); }
  .snes-progress.is-error::-moz-progress-bar { background: linear-gradient(90deg, #5a1a1a, #ff6f00); }
  /* SNES button overrides for compact dark UI */
  .snes-button {
    font-family: 'Press Start 2P', cursive;
    font-size: 8px;
    padding: 4px 10px;
    border-image-outset: 3px;
    border-width: 6px;
    line-height: 1;
    color: #fff;
  }
  .snes-button::before {
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-button::after {
    height: 9px;
    width: calc(100% + 9px);
  }
  /* SNES blockquote overrides for notification balloons */
  .snes-blockquote.notif-balloon {
    text-align: left;
    border-image-outset: 3px;
    border-width: 6px;
    padding: 8px 10px;
    margin-bottom: 0;
  }
  .snes-blockquote.notif-balloon::before {
    height: 9px;
    width: calc(100% + 9px);
  }
  .snes-blockquote.notif-balloon::after {
    height: 9px;
    width: calc(100% + 9px);
  }

  /* Mobile menu button ‚Äî hidden on desktop */
  .mobile-menu-btn { display: none; }

  /* Mobile overlay backdrop ‚Äî hidden by default */
  .mobile-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 49;
  }

  /* === MOBILE (<768px) === */
  @media (max-width: 767px) {
    body {
      overflow-y: auto;
      height: auto;
      min-height: 100vh;
    }

    .mobile-menu-btn { display: none; }
    .mobile-overlay { display: none !important; }

    /* Top bar: wrap stats to next line */
    .top-bar {
      flex-wrap: wrap;
      height: auto;
      padding: 6px 10px;
      gap: 4px;
    }
    .top-title { font-size: 11px; }
    .top-stats {
      order: 3;
      width: 100%;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px 14px;
      padding: 4px 0 2px;
      border-top: 1px solid #2a2a4a;
      margin-top: 2px;
    }

    /* Main layout: vertical stack */
    .main {
      flex-direction: column;
      height: auto;
      min-height: calc(100vh - 70px);
    }

    /* Canvas first on mobile, sidebar below */
    .scene-wrap { order: 1; }
    .sidebar {
      order: 2;
      position: static;
      width: 100%;
      max-width: none;
      min-width: 0;
      height: auto;
      z-index: auto;
      transform: none;
      transition: none;
      border-right: none;
      border-top: 2px solid #f0c040;
      overflow-y: visible;
      display: flex;
      flex-direction: column;
    }

    /* Sidebar section order: PARTY ‚Üí QUEST LOG ‚Üí INVENTORY */
    .sidebar > .sb-section:nth-child(2) { order: 3; } /* INVENTORY ‚Üí last */
    .sidebar > .sb-section:nth-child(3) { order: 2; } /* QUEST LOG ‚Üí middle */
    .sidebar > .sb-section:nth-child(4) { order: 1; } /* PARTY ‚Üí first */

    /* Hide desktop resize handle on mobile */
    .resize-handle { display: none; }

    /* Agent cards: larger touch targets */
    .agent-card {
      padding: 10px 12px !important;
      margin-bottom: 10px;
    }
    .ac-detail { font-size: 9px; line-height: 2.2; }

    /* SNES.css mobile overrides */
    .snes-container {
      padding: 8px 10px;
    }
    .snes-container > .snes-container-title {
      font-size: 8px;
    }
    .snes-badge span { font-size: 5px; }
    .snes-button { font-size: 7px; padding: 3px 6px; }
    .snes-progress { height: 6px; }

    /* Sidebar sections: more padding */
    .sb-section { padding: 10px 12px; }
    .sb-header { font-size: 10px; margin-bottom: 12px; }

    /* Scene area: responsive ‚Äî fill width, auto height from aspect ratio */
    .scene-wrap {
      flex: none;
      width: 100%;
      min-height: 200px;
    }
    .canvas-area {
      width: 100%;
      height: 0;
      padding-bottom: 60%; /* 768/1280 = 60% aspect ratio */
      position: relative;
      overflow: hidden;
    }
    .canvas-area canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Status bar: wrap text, fixed at bottom */
    .status-bar {
      flex-wrap: wrap;
      height: auto;
      padding: 6px 10px;
      gap: 4px;
      font-size: 6px;
    }
    .sb-log {
      max-width: 100%;
      white-space: normal;
      word-break: break-word;
    }

    /* Usage cards: slightly larger text */
    .usage-card { padding: 10px; }
    .uc-title { font-size: 9px; }
    .uc-row { font-size: 8px; }

    /* Quest Log feed: slightly larger on mobile */
    .ql-feed { max-height: 240px; }
    .ql-entry { font-size: 8px; gap: 8px; padding: 5px 0; min-height: 44px; }
    .ql-status { font-size: 7px; }
    .ql-time { font-size: 7px; }
    .ql-title { font-size: 7px; }

    /* Agent card tap-to-expand */
    .agent-card .ac-detail { max-height: 2.2em; overflow: hidden; transition: max-height 0.2s ease; }
    .agent-card.mobile-expanded .ac-detail { max-height: 20em; }
    .agent-card.mobile-expanded { border-color: #f0c040; }
  }

  /* === SMALL MOBILE (<480px) === */
  @media (max-width: 479px) {
    .top-title { font-size: 9px; }
    .top-title .ver { font-size: 6px; }
    .top-stats { font-size: 6px; gap: 6px 10px; }
    .snes-button { font-size: 6px; padding: 2px 4px; }

    .sb-header { font-size: 9px; }
    .agent-card { padding: 8px 10px !important; }
    .ac-detail { font-size: 8px; }

    .status-bar { font-size: 5px; }
  }
</style>
</head>
<body>

<!-- UI MODE REDIRECT -->
<script>
(function() {
  var pref = null;
  try { pref = localStorage.getItem('corral-ui-mode'); } catch(e) {}
  if (pref === 'classic') {
    window.location.replace('/');
    return;
  }
  // Set preference to sv if not already set
  try { localStorage.setItem('corral-ui-mode', 'sv'); } catch(e) {}
})();
</script>

<!-- TOP BAR -->
<div class="top-bar">
  <div class="top-title">
    <span style="font-size:16px">ü§†</span>
    <span>CORRAL</span>
    <span class="ver">sv</span>
  </div>
  <div class="top-stats" id="topStats">
    <span>AGENTS <span class="val" id="statAgents">0</span>/<span style="color:#555">12</span></span>
    <span>PRs <span class="val" id="statPRs">0</span></span>
    <span>MERGED <span class="val" id="statMerged">0</span></span>
    <span>DEAD <span class="val-bad" id="statDead">0</span></span>
    <span>UPTIME <span class="val" id="statUptime">0:00:00</span></span>
  </div>
  <div class="top-controls">
    <div class="conn-dot connecting" id="connDot" title="Connecting"></div>
    <button class="snes-button" id="soundToggleBtn" onclick="toggleSound()" title="Sound off (S)">üîá</button>
    <button class="snes-button has-ocean-color" id="toggleViewBtn" onclick="switchToClassic()" title="Switch to Classic view">üì∫ Classic</button>
    <button class="snes-button has-ember-color" id="cleanBtn" onclick="cleanAgents()">üßπ</button>
    <button class="snes-button mobile-menu-btn" id="mobileMenuBtn" onclick="toggleMobileSidebar()" title="Toggle sidebar">‚ò∞</button>
  </div>
</div>

<div class="main">

  <!-- Mobile overlay -->
  <div class="mobile-overlay" id="mobileOverlay" onclick="toggleMobileSidebar()"></div>

  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar">
    <div class="resize-handle" id="resizeHandle"></div>

    <!-- Usage / Inventory -->
    <div class="sb-section">
      <section class="snes-container">
        <p class="snes-container-title has-ember-underline">‚öîÔ∏è INVENTORY <span class="count" id="usageUpdated" style="font-size:7px;color:#666">‚Äî</span></p>
        <div id="usageCards">
          <div class="no-data">Loading usage data...</div>
        </div>
      </section>
    </div>

    <!-- Timeline / Quest Log -->
    <div class="sb-section">
      <section class="snes-container">
        <p class="snes-container-title has-sunshine-underline">üìú QUEST LOG <span class="count" id="timelineRange" style="font-size:7px;color:#666">‚Äî</span></p>

        <div id="timelineRows" class="ql-feed">
          <div class="no-data">No quests yet...</div>
        </div>
      </section>
    </div>

    <!-- Agents / Party -->
    <div class="sb-section">
      <section class="snes-container">
        <p class="snes-container-title has-nature-underline">‚ö° PARTY <span class="count" id="agentCount" style="font-size:7px;color:#666">‚Äî</span></p>
        <div id="notificationArea"></div>
        <div id="agentCards">
          <div class="no-data">Waiting for agent data...</div>
        </div>
      </section>
    </div>
  </div>

  <!-- SCENE -->
  <div class="scene-wrap">
    <div class="canvas-area">
      <canvas id="office" width="1280" height="768"></canvas>
      <div class="scanlines"></div>
    </div>
    <div class="status-bar" style="padding:0 14px;margin:0">
      <span class="sb-log" id="statusLog">‚ñ∏ Connecting to server...</span>
      <span>POLL 5s ‚îÇ <span id="agentCountBar">0</span> agents ‚îÇ <span id="clock"></span></span>
    </div>
  </div>
</div>

<div id="canvasTooltip" role="tooltip" aria-hidden="true"></div>

<script>
// ============================================================
// SV UI ‚Äî Live data integration
// ============================================================

// --- State ---
let agents = [];
let historyData = [];
let usageData = null;
let canvasUsage = { claude: null, codex: null };
let connectionState = 'connecting';
let polling = false;
const startTime = Date.now();

// --- Sound state ---
let soundEnabled = false;
let audioCtx = null;
const soundedNewAgent = new Set();
const soundedPrOpen = new Set();
const soundedCiFailed = new Set();
const soundedDead = new Set();
const soundedMerged = new Set();
const previousAgentsByKey = new Map();

// --- Walk animation state ---
let transitions = [];    // { key, deskIdx, path, progress, colorIdx, startTime }
let prevAgentKeys = new Set();
let hasInitialized = false;

// --- Notification balloon state ---
let prevAgentStates = new Map(); // agentId -> { state, prNumber, ciFailing }
const MAX_BALLOONS = 3;
const BALLOON_DURATION = 8000;

function showNotification(emoji, message, colorClass) {
  const area = document.getElementById('notificationArea');
  if (!area) return;

  // Enforce max 3 balloons ‚Äî remove oldest first
  while (area.children.length >= MAX_BALLOONS) {
    area.removeChild(area.firstChild);
  }

  const balloon = document.createElement('div');
  balloon.className = 'snes-blockquote has-phantom-bg notif-balloon';
  balloon.innerHTML = '<span class="' + colorClass + '">' + emoji + ' ' + escapeHtml(message) + '</span>';
  area.appendChild(balloon);

  setTimeout(() => {
    balloon.classList.add('fade-out');
    setTimeout(() => { if (balloon.parentNode) balloon.parentNode.removeChild(balloon); }, 500);
  }, BALLOON_DURATION);
}

function detectStateChanges() {
  if (!hasInitialized) return; // skip initial load
  const currentStates = new Map();

  agents.forEach(agent => {
    const id = agent.id || '';
    if (!id) return;
    const state = mapState(agent);
    const prNum = getPrNumber(agent);
    const ciFail = isCiFailing(agent);
    const repo = getRepoName(agent);
    const name = id.length > 16 ? id.slice(0, 16) + '..' : id;
    const repoLabel = repo ? repo + (prNum ? '#' + prNum : '') : name;

    currentStates.set(id, { state, prNumber: prNum, ciFailing: ciFail });

    const prev = prevAgentStates.get(id);
    if (!prev) {
      // New agent appeared (not on first load since hasInitialized check above)
      showNotification('\u{1F6B6}', 'New agent: ' + name, 'notif-text-green');
      return;
    }

    // Detect state transitions
    if (state === 'merged' && prev.state !== 'merged') {
      showNotification('\u2705', repoLabel + ' PR merged!', 'notif-text-gold');
    } else if (ciFail && !prev.ciFailing) {
      showNotification('\u274C', repoLabel + ' CI failed', 'notif-text-red');
    } else if (prNum && !prev.prNumber) {
      showNotification('\u{1F500}', repoLabel + ' PR opened', 'notif-text-blue');
    } else if ((state === 'dead' || state === 'exited') && prev.state !== 'dead' && prev.state !== 'exited') {
      showNotification('\u{1F480}', name + ' died', 'notif-text-gray');
    }
  });

  prevAgentStates = currentStates;
}

// --- Helpers ---
function escapeHtml(value) {
  return String(value ?? '').replace(/[&<>"']/g, c => {
    switch (c) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return c;
    }
  });
}

function getRepoName(agent) {
  if (!agent) return '';
  return (agent.repo || '').split('/').pop() || '';
}

function getIssueId(agent) {
  if (!agent) return '';
  return agent.issueId ?? agent.issue ?? agent.issueID ?? '';
}

function resolveAgentType(agent) {
  if (!agent) return '';
  return (agent.agentType || agent.agent || agent.type || '').toLowerCase();
}

function mapState(agent) {
  if (!agent) return 'idle';
  const status = (agent.status || '').toLowerCase();
  const activity = (agent.activity || '').toLowerCase();
  // Check explicit status FIRST, before endedAt
  if (status.includes('merged') || activity.includes('merged')) return 'merged';
  if (status.includes('pr_closed') || activity.includes('pr_closed')) return 'pr_closed';
  if (status.includes('exited') || activity.includes('exited') ||
      status.includes('archived') || activity.includes('archived')) return 'exited';
  if (status.includes('dead') || activity.includes('dead')) return 'dead';
  // endedAt as fallback for agents with no clear status
  if (agent.endedAt || agent.ended_at) return 'exited';
  if (status.includes('pr_review') || status.includes('changes_requested')) return 'reading';
  if (status.includes('pr_open') && agent.alive === false) return 'review_waiting';
  if (status.includes('pr_open') || status.includes('ci') || activity.includes('stale')) return 'waiting';
  if (status.includes('working') || activity.includes('active')) return 'coding';
  return 'idle';
}

function stateLabel(state) {
  switch(state) {
    case 'coding': return 'coding';
    case 'reading': return 'review';
    case 'review_waiting': return 'needs review';
    case 'waiting': return 'PR open';
    case 'merged': return 'merged ‚úì';
    case 'pr_closed': return 'PR closed';
    case 'exited': return 'exited';
    case 'dead': return 'dead';
    default: return 'idle';
  }
}

function isDoneState(state) {
  return state === 'dead' || state === 'merged' || state === 'exited' || state === 'pr_closed';
}

function stateToCardClass(state) {
  if (state === 'coding') return 'st-coding';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'st-pr';
  if (state === 'merged') return 'st-merged';
  if (state === 'exited' || state === 'dead') return 'st-dead';
  if (state === 'pr_closed') return 'st-closed';
  return '';
}

function stateToPulseClass(state) {
  if (state === 'coding') return 'green';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'blue';
  if (state === 'merged') return 'gold';
  if (state === 'exited' || state === 'dead') return 'gray';
  if (state === 'pr_closed') return 'purple';
  return 'gray';
}

function stateToColorClass(state) {
  if (state === 'coding') return 'v-green';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'v-blue';
  if (state === 'merged') return 'v-gold';
  if (state === 'exited' || state === 'dead') return 'v-gray';
  if (state === 'pr_closed') return 'v-purple';
  return 'v-gray';
}

function stateToFillClass(state) {
  if (state === 'coding') return 'fill-green';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'fill-blue';
  if (state === 'merged') return 'fill-gold';
  return '';
}

function stateToBadgeClass(state) {
  if (state === 'coding') return 'is-success';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'is-primary';
  if (state === 'merged') return 'is-warning';
  if (state === 'exited' || state === 'dead') return 'is-error';
  if (state === 'pr_closed') return 'is-error';
  return 'is-primary';
}

function stateToProgressClass(state) {
  if (state === 'coding') return 'is-success';
  if (state === 'waiting' || state === 'reading' || state === 'review_waiting') return 'is-primary';
  if (state === 'merged') return 'is-warning';
  return 'is-success';
}

function formatDuration(ms) {
  const totalMins = Math.max(0, Math.floor(ms / 60000));
  const hours = Math.floor(totalMins / 60);
  const mins = totalMins % 60;
  if (hours > 0) return hours + 'h ' + mins + 'm';
  return mins + 'm';
}

function getCreatedAt(agent) {
  const keys = ['createdAt','created_at','startedAt','started_at','startTime','start_time','spawnedAt','spawned_at'];
  for (const k of keys) { if (agent[k]) return new Date(agent[k]).getTime(); }
  return null;
}

function coffeeCount(agent) {
  const created = getCreatedAt(agent);
  if (!created) return 0;
  const hours = (Date.now() - created) / 3600000;
  if (hours < 0.5) return 0;
  if (hours < 1) return 1;
  if (hours < 2) return 2;
  return 3;
}

function getTokens(agent) {
  return agent.tokensUsed || agent.tokens_used || agent.tokens || 0;
}

function getPrNumber(agent) {
  return agent.prNumber || agent.pr_number || agent.pr || null;
}

function isCiFailing(agent) {
  const status = (agent.status || '').toLowerCase();
  return status.includes('ci_failed') || status.includes('failed');
}

// --- Connection indicator ---
function setConnection(state) {
  connectionState = state;
  const dot = document.getElementById('connDot');
  if (!dot) return;
  dot.className = 'conn-dot ' + state;
  dot.title = state === 'connected' ? 'Connected' : state === 'connecting' ? 'Connecting...' : 'Disconnected';
}

// --- View toggle ---
function switchToClassic() {
  try { localStorage.setItem('corral-ui-mode', 'classic'); } catch(e) {}
  window.location.href = '/';
}

// --- Clean button ---
async function cleanAgents() {
  const btn = document.getElementById('cleanBtn');
  if (btn) btn.disabled = true;
  try {
    await fetch('/api/clean', { method: 'POST' });
    await refreshFromLasso();
  } catch(e) {}
  if (btn) btn.disabled = false;
}

// --- Sound ---
function initAudio() {
  if (!audioCtx) {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = AC ? new AC() : null;
  }
}

function updateSoundButton() {
  const btn = document.getElementById('soundToggleBtn');
  if (!btn) return;
  btn.textContent = soundEnabled ? 'üîä' : 'üîá';
  btn.title = soundEnabled ? 'Sound on (S)' : 'Sound off (S)';
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  try { localStorage.setItem('corral-sound', soundEnabled ? '1' : '0'); } catch {}
  updateSoundButton();
  if (soundEnabled) {
    initAudio();
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    playConfirmation();
  }
}

function playTone(freq, endFreq, duration, type, vol, delay) {
  initAudio();
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime + (delay || 0);
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type || 'square';
  osc.frequency.setValueAtTime(freq, t);
  osc.frequency.exponentialRampToValueAtTime(endFreq, t + duration * 0.4);
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(vol || 0.08, t + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + duration + 0.01);
}

function playConfirmation() {
  playTone(660, 880, 0.15, 'square', 0.05);
}

// New agent arrives ‚Äî ascending chiptune arpeggio (~0.5s)
function playNewAgent() {
  if (!soundEnabled) return;
  playTone(523, 523, 0.12, 'square', 0.06, 0);
  playTone(659, 659, 0.12, 'square', 0.06, 0.12);
  playTone(784, 784, 0.12, 'square', 0.06, 0.24);
  playTone(1047, 1047, 0.12, 'square', 0.05, 0.36);
}

// PR opened ‚Äî 3 rising notes, Zelda item get (~0.8s)
function playPrCreated() {
  if (!soundEnabled) return;
  playTone(587, 587, 0.2, 'square', 0.06, 0);
  playTone(740, 740, 0.2, 'square', 0.06, 0.22);
  playTone(880, 880, 0.35, 'triangle', 0.07, 0.44);
}

// CI failed ‚Äî descending minor chord, warning (~0.5s)
function playCiFailed() {
  if (!soundEnabled) return;
  playTone(440, 330, 0.25, 'sawtooth', 0.05, 0);
  playTone(330, 220, 0.25, 'sawtooth', 0.05, 0.2);
}

// Agent died ‚Äî low rumble + descending tone (~1s)
function playAgentDied() {
  if (!soundEnabled) return;
  playTone(260, 100, 0.6, 'sine', 0.06, 0);
  playTone(180, 80, 0.5, 'sawtooth', 0.03, 0.3);
}

// PR merged ‚Äî victory fanfare, celebration arpeggio (~1.5s)
function playPrMerged() {
  if (!soundEnabled) return;
  playTone(523, 523, 0.15, 'square', 0.06, 0);
  playTone(659, 659, 0.15, 'square', 0.06, 0.15);
  playTone(784, 784, 0.15, 'square', 0.06, 0.30);
  playTone(1047, 1047, 0.3, 'square', 0.07, 0.45);
  playTone(880, 880, 0.15, 'triangle', 0.05, 0.80);
  playTone(1047, 1047, 0.5, 'triangle', 0.07, 0.95);
}

// --- Top stats bar ---
function updateTopStats() {
  const active = agents.filter(a => !isDoneState(mapState(a)));
  const prs = agents.filter(a => {
    const s = mapState(a);
    return s === 'waiting' || s === 'reading' || s === 'review_waiting';
  });
  const merged = agents.filter(a => mapState(a) === 'merged');
  const dead = agents.filter(a => {
    const s = mapState(a);
    return s === 'dead' || s === 'exited';
  });

  const el = (id, val) => { const e = document.getElementById(id); if (e) e.textContent = val; };
  el('statAgents', active.length);
  el('statPRs', prs.length);
  el('statMerged', merged.length);
  el('statDead', dead.length);
  el('agentCountBar', agents.length);

  // Uptime
  const upMs = Date.now() - startTime;
  const h = Math.floor(upMs / 3600000);
  const m = Math.floor((upMs % 3600000) / 60000);
  const s = Math.floor((upMs % 60000) / 1000);
  el('statUptime', h + ':' + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0'));
}

// --- Agent cards ---
function renderAgentCards() {
  const container = document.getElementById('agentCards');
  const countEl = document.getElementById('agentCount');
  if (!container) return;

  if (agents.length === 0) {
    container.innerHTML = '<div class="no-data">No agents connected</div>';
    if (countEl) countEl.textContent = '‚Äî';
    return;
  }

  const active = agents.filter(a => !isDoneState(mapState(a)));
  const terminal = agents.filter(a => isDoneState(mapState(a)));
  if (countEl) countEl.textContent = active.length + ' active' + (terminal.length ? ' ¬∑ ' + terminal.length + ' terminal' : '');

  container.innerHTML = agents.map(agent => {
    const state = mapState(agent);
    const cardClass = stateToCardClass(state);
    const colorClass = stateToColorClass(state);
    const badgeClass = stateToBadgeClass(state);
    const progressClass = stateToProgressClass(state);
    const name = escapeHtml(agent.id || 'agent');
    const repo = escapeHtml(getRepoName(agent));
    const issueId = getIssueId(agent);
    const issueTitle = escapeHtml(agent.issueTitle || '');
    const tokens = getTokens(agent);
    const tokensLabel = tokens > 1000 ? Math.round(tokens / 1000) + 'K' : tokens;
    const prNum = getPrNumber(agent);
    const created = getCreatedAt(agent);
    const elapsed = created ? formatDuration(Date.now() - created) : '‚Äî';
    const failing = isCiFailing(agent);
    const tokenPct = Math.min(100, Math.max(0, tokens / 2000));
    const agentType = resolveAgentType(agent);
    const typeIcon = agentType.includes('codex') ? 'ü™ô' :
                     agentType.includes('claude') ? '‚≠ê' : '';

    const titleLabel = repo && issueId ? repo + '#' + escapeHtml(String(issueId)) : (repo || name);

    let detailLine = '';
    if (issueTitle) detailLine += `<span style="color:#999">${issueTitle}</span><br>`;
    if (prNum) detailLine += `PR <span class="v-green">#${escapeHtml(String(prNum))}</span> ¬∑ `;
    if (failing) detailLine += `<span class="v-red">CI ‚úó</span> ¬∑ `;
    detailLine += `<span style="color:#666">${elapsed}</span>`;
    if (tokens) detailLine += ` ¬∑ ${tokensLabel} tok`;

    return `
      <section class="snes-container agent-card ${cardClass}" style="margin-bottom:8px;padding:6px 8px">
        <p class="snes-container-title" style="font-size:8px">${typeIcon} ${escapeHtml(titleLabel)}</p>
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px">
          <span class="snes-badge"><span class="${badgeClass}">${escapeHtml(stateLabel(state).toUpperCase())}</span></span>
        </div>
        <div class="ac-detail" style="margin-bottom:4px">${detailLine}</div>
        ${tokens ? `<progress class="snes-progress ${progressClass}" value="${Math.round(tokenPct)}" max="100" style="height:8px"></progress>` : ''}
      </section>
    `;
  }).join('');
}

// --- Canvas usage bars ---
function updateCanvasUsage() {
  canvasUsage = { claude: null, codex: null };
  if (!usageData || !Array.isArray(usageData.providers)) return;
  usageData.providers.forEach(provider => {
    const id = (provider.id || provider.name || '').toLowerCase();
    const isExhausted = provider.quotaStatus && provider.quotaStatus.exhausted;
    if (isExhausted) {
      const key = id.includes('codex') ? 'codex' : 'claude';
      canvasUsage[key] = { pct: 0, exhausted: true, name: provider.name || id };
      return;
    }
    if (provider.status === 'error' || provider.status === 'unavailable') {
      const key = id.includes('codex') ? 'codex' : 'claude';
      canvasUsage[key] = { pct: null, exhausted: false, error: true, name: provider.name || id };
      return;
    }
    const metrics = Array.isArray(provider.metrics) ? provider.metrics : [];
    const percents = metrics.map(m => {
      if (m.utilization !== null && m.utilization !== undefined) return Number(m.utilization) / 100;
      if (m.used == null || m.limit == null || m.limit === 0) return null;
      return Math.min(1, Math.max(0, m.used / m.limit));
    }).filter(p => p !== null);
    const highest = percents.length ? Math.max(...percents) : null;
    const remaining = highest !== null ? Math.round((1 - highest) * 100) : null;
    const key = id.includes('codex') ? 'codex' : 'claude';
    canvasUsage[key] = { pct: remaining, exhausted: false, name: provider.name || id };
  });
}

// --- Usage panel ---
function renderUsageCards() {
  updateCanvasUsage();
  const container = document.getElementById('usageCards');
  const updatedEl = document.getElementById('usageUpdated');
  if (!container) return;

  if (!usageData || (!Array.isArray(usageData.providers) && !Array.isArray(usageData.usage))) {
    container.innerHTML = '<div class="no-data">Usage unavailable</div>';
    if (updatedEl) updatedEl.textContent = '‚Äî';
    return;
  }

  const providers = Array.isArray(usageData.providers) ? usageData.providers : usageData.usage;
  if (!providers || providers.length === 0) {
    container.innerHTML = '<div class="no-data">' + escapeHtml(usageData.error || 'No usage data') + '</div>';
    return;
  }

  if (updatedEl && usageData.fetchedAt) {
    const d = new Date(usageData.fetchedAt);
    const ago = Math.round((Date.now() - d.getTime()) / 60000);
    updatedEl.textContent = ago <= 1 ? 'just now' : ago + 'm ago';
  }

  container.innerHTML = providers.map(provider => {
    const name = escapeHtml(provider.name || provider.id || 'Usage');
    const isExhausted = provider.quotaStatus && provider.quotaStatus.exhausted;

    if (isExhausted) {
      const resetLabel = provider.quotaStatus.resetAt
        ? 'Resets ' + new Date(provider.quotaStatus.resetAt).toLocaleString()
        : 'Reset time unknown';
      return `
        <div class="usage-card exhausted">
          <div class="uc-title"><span>${name}</span><span class="snes-badge"><span class="is-error">EXHAUSTED</span></span></div>
          <div class="uc-row" style="color:#f5b3b3">üíÄ HP: 0/100</div>
          <progress class="snes-progress is-error" value="100" max="100" style="height:8px"></progress>
          <div class="uc-note">${escapeHtml(resetLabel)}</div>
        </div>`;
    }

    const metrics = Array.isArray(provider.metrics) ? provider.metrics : [];
    const percents = metrics.map(m => {
      if (m.utilization !== null && m.utilization !== undefined) return Number(m.utilization) / 100;
      if (m.used == null || m.limit == null || m.limit === 0) return null;
      return Math.min(1, Math.max(0, m.used / m.limit));
    }).filter(p => p !== null);
    const highest = percents.length ? Math.max(...percents) : null;
    const level = highest === null ? 'unknown' : highest >= 0.95 ? 'alert' : highest >= 0.8 ? 'warn' : 'ok';
    const badgeClass = level === 'alert' ? 'is-error' : level === 'warn' ? 'is-warning' : 'is-success';
    const resetNote = provider.resetAt ? 'Resets ' + new Date(provider.resetAt).toLocaleString() : '';

    const metricsHtml = metrics.map(m => {
      const label = escapeHtml(m.label || m.id || 'Metric');
      let pct = null;
      if (m.utilization !== null && m.utilization !== undefined) pct = Number(m.utilization) / 100;
      else if (m.used != null && m.limit != null && m.limit > 0) pct = Math.min(1, m.used / m.limit);
      const fillWidth = pct === null ? 0 : Math.round(pct * 100);
      const progressClass = pct === null ? 'is-success' : pct >= 0.95 ? 'is-error' : pct >= 0.8 ? 'is-warning' : 'is-success';
      const remaining = pct !== null ? Math.max(0, Math.round((1 - pct) * 100)) : 100;
      const hearts = remaining >= 75 ? '‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è' : remaining >= 50 ? '‚ù§Ô∏è‚ù§Ô∏èüñ§' : remaining >= 25 ? '‚ù§Ô∏èüñ§üñ§' : 'üñ§üñ§üñ§';

      let valStr = '‚Äî';
      if (m.unit === '%' && m.limit === 100 && m.used != null) valStr = 'HP: ' + (100 - m.used) + '/100';
      else if (m.limit != null) valStr = 'HP: ' + (m.limit - (m.used || 0)) + '/' + m.limit + (m.unit ? ' ' + m.unit : '');
      else if (m.used != null) valStr = m.used + (m.unit ? ' ' + m.unit : '');

      return `
        <div class="uc-row"><span>${label}</span><span>${hearts} ${escapeHtml(valStr)}</span></div>
        <progress class="snes-progress ${progressClass}" value="${fillWidth}" max="100" style="height:8px"></progress>`;
    }).join('');

    return `
      <div class="usage-card" style="border:none;background:transparent">
        <div class="uc-title"><span>${name}</span><span class="snes-badge"><span class="${badgeClass}">${level.toUpperCase()}</span></span></div>
        ${metricsHtml || '<div class="uc-note">No metrics</div>'}
        ${resetNote ? '<div class="uc-note">' + escapeHtml(resetNote) + '</div>' : ''}
      </div>`;
  }).join('');
}

// --- Timeline (Quest Log event feed) ---
function questIcon(state) {
  switch (state) {
    case 'merged': return 'üéâ';
    case 'pr_closed': return 'üö´';
    case 'exited': case 'dead': return 'üíÄ';
    case 'waiting': return 'üîÄ';
    case 'review_waiting': return 'üîÄ';
    case 'reading': return 'üîÄ';
    case 'coding': return '‚òï';
    default: return '‚òï';
  }
}

function questStatusLabel(state) {
  switch (state) {
    case 'merged': return 'MERGED';
    case 'pr_closed': return 'CLOSED';
    case 'exited': return 'EXITED';
    case 'dead': return 'DEAD';
    case 'waiting': return 'PR OPEN';
    case 'review_waiting': return 'REVIEW';
    case 'reading': return 'REVIEW';
    case 'coding': return 'WORKING';
    default: return 'IDLE';
  }
}

function questTimeAgo(ms) {
  if (ms < 60000) return 'just now';
  const mins = Math.floor(ms / 60000);
  if (mins < 60) return mins + 'm ago';
  const hours = Math.floor(mins / 60);
  if (hours < 24) return hours + 'h ago';
  const days = Math.floor(hours / 24);
  return days + 'd ago';
}

function renderTimeline() {
  const container = document.getElementById('timelineRows');
  const rangeEl = document.getElementById('timelineRange');
  if (!container) return;

  const items = historyData.length ? historyData : agents;
  if (!items.length) {
    container.innerHTML = '<div class="no-data">No quests yet...</div>';
    return;
  }

  const now = Date.now();
  if (rangeEl) rangeEl.textContent = 'last 6h';

  // Build event list: extract most recent event time for each item
  const events = items.map(item => {
    const state = mapState(item);
    const statusHistory = item.statusHistory || [];
    // Most recent event time: last statusHistory entry, or lastUpdatedAt, or createdAt
    let eventTime = null;
    if (statusHistory.length) {
      const last = statusHistory[statusHistory.length - 1];
      if (last.at) eventTime = new Date(last.at).getTime();
    }
    if (!eventTime) {
      const updated = item.lastUpdatedAt || item.updatedAt || item.updated_at;
      if (updated) eventTime = new Date(updated).getTime();
    }
    if (!eventTime) eventTime = getCreatedAt(item) || now;

    const repoName = getRepoName(item);
    const issueId = getIssueId(item);
    const name = repoName && issueId ? repoName + '#' + issueId : (repoName || escapeHtml((item.id || '').substring(0, 12)));
    const title = item.issueTitle || item.issue_title || '';

    // Build link URL: PR if available, otherwise issue
    const prUrl = item.prUrl || '';
    const prNum = getPrNumber(item);
    let url = '';
    if (prUrl) url = prUrl;
    else if (repoName && prNum) url = 'https://github.com/' + repoName + '/pull/' + prNum;
    else if (repoName && issueId) url = 'https://github.com/' + repoName + '/issues/' + issueId;

    return { state, eventTime, name, title, item, url };
  });

  // Sort by most recent event first
  events.sort((a, b) => b.eventTime - a.eventTime);

  const rows = events.slice(0, 12).map(ev => {
    const icon = questIcon(ev.state);
    const label = questStatusLabel(ev.state);
    const color = timelineColor(ev.item.status || '');
    const timeAgo = questTimeAgo(now - ev.eventTime);
    const titleLine = ev.title
      ? `<div class="ql-title">${escapeHtml(ev.title)}</div>`
      : '';

    const tag = ev.url ? 'a' : 'div';
    const linkAttrs = ev.url ? ` href="${escapeHtml(ev.url)}" target="_blank" rel="noopener"` : '';

    return `<${tag}${linkAttrs} class="ql-entry">
      <span class="ql-icon">${icon}</span>
      <div class="ql-body">
        <div class="ql-head">
          <span class="ql-name">${escapeHtml(ev.name)}</span>
          <span class="ql-status" style="color:${color}">${label}</span>
          <span class="ql-time">${timeAgo}</span>
        </div>
        ${titleLine}
      </div>
    </${tag}>`;
  });

  container.innerHTML = rows.join('');
}

function timelineColor(status) {
  const s = (status || '').toLowerCase();
  if (s.includes('merged')) return '#f0c040';
  if (s.includes('pr_closed')) return '#8855aa';
  if (s.includes('exited') || s.includes('dead') || s.includes('archived')) return '#6c6c6c';
  if (s.includes('ci_failed') || s.includes('failed')) return '#ff5c5c';
  if (s.includes('pr_open') || s.includes('ci')) return '#3adf7a';
  if (s.includes('working') || s.includes('coding') || s.includes('active')) return '#3b7cff';
  return '#3b7cff';
}

// --- Status log ---
const logMessages = [];
function addLog(msg) {
  logMessages.push(msg);
  if (logMessages.length > 20) logMessages.shift();
  const el = document.getElementById('statusLog');
  if (el) el.textContent = msg;
}

// --- Data fetching ---
async function refreshFromLasso() {
  try {
    const [agentsResp, historyResp] = await Promise.all([
      fetch('/api/agents'),
      fetch('/api/history'),
    ]);
    if (!agentsResp.ok) throw new Error('Agents fetch failed');
    const data = await agentsResp.json();
    agents = Array.isArray(data) ? data : (data.sessions || []);
    detectStateChanges();
    detectNewAgents();
    detectSoundEvents();

    if (historyResp.ok) {
      const hData = await historyResp.json();
      historyData = Array.isArray(hData.history) ? hData.history : [];
    }

    setConnection('connected');
    updateAll();

    // Log latest agent activity
    if (agents.length) {
      const a = agents[0];
      addLog('‚ñ∏ ' + (a.id || 'agent') + ' ‚Äî ' + (a.status || 'active') + ' ‚Äî poll OK');
    } else {
      addLog('‚ñ∏ Poll OK ‚Äî no active agents');
    }
  } catch(err) {
    setConnection('disconnected');
    addLog('‚ñ∏ Connection failed ‚Äî ' + err.message);
  }
}

async function refreshUsage() {
  try {
    const resp = await fetch('/api/usage');
    if (!resp.ok) throw new Error('Usage fetch failed');
    usageData = await resp.json();
    renderUsageCards();
  } catch(err) {
    usageData = { error: err.message, providers: [] };
    renderUsageCards();
  }
}

function updateAll() {
  updateTopStats();
  renderAgentCards();
  renderTimeline();
}

async function startPolling() {
  if (polling) return;
  polling = true;
  setConnection('connecting');
  // Initial fetch
  await refreshFromLasso();
  await refreshUsage();
  // Poll loop
  while (polling) {
    await new Promise(r => setTimeout(r, 5000));
    await refreshFromLasso();
    // Usage less frequently
    if (Date.now() % 30000 < 6000) await refreshUsage();
  }
}

// --- Clock ---
setInterval(() => {
  const el = document.getElementById('clock');
  if (el) el.textContent = new Date().toLocaleTimeString('en-US', { hour12: false });
  updateTopStats(); // update uptime counter
}, 1000);

// ============================================================
// Canvas ‚Äî reuse mockup rendering (pixel art office)
// ============================================================
const canvas = document.getElementById('office');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const TILE = 16, SCALE = 4, S = TILE * SCALE;
const COLS = 20, ROWS = 12;
let frame = 0;

const PAL = {
  floor1: '#3d3550', floor2: '#352e48', floor3: '#302a42',
  floorCrack: '#2a2440',
  beam: '#6a5040', beamDark: '#5a4030', beamLight: '#7a6050', nail: '#999',
  wall: '#4a4a72', wallDark: '#3e3e64', wallLight: '#5a5a82', wallPanel: '#424268',
  desk: '#8b6914', deskTop: '#c49b2a', deskDark: '#6a5010',
  monitor: '#1a1a1a', monitorBezel: '#2a2a2a',
  chair: '#3a3a3a', chairDark: '#2a2a2a', chairLight: '#4a4a4a',
  plant: '#2d5a1e', plantLight: '#3a7a2a', plantPot: '#8b5e3c', plantPotDark: '#6a4a2a',
  cup: '#e0e0e0', cupDark: '#ccc', coffee: '#5a3a1a',
  fire1: '#ff0044', fire2: '#ff6600', fire3: '#ffaa00', fire4: '#ffee44',
  tombstone: '#6c6c6c', tombstoneLight: '#8b8b8b',
  divider: '#26263b',
  neonPink: '#ff2d7b', neonPinkGlow: 'rgba(255,45,123,0.12)',
  neonCyan: '#00e5ff', neonCyanGlow: 'rgba(0,229,255,0.08)',
  wb: '#d8d8c8', wbFrame: '#888',
  pizza: '#c49b2a', pizzaDark: '#8b6914',
  // SV environment upgrades
  svFloor1: '#4a4458', svFloor2: '#3a3648', svFloor3: '#524c62', svFloor4: '#44405a',
  svFloorWarm: 'rgba(255,200,100,0.03)',
  svBrick: '#6a3a2a', svBrickDark: '#5a2e20', svBrickMortar: '#4a3830',
  svConduit: '#555', svConduitLight: '#666',
  svFluor: '#c8e8ff', svFluorGlow: 'rgba(200,232,255,0.06)',
  svDeskFrame: '#606060', svDeskFrameLight: '#707070', svDeskFrameDark: '#505050',
  svDeskSurface: '#d4c8b0', svDeskSurfaceDark: '#b8aa90',
  svKeyboard: '#2a2a2a', svKeyboardKey: '#3a3a3a',
  svMouse: '#333', svCable: '#2a2a2a',
  svMonitor2: '#222', svMonitor2Bezel: '#2e2e2e',
  svLaptop: '#2a2a2a', svLaptopScreen: '#1a1a2e',
  svChairMesh: '#3a3a3a', svChairFrame: '#555', svChairWheel: '#444',
  svChairColors: ['#2e5a2e', '#2e2e5a', '#5a2e2e', '#5a5a2e', '#2e5a5a', '#5a2e5a'],
  svPizzaBox: '#b08030', svPizzaBoxDark: '#8a6020',
  svEnergy: '#40e060', svEnergyDark: '#30b048', svEnergyCan: '#ccc',
  svSticky: ['#ffee55', '#55eeff', '#ff88aa', '#88ff88'],
  svPoster: '#e8e0d0', svPosterText: '#222',
  svSkateDeck: '#8844aa', svSkateWheel: '#ddd', svSkateTruck: '#999',
  svCardboard: '#b09060', svCardboardDark: '#907040',
  svBeanBag: '#cc4466',  svBeanBagDark: '#aa3350',
  svFridge: '#ddd', svFridgeDark: '#bbb', svFridgeHandle: '#999',
};

const CHARS = [
  { skin: '#f5c6a0', skinD: '#d4a080', hair: '#4a2800', shirt: '#3fbf3f', shirtD: '#2a8a2a', pants: '#3050a0' },
  { skin: '#d4a373', skinD: '#b88855', hair: '#1a1a2e', shirt: '#3fbf3f', shirtD: '#2a8a2a', pants: '#2a2a4e' },
  { skin: '#f5deb3', skinD: '#d4bc90', hair: '#c04000', shirt: '#f08b2e', shirtD: '#c06a18', pants: '#404040' },
  { skin: '#c49b6a', skinD: '#a07a48', hair: '#222',    shirt: '#f08b2e', shirtD: '#c06a18', pants: '#3a3a5c' },
  { skin: '#f0d0b0', skinD: '#d0b090', hair: '#604020', shirt: '#3fbf3f', shirtD: '#2a8a2a', pants: '#333' },
  { skin: '#e8c090', skinD: '#c8a070', hair: '#802020', shirt: '#f08b2e', shirtD: '#c06a18', pants: '#2a2a4e' },
];

const CHARS_SV = [
  { skin: '#f5c6a0', skinH: '#ffe0c8', skinD: '#d4a080', hair: '#4a2800', hairH: '#6a4820', hairStyle: 0 },
  { skin: '#d4a373', skinH: '#e8b888', skinD: '#b88855', hair: '#1a1a2e', hairH: '#3a3a4e', hairStyle: 1 },
  { skin: '#f5deb3', skinH: '#fff0d0', skinD: '#d4bc90', hair: '#c04000', hairH: '#e06020', hairStyle: 2 },
  { skin: '#c49b6a', skinH: '#d8b080', skinD: '#a07a48', hair: '#222',    hairH: '#444',    hairStyle: 3 },
  { skin: '#f0d0b0', skinH: '#ffe8d0', skinD: '#d0b090', hair: '#604020', hairH: '#806040', hairStyle: 4 },
  { skin: '#e8c090', skinH: '#f8d8a8', skinD: '#c8a070', hair: '#802020', hairH: '#a04040', hairStyle: 5 },
];

const DESKS = [];
for (let r = 0; r < 3; r++)
  for (let c = 0; c < 4; c++)
    DESKS.push({ x: 2 + c * 5, y: 2 + r * 3 });

// --- Ambient particles (dust motes + neon sparkles) ---
const particles = [];
(function initParticles() {
  const W = COLS * TILE, H = ROWS * TILE;
  // Dust motes ‚Äî 12 small dots floating upward
  for (let i = 0; i < 12; i++) {
    particles.push({
      type: 'dust',
      x: Math.random() * W,
      y: Math.random() * H,
      vx: (Math.random() - 0.5) * 0.15,
      vy: -0.1 - Math.random() * 0.15,
      alpha: 0.15 + Math.random() * 0.15,
      size: 1 + (Math.random() > 0.7 ? 1 : 0),
    });
  }
  // Neon sparkles ‚Äî 4 slots near the HACK sign (nx=55, ny=10)
  for (let i = 0; i < 4; i++) {
    particles.push({
      type: 'sparkle',
      x: 55 + Math.random() * 38,
      y: 8 + Math.random() * 14,
      life: 0,
      maxLife: 40 + Math.random() * 40,
      alpha: 0,
      size: 1,
    });
  }
})();

// --- Walk animation ---
const DOOR_TILE = { x: 0, y: 2 };
const WALK_SPEED = 2; // tiles per second
const ENTER_STAGGER = 0.5; // seconds between multiple entering agents

function agentKey(agent, fallbackIndex) {
  if (!agent) return 'agent-' + fallbackIndex;
  const id = (agent.id || agent.label || agent.agentId || agent.name || '').toString().trim();
  return id || ('agent-' + fallbackIndex);
}

function buildPath(start, end) {
  const mid = { x: end.x, y: start.y };
  const seg1 = Math.abs(mid.x - start.x) + Math.abs(mid.y - start.y);
  const seg2 = Math.abs(end.x - mid.x) + Math.abs(end.y - mid.y);
  return { start: { ...start }, mid, end: { ...end }, seg1, seg2, total: seg1 + seg2 };
}

function positionAlongPath(path, dist) {
  if (path.total === 0) return { x: path.end.x, y: path.end.y };
  if (dist <= path.seg1) {
    const dx = path.mid.x - path.start.x;
    const dy = path.mid.y - path.start.y;
    return {
      x: path.start.x + (dx === 0 ? 0 : Math.sign(dx) * dist),
      y: path.start.y + (dy === 0 ? 0 : Math.sign(dy) * dist),
    };
  }
  const remaining = dist - path.seg1;
  const dx = path.end.x - path.mid.x;
  const dy = path.end.y - path.mid.y;
  return {
    x: path.mid.x + (dx === 0 ? 0 : Math.sign(dx) * remaining),
    y: path.mid.y + (dy === 0 ? 0 : Math.sign(dy) * remaining),
  };
}

function updateTransitions() {
  if (!transitions.length) return;
  const now = Date.now();
  const next = [];
  transitions.forEach(t => {
    if (t.path.total === 0) return;
    const elapsed = Math.max(0, now - t.startTime) / 1000;
    t.progress = Math.min(t.path.total, elapsed * WALK_SPEED);
    if (t.progress >= t.path.total) return;
    next.push(t);
  });
  transitions = next;
}

function detectNewAgents() {
  const currentKeys = new Set();
  agents.slice(0, 12).forEach((a, i) => currentKeys.add(agentKey(a, i)));

  if (hasInitialized) {
    let staggerIdx = 0;
    const now = Date.now();
    const existingTransitionKeys = new Set(transitions.map(t => t.key));
    agents.slice(0, 12).forEach((agent, idx) => {
      const key = agentKey(agent, idx);
      if (!prevAgentKeys.has(key) && !existingTransitionKeys.has(key)) {
        const desk = DESKS[idx];
        if (!desk) return;
        transitions.push({
          key,
          deskIdx: idx,
          path: buildPath(DOOR_TILE, { x: desk.x, y: desk.y }),
          progress: 0,
          colorIdx: idx % CHARS.length,
          startTime: now + staggerIdx * ENTER_STAGGER * 1000,
          agentType: resolveAgentType(agent),
        });
        staggerIdx++;
      }
    });
  }

  hasInitialized = true;
  prevAgentKeys = currentKeys;
}

function hasPrOpen(agent) {
  const s = mapState(agent);
  return s === 'waiting' || s === 'reading' || s === 'review_waiting';
}

function detectSoundEvents() {
  if (!hasInitialized || previousAgentsByKey.size === 0) {
    // First load ‚Äî store state but don't play sounds
    agents.slice(0, 12).forEach((a, i) => previousAgentsByKey.set(agentKey(a, i), a));
    return;
  }

  let soundToPlay = null;
  agents.slice(0, 12).forEach((agent, idx) => {
    const key = agentKey(agent, idx);
    const prev = previousAgentsByKey.get(key);

    // New agent arrived (no previous state for this key)
    if (!prev && !soundedNewAgent.has(key)) {
      soundedNewAgent.add(key);
      if (!soundToPlay) soundToPlay = 'new';
    }

    if (!prev) return;

    // PR merged
    if (!soundedMerged.has(key) && mapState(prev) !== 'merged' && mapState(agent) === 'merged') {
      soundedMerged.add(key);
      soundToPlay = 'merged'; // highest priority
    }

    // Agent died
    if (!soundedDead.has(key) && mapState(prev) !== 'dead' && mapState(agent) === 'dead') {
      soundedDead.add(key);
      if (!soundToPlay || soundToPlay === 'new') soundToPlay = 'dead';
    }

    // CI failed
    if (!soundedCiFailed.has(key) && !isCiFailing(prev) && isCiFailing(agent)) {
      soundedCiFailed.add(key);
      if (!soundToPlay || soundToPlay === 'pr' || soundToPlay === 'new') soundToPlay = 'ci';
    }

    // PR opened
    if (!soundedPrOpen.has(key) && !hasPrOpen(prev) && hasPrOpen(agent)) {
      soundedPrOpen.add(key);
      if (!soundToPlay || soundToPlay === 'new') soundToPlay = 'pr';
    }
  });

  if (soundToPlay === 'merged') playPrMerged();
  else if (soundToPlay === 'dead') playAgentDied();
  else if (soundToPlay === 'ci') playCiFailed();
  else if (soundToPlay === 'pr') playPrCreated();
  else if (soundToPlay === 'new') playNewAgent();

  // Store current state for next comparison
  previousAgentsByKey.clear();
  agents.slice(0, 12).forEach((a, i) => previousAgentsByKey.set(agentKey(a, i), a));
}

function R(x, y, w, h, color) { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); }
function tileRect(tx, ty, tw, th, color) { R(tx * S, ty * S, tw * S, th * S, color); }

// === DAY/NIGHT CYCLE ===
function getTimeOfDay() {
  const now = new Date();
  const h = now.getHours() + now.getMinutes() / 60;
  // nightFactor: 0 = full day, 1 = full night
  // Smooth sine-based transitions during dawn (6-8) and dusk (18-20)
  let nightFactor;
  if (h >= 8 && h < 18) {
    nightFactor = 0; // day
  } else if (h >= 20 || h < 6) {
    nightFactor = 1; // night
  } else if (h >= 6 && h < 8) {
    // dawn: 1 ‚Üí 0 over 2 hours
    nightFactor = 0.5 + 0.5 * Math.cos((h - 6) / 2 * Math.PI);
  } else {
    // dusk (18-20): 0 ‚Üí 1 over 2 hours
    nightFactor = 0.5 - 0.5 * Math.cos((h - 18) / 2 * Math.PI);
  }
  // warmFactor peaks during dawn/dusk
  let warmFactor = 0;
  if (h >= 6 && h < 8) warmFactor = Math.sin((h - 6) / 2 * Math.PI);
  else if (h >= 18 && h < 20) warmFactor = Math.sin((h - 18) / 2 * Math.PI);
  return { nightFactor, warmFactor, hour: h };
}

function drawDayNightOverlay() {
  const { nightFactor, warmFactor } = getTimeOfDay();
  if (nightFactor <= 0 && warmFactor <= 0) return;
  ctx.save();
  // Night blue overlay
  if (nightFactor > 0) {
    ctx.fillStyle = 'rgba(10,10,40,' + (0.3 * nightFactor).toFixed(3) + ')';
    ctx.fillRect(0, 0, COLS * TILE * SCALE, ROWS * TILE * SCALE);
  }
  // Dawn/dusk warm overlay
  if (warmFactor > 0) {
    ctx.fillStyle = 'rgba(255,160,50,' + (0.1 * warmFactor).toFixed(3) + ')';
    ctx.fillRect(0, 0, COLS * TILE * SCALE, ROWS * TILE * SCALE);
  }
  ctx.restore();
}

function drawFloor() {
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      const hash = ((c * 7 + r * 13) % 3);
      tileRect(c, r, 1, 1, hash === 0 ? PAL.floor1 : hash === 1 ? PAL.floor2 : PAL.floor3);
    }
  ctx.save(); ctx.scale(SCALE, SCALE);
  ctx.fillStyle = PAL.floorCrack;
  for (let i = 0; i < 15; i++) ctx.fillRect(40 + i * 2, 100 + Math.sin(i) * 2 | 0, 2, 1);
  for (let i = 0; i < 10; i++) ctx.fillRect(180 + i * 2, 150 + (i % 3 === 0 ? 1 : 0), 1, 1);
  ctx.fillStyle = '#2e2845';
  ctx.fillRect(90, 130, 4, 3);
  ctx.fillRect(200, 110, 3, 4);
  ctx.restore();
}

function drawWalls() {
  for (let c = 0; c < COLS; c++) tileRect(c, 0, 1, 1, PAL.wall);
  ctx.save(); ctx.scale(SCALE, SCALE);
  ctx.fillStyle = PAL.wallLight; ctx.fillRect(0, 0, COLS * TILE, 2);
  ctx.fillStyle = PAL.wallDark; ctx.fillRect(0, 2, COLS * TILE, 1);
  for (let x = 0; x < COLS * TILE; x += 40) { ctx.fillStyle = PAL.wallPanel; ctx.fillRect(x, 3, 1, TILE - 3); }
  ctx.fillStyle = '#3a3028'; ctx.fillRect(0, TILE - 2, COLS * TILE, 2);
  ctx.fillStyle = '#4a4038'; ctx.fillRect(0, TILE - 2, COLS * TILE, 1);
  ctx.restore();
}

function drawGarageFrame() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const W = COLS * TILE, H = ROWS * TILE;
  R(0, 0, W, 3, PAL.beam); R(0, 0, W, 1, PAL.beamLight); R(0, 2, W, 1, PAL.beamDark);
  R(0, 0, 3, H, PAL.beam); R(0, 0, 1, H, PAL.beamLight); R(2, 0, 1, H, PAL.beamDark);
  R(W - 3, 0, 3, H, PAL.beam); R(W - 3, 0, 1, H, PAL.beamLight);
  // Garage door ridges ‚Äî horizontal lines suggesting metal slats on side beams
  for (let gy = 8; gy < H - 4; gy += 12) {
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0, gy, 3, 1);
    ctx.fillRect(W - 3, gy, 3, 1);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, gy + 1, 3, 1);
    ctx.fillRect(W - 3, gy + 1, 3, 1);
  }
  [[6,1],[6,80],[6,160],[W-5,1],[W-5,80],[W-5,160]].forEach(([nx, ny]) => {
    ctx.fillStyle = PAL.nail; ctx.fillRect(nx, ny, 2, 2);
    ctx.fillStyle = '#777'; ctx.fillRect(nx, ny, 1, 1);
  });
  ctx.restore();
}

function drawWindow() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = 120, y = 4, w = 64, h = 24;
  const { nightFactor, warmFactor, hour } = getTimeOfDay();
  // Sky color: lerp between day blue and night dark
  const skyR = Math.round(10 + (1 - nightFactor) * 60 + warmFactor * 80);
  const skyG = Math.round(16 + (1 - nightFactor) * 80 + warmFactor * 40);
  const skyB = Math.round(41 + (1 - nightFactor) * 100);
  const skyColor = 'rgb(' + Math.min(skyR,255) + ',' + Math.min(skyG,255) + ',' + Math.min(skyB,255) + ')';
  R(x, y, w, h, skyColor);
  // Building silhouettes ‚Äî taller cityscape for larger window
  const bldR = Math.round(12 + (1 - nightFactor) * 30);
  const bldG = Math.round(21 + (1 - nightFactor) * 30);
  const bldB = Math.round(48 + (1 - nightFactor) * 30);
  const bldColor = 'rgb(' + bldR + ',' + bldG + ',' + bldB + ')';
  const buildings = [
    [x+2,y+14,6,10],[x+10,y+8,5,16],[x+17,y+16,5,8],
    [x+24,y+6,8,18],[x+34,y+10,6,14],[x+42,y+14,5,10],
    [x+48,y+7,6,17],[x+56,y+16,6,8]
  ];
  const windowChance = 0.3 + nightFactor * 0.4;
  buildings.forEach(([bx,by,bw,bh]) => {
    ctx.fillStyle = bldColor; ctx.fillRect(bx, by, bw, bh);
    for (let wx = bx + 1; wx < bx + bw - 1; wx += 2)
      for (let wy = by + 1; wy < by + bh - 1; wy += 2)
        if (Math.random() > (1 - windowChance)) {
          ctx.fillStyle = ['#f0d060','#5dfc5d','#00e5ff','#ff8844','#fff'][Math.floor(Math.random()*5)];
          ctx.fillRect(wx, wy, 1, 1);
        }
  });
  // Stars: only visible at night
  if (nightFactor > 0.3) {
    ctx.fillStyle = 'rgba(255,255,255,' + (nightFactor * 0.8).toFixed(2) + ')';
    [[x+5,y+1],[x+20,y+2],[x+45,y+1],[x+55,y+2],[x+35,y+1],[x+15,y+3],[x+60,y+2],[x+30,y+1],[x+8,y+3]].forEach(([sx,sy]) => ctx.fillRect(sx, sy, 1, 1));
  }
  // Moon/sun
  if (nightFactor > 0.3) {
    ctx.fillStyle = 'rgba(255,240,200,' + (nightFactor * 0.9).toFixed(2) + ')';
    ctx.fillRect(x+50, y+1, 4, 4);
    ctx.fillStyle = 'rgba(220,210,160,' + (nightFactor * 0.7).toFixed(2) + ')';
    ctx.fillRect(x+51, y+1, 2, 2);
  } else {
    ctx.fillStyle = '#ffe39a'; ctx.fillRect(x+50, y+2, 4, 4);
    ctx.fillStyle = '#d8d060'; ctx.fillRect(x+51, y+2, 2, 2);
  }
  // Window frame ‚Äî 4 panes
  ctx.fillStyle = '#5a5040';
  ctx.fillRect(x-1, y-1, w+2, 1); ctx.fillRect(x-1, y+h, w+2, 1);
  ctx.fillRect(x-1, y-1, 1, h+2); ctx.fillRect(x+w, y-1, 1, h+2);
  ctx.fillRect(x + w/2, y, 1, h); // vertical divider
  ctx.fillRect(x, y + Math.floor(h/2), w, 1); // horizontal divider
  // Window sill
  ctx.fillStyle = '#6a5a48';
  ctx.fillRect(x-2, y+h, w+4, 2);
  ctx.fillStyle = '#7a6a58';
  ctx.fillRect(x-2, y+h, w+4, 1);
  // Curtain edges
  ctx.fillStyle = '#4a3a50';
  ctx.fillRect(x, y, 3, h); ctx.fillRect(x+w-3, y, 3, h);
  ctx.fillStyle = '#3a2a40';
  ctx.fillRect(x+1, y, 1, h); ctx.fillRect(x+w-2, y, 1, h);
  ctx.restore();
}

function drawDoor() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = 4, y = 6;
  R(x, y, 14, 28, '#3a3028'); R(x+1, y+1, 12, 26, '#2a2218');
  R(x+2, y+2, 10, 10, '#2e2620'); R(x+2, y+14, 10, 12, '#2e2620');
  R(x+10, y+15, 2, 2, '#c49b2a'); R(x+10, y+15, 1, 1, '#dab84a');
  R(x-1, y-1, 16, 1, PAL.beam); R(x-1, y-1, 1, 30, PAL.beam); R(x+14, y-1, 1, 30, PAL.beam);
  ctx.restore();
}

function drawNeonSign() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const nx = 55, ny = 10;
  const { nightFactor } = getTimeOfDay();
  // Glow radius and intensity increase at night
  const glowMult = 1 + nightFactor * 1.5;
  const maxR = Math.round(8 * glowMult);
  for (let r = maxR; r > 0; r -= 2) R(nx-r, ny-r, 46+r*2, 10+r*2, 'rgba(255,45,123,' + (0.008 * glowMult * (maxR-r) / maxR * 8).toFixed(4) + ')');
  const H = [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[3,0],[3,1],[3,2],[3,3],[3,4],[3,5],[1,2],[2,2]];
  const A = [[6,0],[7,0],[5,1],[5,2],[5,3],[5,4],[5,5],[8,1],[8,2],[8,3],[8,4],[8,5],[6,3],[7,3]];
  const C = [[11,0],[12,0],[13,0],[10,1],[10,2],[10,3],[10,4],[11,5],[12,5],[13,5]];
  const K = [[15,0],[15,1],[15,2],[15,3],[15,4],[15,5],[18,0],[17,1],[16,2],[16,3],[17,4],[18,5]];
  [H, A, C, K].forEach(letter => { letter.forEach(([lx, ly]) => R(nx+lx*2, ny+ly, 2, 1, PAL.neonPink)); });
  R(nx, ny+7, 38, 1, PAL.neonCyan);
  for (let i = 0; i < 38; i += 3) R(nx+i, ny+7, 1, 1, '#005a6a');
  // Stronger underglow at night
  const underGlowAlpha = (0.12 + nightFactor * 0.15).toFixed(3);
  R(nx-4, ny+8, 46, 4, 'rgba(255,45,123,' + underGlowAlpha + ')');
  ctx.restore();
}

function drawWhiteboard() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = 218, y = 6, w = 44, h = 20;
  // Board body
  R(x, y, w, h, PAL.wb);
  R(x, y, w, 1, PAL.wbFrame); R(x, y+h-1, w, 1, PAL.wbFrame);
  R(x, y, 1, h, PAL.wbFrame); R(x+w-1, y, 1, h, PAL.wbFrame);
  // "DAYS WITHOUT INCIDENT: 0" header
  ctx.fillStyle = '#444'; ctx.font = '3px "Press Start 2P"';
  ctx.fillText('DAYS WITHOUT', x+3, y+5);
  ctx.fillText('INCIDENT:', x+3, y+9);
  ctx.fillStyle = '#e04040'; ctx.font = '6px "Press Start 2P"'; ctx.fillText('0', x+32, y+9);
  // Crossed-out "3"
  ctx.fillStyle = '#aaa'; ctx.font = '4px "Press Start 2P"'; ctx.fillText('3', x+28, y+5);
  R(x+27, y+3, 6, 1, '#e04040');
  // Sprint items
  ctx.fillStyle = '#666'; ctx.font = '2px "Press Start 2P"';
  ctx.fillText('TODO:', x+3, y+14);
  ctx.fillStyle = '#888';
  ctx.fillText('fix auth', x+14, y+14);
  ctx.fillText('deploy v2', x+3, y+17);
  // Checkbox marks
  R(x+2, y+12, 2, 2, '#40c040'); // checked
  R(x+2, y+15, 2, 2, '#ddd'); // unchecked
  // Marker tray
  R(x+8, y+h, 26, 1, '#666');
  R(x+9, y+h, 2, 1, '#e04040'); R(x+12, y+h, 2, 1, '#4040e0');
  R(x+15, y+h, 2, 1, '#40c040'); R(x+18, y+h, 2, 1, '#222');
  ctx.restore();
}

function drawDesk(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE + 8;
  R(x, y, TILE, 2, PAL.deskTop); R(x, y, TILE, 1, '#d4ab3a');
  for (let gx = x + 2; gx < x + TILE - 1; gx += 3) R(gx, y+1, 2, 1, PAL.desk);
  R(x, y+2, TILE, 4, PAL.desk); R(x, y+2, TILE, 1, PAL.deskDark);
  R(x+1, y+6, 2, 6, PAL.deskDark); R(x+TILE-3, y+6, 2, 6, PAL.deskDark);
  ctx.restore();
}

function drawChair(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = d.y * TILE + 10;
  R(x, y, 10, 2, PAL.chairLight); R(x+1, y, 8, 1, PAL.chair);
  R(x, y-6, 10, 2, PAL.chairLight); R(x+1, y-6, 8, 1, PAL.chair);
  R(x, y-4, 1, 4, PAL.chairDark); R(x+9, y-4, 1, 4, PAL.chairDark);
  R(x, y-2, 2, 1, PAL.chair); R(x+8, y-2, 2, 1, PAL.chair);
  R(x+4, y+2, 2, 3, PAL.chairDark); R(x+1, y+5, 8, 1, PAL.chair);
  R(x+1, y+6, 2, 1, '#555'); R(x+7, y+6, 2, 1, '#555');
  ctx.restore();
}

function drawMonitor(d, state, monitorText) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = d.y * TILE;
  R(x, y, 10, 7, PAL.monitorBezel); R(x+1, y, 8, 1, PAL.monitor);
  const sc = state === 'ci_failed' ? '#3a0808' : (state === 'coding' ? '#0a200a' : '#0a0a0a');
  R(x+1, y+1, 8, 5, sc);
  if (state === 'coding') {
    const colors = ['#4ae04a', '#2a8a2a', '#6af06a', '#3aaa3a'];
    for (let line = 0; line < 4; line++) {
      const indent = line === 2 ? 2 : 0;
      const len = 2 + (line * 3 + frame) % 4;
      R(x+2+indent, y+1+line, Math.min(len, 6-indent), 1, colors[line % colors.length]);
    }
    if (frame % 10 < 5) R(x+7, y+4, 1, 1, '#4ae04a');
  } else if (state === 'ci_failed') {
    const bright = Math.sin(frame * 0.1) > 0;
    const c = bright ? '#ff3b3b' : '#aa2222';
    R(x+2,y+1,1,1,c); R(x+6,y+1,1,1,c);
    R(x+3,y+2,1,1,c); R(x+5,y+2,1,1,c); R(x+4,y+3,1,1,c);
    R(x+3,y+4,1,1,c); R(x+5,y+4,1,1,c); R(x+2,y+5,1,1,c); R(x+6,y+5,1,1,c);
    R(x+2, y+1, 6, 1, '#3a0808');
    R(x+2, y+2, 1, 1, '#aa2222'); R(x+3, y+2, 2, 1, '#ff3b3b');
  } else if (state === 'merged') {
    R(x+4,y+1,2,1,'#f0c040'); R(x+3,y+2,4,1,'#f0c040');
    R(x+2,y+3,6,1,'#d8a820'); R(x+3,y+4,4,1,'#f0c040');
  } else {
    R(x+3,y+3,1,1,'#4ae04a'); R(x+4,y+4,1,1,'#4ae04a');
    R(x+5,y+3,1,1,'#4ae04a'); R(x+6,y+2,1,1,'#4ae04a'); R(x+7,y+1,1,1,'#2a8a2a');
  }
  // Scrolling issue title text on monitor screen
  if (monitorText) {
    ctx.restore(); // exit SCALE transform for text rendering
    const sx = (x + 1) * SCALE, sy = (y + 1) * SCALE, sw = 8 * SCALE, sh = 5 * SCALE;
    ctx.save();
    ctx.beginPath(); ctx.rect(sx, sy, sw, sh); ctx.clip();
    ctx.fillStyle = state === 'ci_failed' ? '#ff6666' : (state === 'coding' ? '#4ae04a' : '#8888ff');
    ctx.font = '10px "Press Start 2P", monospace';
    ctx.textBaseline = 'middle';
    const textWidth = ctx.measureText(monitorText).width;
    const totalScroll = textWidth + sw + 8;
    const scroll = (frame * 0.6) % totalScroll;
    ctx.fillText(monitorText, sx + sw - scroll, sy + sh / 2);
    ctx.restore();
    ctx.save(); ctx.scale(SCALE, SCALE); // re-enter SCALE for remaining drawing
  }
  R(x+3, y+7, 4, 1, '#333'); R(x+2, y+8, 6, 1, '#2a2a2a');
  if (state === 'coding' || state === 'ci_failed') {
    R(x-1, y+7, 12, 3, state === 'ci_failed' ? 'rgba(255,59,59,0.05)' : 'rgba(74,224,74,0.05)');
  }
  ctx.restore();
}

function drawCharacter(d, colorIdx, state) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const c = CHARS[colorIdx % CHARS.length];
  const x = d.x * TILE, y = (d.y + 1) * TILE;
  const sleeping = state === 'sleeping';
  const sitting = ['coding','reading','waiting','merged','exited','pr_closed','sleeping'].includes(state);
  const celeb = state === 'merged';
  const slumped = state === 'exited' || sleeping;
  const walk = state === 'walking';
  const bob = sitting ? 0 : (Math.sin(frame * 0.15) > 0 ? 0 : 1);
  const oy = sitting ? (celeb ? -3 : slumped ? -1 : -2) : bob;

  if (!sitting) { ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(x+3, y+14+bob, 10, 2); }
  ctx.fillStyle = c.pants;
  if (sitting) R(x+4, y+11+oy, 8, 2, c.pants);
  else {
    const lo = walk ? (Math.sin(frame*0.3) > 0 ? 1 : -1) : 0;
    R(x+5, y+11+oy, 2, 4, c.pants); R(x+9, y+11+oy+lo, 2, 4, c.pants);
    R(x+4, y+15+oy, 3, 1, '#222'); R(x+9, y+15+oy+lo, 3, 1, '#222');
  }
  R(x+4, y+6+oy, 8, 5, c.shirt); R(x+4, y+6+oy, 8, 1, c.shirtD); R(x+4, y+10+oy, 8, 1, c.shirtD);
  R(x+7, y+7+oy, 1, 3, c.shirtD);
  R(x+5, y+1+oy, 6, 5, c.skin); R(x+5, y+5+oy, 6, 1, c.skinD);
  R(x+4, y+3+oy, 1, 2, c.skinD); R(x+11, y+3+oy, 1, 2, c.skinD);
  R(x+5, y+oy, 6, 2, c.hair); R(x+4, y+oy+1, 1, 1, c.hair); R(x+11, y+oy+1, 1, 1, c.hair);
  R(x+4, y+3+oy, 1, 3, c.shirt); R(x+11, y+3+oy, 1, 3, c.shirt);

  if (state === 'coding') {
    R(x+3, y+2+oy, 1, 3, '#333'); R(x+12, y+2+oy, 1, 3, '#333');
    R(x+3, y+3+oy, 1, 2, '#555'); R(x+12, y+3+oy, 1, 2, '#555');
    R(x+4, y+oy, 8, 1, '#444');
  }

  if (sleeping) {
    const zf = frame % 90;
    ctx.fillStyle = '#aaddff'; ctx.font = '3px "Press Start 2P"';
    if (zf < 30) ctx.fillText('z', x+13, y+oy);
    else if (zf < 60) ctx.fillText('zZ', x+12, y+oy-2);
    else ctx.fillText('zZz', x+11, y+oy-4);
  }

  if (state === 'coding') {
    const ab = frame % 6 < 3 ? 0 : 1;
    R(x+2, y+7+oy, 2, 3, c.shirt); R(x+12, y+7+oy+ab, 2, 3, c.shirt);
    R(x+2, y+10+oy, 2, 1, c.skin); R(x+12, y+10+oy+ab, 2, 1, c.skin);
  } else if (celeb) {
    R(x+2, y+1+oy, 2, 4, c.shirt); R(x+12, y+1+oy, 2, 4, c.shirt);
    R(x+2, y+oy, 2, 1, c.skin); R(x+12, y+oy, 2, 1, c.skin);
  } else if (slumped) {
    R(x+2, y+8+oy, 2, 4, c.shirt); R(x+12, y+8+oy, 2, 4, c.shirt);
  } else {
    R(x+2, y+6+oy, 2, 4, c.shirt); R(x+12, y+6+oy, 2, 4, c.shirt);
  }

  const blink = frame % 60 < 3;
  if (slumped) { R(x+6, y+4+oy, 2, 1, '#222'); R(x+9, y+4+oy, 2, 1, '#222'); }
  else if (!blink) {
    R(x+6, y+3+oy, 2, 2, '#fff'); R(x+9, y+3+oy, 2, 2, '#fff');
    const px = state === 'coding' ? 0 : (Math.sin(frame*0.02) > 0 ? 0 : 1);
    R(x+6+px, y+3+oy, 1, 1, '#111'); R(x+9+px, y+3+oy, 1, 1, '#111');
    R(x+6, y+3+oy, 1, 1, '#ddf'); R(x+9, y+3+oy, 1, 1, '#ddf');
  }
  ctx.restore();
}

function drawCharacterSV(d, colorIdx, state, agentType) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const ch = CHARS_SV[colorIdx % CHARS_SV.length];
  const x = d.x * TILE;
  const y = (d.y + 1) * TILE;
  const isCodex = (agentType || '').includes('codex');
  // Hoodie palette by agent type (orange=Claude, green=Codex)
  const hM = isCodex ? '#3fbf3f' : '#e87030';
  const hL = isCodex ? '#5fdf5f' : '#ff9050';
  const hD = isCodex ? '#2a8a2a' : '#c05020';
  const hX = isCodex ? '#1e6e1e' : '#a03818';
  const f = Math.floor(frame / 8) % 4;
  const sleeping = state === 'sleeping';
  const sitting = ['coding','reading','waiting','merged','exited','pr_closed','sleeping'].includes(state);
  const celeb = state === 'merged';
  const slumped = state === 'exited' || sleeping;
  const walk = state === 'walking';
  const coding = state === 'coding';
  const bob = sitting ? 0 : [0, -1, 0, -1][f];
  const oy = sitting ? (celeb ? -6 : slumped ? -2 : -4) : bob;
  // Shadow for standing/walking
  if (!sitting) { ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(x+2, y+19, 12, 2); }
  // --- LEGS ---
  if (sitting) {
    R(x+4, y+13+oy, 3, 2, '#3050a0'); R(x+9, y+13+oy, 3, 2, '#3050a0');
    R(x+4, y+14+oy, 3, 1, '#283e80'); R(x+9, y+14+oy, 3, 1, '#283e80');
  } else if (walk) {
    const wc = [[0,0,0,0],[-1,-1,1,0],[0,0,0,0],[1,0,-1,-1]][f];
    R(x+4+wc[0], y+14+oy, 3, 4, '#3050a0'); R(x+4+wc[0], y+14+oy, 3, 1, '#283e80');
    R(x+9+wc[2], y+14+oy, 3, 4, '#3050a0'); R(x+9+wc[2], y+14+oy, 3, 1, '#283e80');
    R(x+3+wc[0], y+18+oy+wc[1], 5, 1, '#333'); R(x+8+wc[2], y+18+oy+wc[3], 5, 1, '#333');
  } else {
    R(x+4, y+14+oy, 3, 4, '#3050a0'); R(x+4, y+14+oy, 3, 1, '#283e80');
    R(x+9, y+14+oy, 3, 4, '#3050a0'); R(x+9, y+14+oy, 3, 1, '#283e80');
    R(x+3, y+18+oy, 5, 1, '#333'); R(x+8, y+18+oy, 5, 1, '#333');
  }
  // --- TORSO (Hoodie) ---
  R(x+3, y+7+oy, 10, 6, hM);
  R(x+3, y+7+oy, 10, 1, hL);
  R(x+3, y+12+oy, 10, 1, hD);
  R(x+4, y+8+oy, 1, 4, hL);
  R(x+12, y+8+oy, 1, 4, hD);
  R(x+5, y+7+oy, 6, 1, hD);
  R(x+7, y+8+oy, 1, 4, hD); R(x+8, y+8+oy, 1, 4, hX);
  R(x+6, y+8+oy, 1, 2, hX); R(x+9, y+8+oy, 1, 2, hX);
  if (isCodex) { R(x+10, y+9+oy, 2, 2, '#f0c040'); R(x+10, y+9+oy, 1, 1, '#d4a020'); }
  else { R(x+10, y+9+oy, 1, 1, '#f0c040'); R(x+9, y+10+oy, 3, 1, '#f0c040'); R(x+10, y+11+oy, 1, 1, '#f0c040'); }
  // --- HEAD (with lean-in bob for coding) ---
  const hob = coding ? (Math.floor(frame / 24) % 4 === 1 ? 1 : 0) : 0;
  const hy = oy + hob;
  R(x+4, y+2+hy, 8, 5, ch.skin);
  R(x+4, y+2+hy, 8, 1, ch.skinH);
  R(x+4, y+6+hy, 8, 1, ch.skinD);
  R(x+3, y+3+hy, 1, 2, ch.skin); R(x+3, y+3+hy, 1, 1, ch.skinH);
  R(x+12, y+3+hy, 1, 2, ch.skinD);
  // --- EYES (2px tall) ---
  const blink = frame % 80 < 3;
  if (slumped) {
    R(x+5, y+4+hy, 2, 1, '#222'); R(x+9, y+4+hy, 2, 1, '#222');
  } else if (!blink) {
    R(x+5, y+3+hy, 2, 2, '#fff'); R(x+9, y+3+hy, 2, 2, '#fff');
    // Coding: eyes glance between monitor areas; others: slow drift
    const px = coding ? (Math.floor(frame / 30) % 3 === 2 ? 1 : 0) : (Math.sin(frame * 0.02) > 0 ? 0 : 1);
    R(x+5+px, y+3+hy, 1, 2, '#111'); R(x+9+px, y+3+hy, 1, 2, '#111');
    R(x+5, y+3+hy, 1, 1, '#ddf'); R(x+9, y+3+hy, 1, 1, '#ddf');
    if (celeb) { R(x+5, y+2+hy, 2, 1, ch.hair); R(x+9, y+2+hy, 2, 1, ch.hair); }
  }
  if (celeb) R(x+7, y+5+hy, 2, 1, '#c06060');
  else if (slumped) R(x+7, y+5+hy, 2, 1, '#888');
  else if (coding) R(x+7, y+5+hy, 1, 1, ch.skinD);
  // --- HAIR (per hairStyle) ---
  const hs = ch.hairStyle;
  R(x+4, y+1+hy, 8, 2, ch.hair); R(x+4, y+1+hy, 8, 1, ch.hairH);
  R(x+3, y+2+hy, 1, 1, ch.hair); R(x+12, y+2+hy, 1, 1, ch.hair);
  if (hs === 0) {
    R(x+5, y+hy, 2, 1, ch.hair); R(x+8, y+hy, 2, 1, ch.hair);
    R(x+6, y+hy-1, 1, 1, ch.hairH); R(x+9, y+hy-1, 1, 1, ch.hairH); R(x+11, y+hy, 1, 1, ch.hair);
  } else if (hs === 1) {
    R(x+12, y+1+hy, 2, 1, ch.hair); R(x+13, y+2+hy, 2, 2, ch.hair); R(x+13, y+2+hy, 1, 1, ch.hairH);
  } else if (hs === 2) {
    R(x+3, y+hy, 10, 2, '#cc3333'); R(x+3, y+hy, 10, 1, '#ee5555'); R(x+2, y+1+hy, 12, 1, '#aa2222');
  } else if (hs === 3) {
    R(x+3, y+hy, 10, 2, ch.hair);
    R(x+2, y+2+hy, 2, 3, '#555'); R(x+2, y+2+hy, 2, 1, '#777');
    R(x+12, y+2+hy, 2, 3, '#555'); R(x+12, y+2+hy, 2, 1, '#777');
    R(x+3, y+hy, 10, 1, '#666');
  } else if (hs === 4) {
    R(x+4, y+hy, 8, 1, '#4a4a8a'); R(x+3, y+1+hy, 10, 1, '#3a3a7a');
    R(x+5, y+hy-1, 6, 1, '#5a5a9a'); R(x+7, y+hy-2, 2, 1, '#4a4a8a');
  } else {
    R(x+4, y+hy, 8, 2, ch.hair); R(x+4, y+hy, 8, 1, ch.hairH);
  }
  // --- ARMS ---
  if (coding) {
    const ab = f % 2;
    // Left arm + hand (bounces on even frames)
    R(x+1, y+8+oy, 2, 4, hM); R(x+1, y+8+oy, 2, 1, hL); R(x+1, y+12+oy+(1-ab), 2, 1, ch.skin);
    // Right arm + hand (bounces on odd frames)
    R(x+13, y+8+oy, 2, 4, hM); R(x+13, y+8+oy, 2, 1, hL); R(x+13, y+12+oy+ab, 2, 1, ch.skin);
  } else if (celeb) {
    R(x+1, y+2+oy, 2, 5, hM); R(x+1, y+2+oy, 2, 1, hL); R(x+1, y+1+oy, 2, 1, ch.skin);
    R(x+13, y+2+oy, 2, 5, hM); R(x+13, y+2+oy, 2, 1, hL); R(x+13, y+1+oy, 2, 1, ch.skin);
  } else if (slumped) {
    R(x+1, y+8+oy, 2, 6, hM); R(x+13, y+8+oy, 2, 6, hM);
  } else if (walk) {
    const as = [1, 0, -1, 0][f];
    R(x+1, y+8+oy, 2, 4+as, hM); R(x+1, y+8+oy, 2, 1, hL); R(x+1, y+12+oy+as, 2, 1, ch.skin);
    R(x+13, y+8+oy, 2, 4-as, hM); R(x+13, y+8+oy, 2, 1, hL); R(x+13, y+12+oy-as, 2, 1, ch.skin);
  } else if (state === 'reading' || state === 'waiting') {
    R(x+1, y+8+oy, 2, 4, hM); R(x+1, y+8+oy, 2, 1, hL);
    R(x+13, y+7+oy, 2, 2, hM); R(x+13, y+5+oy, 2, 2, hM); R(x+12, y+5+oy, 1, 1, ch.skin);
  } else {
    R(x+1, y+8+oy, 2, 4, hM); R(x+1, y+8+oy, 2, 1, hL);
    R(x+13, y+8+oy, 2, 4, hM); R(x+13, y+8+oy, 2, 1, hL);
  }
  // Coding headset
  if (coding && hs !== 3) {
    R(x+3, y+2+hy, 1, 3, '#555'); R(x+3, y+2+hy, 1, 1, '#777');
    R(x+12, y+2+hy, 1, 3, '#555'); R(x+12, y+2+hy, 1, 1, '#777');
    R(x+4, y+hy, 8, 1, '#444');
  }
  // Sleeping ZZZ
  if (sleeping) {
    const zf = frame % 90;
    ctx.fillStyle = '#aaddff'; ctx.font = '3px "Press Start 2P"';
    if (zf < 30) ctx.fillText('z', x+14, y+oy+2);
    else if (zf < 60) ctx.fillText('zZ', x+13, y+oy);
    else ctx.fillText('zZz', x+12, y+oy-2);
  }
  ctx.restore();
}

function drawKeyboardGlowSV(d, idx) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE + 8;
  const isStanding = idx % 3 === 0;
  const ky = isStanding ? y - 1 : y + 1;
  // RGB glow cycling slowly under keyboard area
  const rgbPhase = frame * 0.02;
  for (let i = 0; i < 3; i++) {
    const hue = (rgbPhase + i * 2.1) % (Math.PI * 2);
    const r = Math.floor(128 + 60 * Math.sin(hue));
    const g = Math.floor(128 + 60 * Math.sin(hue + 2.09));
    const b = Math.floor(128 + 60 * Math.sin(hue + 4.19));
    R(x + 3 + i * 3, ky + 3, 2, 1, 'rgba(' + r + ',' + g + ',' + b + ',0.25)');
  }
  ctx.restore();
}

function drawThoughtBubbleSV(d, deskIdx) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 4, y = (d.y + 1) * TILE - 12;
  const symbols = ['...', '</>', '{ }'];
  const cycleLen = 200; // frames per symbol
  const totalCycle = cycleLen * symbols.length;
  const t = (frame + deskIdx * 67) % totalCycle;
  const symIdx = Math.floor(t / cycleLen);
  const symT = t % cycleLen;
  // Fade in first 30 frames, hold, fade out last 30 frames
  let alpha;
  if (symT < 30) alpha = symT / 30;
  else if (symT > cycleLen - 30) alpha = (cycleLen - symT) / 30;
  else alpha = 1;
  if (alpha > 0.05) {
    // Small floating dots leading to bubble
    ctx.fillStyle = 'rgba(170,200,255,' + (alpha * 0.4).toFixed(2) + ')';
    R(x + 10, y + 6, 1, 1, ctx.fillStyle);
    R(x + 11, y + 4, 1, 1, ctx.fillStyle);
    // Bubble background
    const sym = symbols[symIdx];
    const bw = sym.length * 4 + 4;
    R(x + 8, y - 1, bw, 7, 'rgba(20,20,40,' + (alpha * 0.7).toFixed(2) + ')');
    // Text
    ctx.fillStyle = 'rgba(170,200,255,' + alpha.toFixed(2) + ')';
    ctx.font = '3px "Press Start 2P"';
    ctx.fillText(sym, x + 10, y + 4);
  }
  ctx.restore();
}

function drawFire(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE - 6;
  [[PAL.fire1,'#cc0033',4,4,4],[PAL.fire2,'#dd5500',5,2,6],[PAL.fire3,PAL.fire4,4,0,4]].forEach(([c1,c2,cnt,yOff,h]) => {
    for (let i = 0; i < cnt; i++) {
      ctx.fillStyle = Math.random() > 0.5 ? c1 : c2;
      ctx.fillRect(x + 2 + Math.floor(Math.random() * 12), y + yOff + Math.floor(Math.random() * h), 2, 2);
    }
  });
  for (let i = 0; i < 4; i++) {
    const age = (frame * 2 + i * 37) % 60;
    if (age < 30) {
      ctx.fillStyle = `rgba(255,136,0,${0.6 - age/50})`;
      ctx.fillRect(x + 4 + Math.sin(age * 0.3 + i) * 4, y - age / 4, 1, 1);
    }
  }
  R(x-2, y+8, TILE+4, 4, 'rgba(255,68,0,0.04)');
  ctx.restore();
}

function drawTombstone(d) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = (d.y + 1) * TILE + 2;
  R(x+1, y+11, 10, 1, 'rgba(0,0,0,0.2)');
  R(x+2, y, 8, 10, PAL.tombstone); R(x+3, y-1, 6, 1, PAL.tombstone);
  R(x+4, y-2, 4, 1, PAL.tombstoneLight); R(x+3, y, 6, 1, PAL.tombstoneLight);
  R(x+2, y+9, 8, 1, '#555');
  R(x+5, y+1, 2, 1, '#888'); R(x+4, y+2, 4, 1, '#888'); R(x+5, y+3, 2, 3, '#888');
  ctx.fillStyle = '#e0dfd8'; ctx.font = '4px "Press Start 2P"'; ctx.fillText('RIP', x+3, y+9);
  ctx.restore();
}

function drawBubble(d, text, color) {
  const px = d.x * S, py = (d.y * TILE - 10) * SCALE;
  R(px - 2, py - 26, text.length * 11 + 24, 26, 'rgba(0,0,0,0.8)');
  R(px + S/2 - 4, py, 8, 6, 'rgba(0,0,0,0.8)');
  ctx.fillStyle = color || '#fff'; ctx.font = '16px "Press Start 2P"';
  ctx.textAlign = 'center'; ctx.fillText(text, px + S/2, py - 6); ctx.textAlign = 'left';
}

function drawConfetti(d) {
  const cx = d.x * S + S/2, cy = d.y * S;
  const colors = ['#f0c040', '#4ae04a', '#fff', '#d1a128', '#ff5a9a', '#00e5ff'];
  for (let i = 0; i < 15; i++) {
    const a = (i / 15) * Math.PI * 2 + frame * 0.04;
    const dist = 40 + Math.sin(frame * 0.08 + i * 1.3) * 28;
    ctx.fillStyle = colors[i % colors.length];
    ctx.fillRect(cx + Math.cos(a) * dist, cy + Math.sin(a) * dist - 20, 4 + (i % 2) * 2, 4 + (i % 2) * 2);
  }
}

function drawCoffeeCups(d, count) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const baseX = d.x * TILE + TILE + 1;
  const baseY = d.y * TILE + 10;
  for (let i = 0; i < count; i++) {
    const cx = baseX + i * 5;
    R(cx, baseY, 3, 4, PAL.cup);
    R(cx, baseY + 4, 3, 1, PAL.cupDark);
    R(cx + 1, baseY + 1, 1, 2, PAL.coffee);
    R(cx + 3, baseY + 1, 1, 2, PAL.cupDark);
  }
  if (count > 0) {
    // Steam/smoke ‚Äî 2-3 translucent white pixels rising and fading
    for (let si = 0; si < Math.min(count, 3); si++) {
      const sx = baseX + si * 5 + 1;
      const drift = Math.sin(frame * 0.04 + si * 2) * 0.8;
      for (let sp = 0; sp < 3; sp++) {
        const age = (frame * 0.06 + si * 3 + sp * 2.5) % 6;
        const steamAlpha = Math.max(0, 0.35 - age * 0.06);
        if (steamAlpha > 0.02) {
          R(sx + (drift | 0), baseY - 1 - (age | 0), 1, 1, 'rgba(255,255,255,' + steamAlpha.toFixed(2) + ')');
        }
      }
    }
  }
  ctx.restore();
}

function drawPrBadge(d, num, merged) {
  const x = d.x * S + S - 12, y = d.y * S - 4;
  R(x, y, 44, 24, merged ? '#d1a128' : '#2f9a3d');
  R(x, y, 44, 2, merged ? '#e8c848' : '#4ae04a');
  ctx.fillStyle = '#111'; ctx.font = '14px "Press Start 2P"'; ctx.fillText(`#${num}`, x + 4, y + 18);
}

function drawTokenBar(d, pct) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 1, y = (d.y + 1) * TILE + TILE - 2, w = TILE - 2;
  R(x, y, w, 2, '#0b0b12');
  const color = pct > 80 ? '#c13c3c' : pct > 50 ? '#d1a128' : '#2f9a3d';
  R(x, y, Math.floor(w * pct / 100), 2, color);
  ctx.restore();
}

function drawPlant(tx, ty) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = tx * TILE + 4, y = ty * TILE;
  R(x+2, y+10, 8, 6, PAL.plantPot); R(x+1, y+10, 10, 2, PAL.plantPotDark); R(x+3, y+10, 6, 1, PAL.plantPot);
  R(x+4, y+4, 4, 6, PAL.plant); R(x+2, y+2, 8, 4, PAL.plant);
  R(x, y+4, 3, 3, PAL.plant); R(x+9, y+3, 3, 4, PAL.plant);
  R(x+3, y+2, 2, 1, PAL.plantLight); R(x+7, y+3, 2, 1, PAL.plantLight); R(x+1, y+4, 1, 1, PAL.plantLight);
  ctx.restore();
}

function drawServerRack(px, py) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  R(px, py, 8, 16, '#1a1a1a'); R(px+1, py+1, 6, 14, '#111');
  for (let i = 0; i < 5; i++) {
    R(px+2, py+2+i*3, 1, 1, ((frame + i * 17) % 30) < 15 ? '#2f9a3d' : '#1a3a1a');
    R(px+4, py+2+i*3, 1, 1, ((frame + i * 23) % 40) < 20 ? '#3b7cff' : '#1a1a3a');
    R(px+2, py+3+i*3, 4, 1, '#222');
  }
  ctx.restore();
}

function drawDivider(col) {
  const x = (2 + col * 5 - 1) * S + S/2;
  ctx.strokeStyle = PAL.divider; ctx.lineWidth = 4; ctx.setLineDash([8, 8]);
  ctx.beginPath(); ctx.moveTo(x, 2 * S); ctx.lineTo(x, ROWS * S - S); ctx.stroke(); ctx.setLineDash([]);
}

function drawLampGlow(tx, ty) {
  const cx = tx * S + S/2, cy = ty * S;
  const grad = ctx.createRadialGradient(cx, cy, 4, cx, cy + 120, 120);
  grad.addColorStop(0, 'rgba(255,240,200,0.06)'); grad.addColorStop(1, 'rgba(255,240,200,0)');
  ctx.fillStyle = grad; ctx.fillRect(cx - 120, cy, 240, 160);
}

// Tumbleweed
let tumbleX = -40;
function drawTumbleweed() {
  tumbleX = (tumbleX + 0.8) % (COLS * S + 80);
  const ty = (ROWS - 1) * S - 16 + Math.sin(tumbleX * 0.015) * 8;
  ctx.save(); ctx.translate(tumbleX, ty); ctx.rotate(frame * 0.06);
  ctx.fillStyle = '#6a5a30'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#8a7a40'; ctx.lineWidth = 2;
  for (let i = 0; i < 5; i++) { const a = i * Math.PI / 2.5; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(a)*10, Math.sin(a)*10); ctx.stroke(); }
  ctx.restore();
}

// ============================================================
// SV Environment Upgrade ‚Äî new draw functions
// ============================================================

function drawFloorSV() {
  // Floor starts at row 2 (rows 0-1 are wall)
  for (let r = 2; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) {
      const checker = (c + r) % 2;
      const noise = Math.sin(c * 7 + r * 13) * 0.5 + 0.5;
      let base;
      if (checker === 0) base = noise > 0.3 ? PAL.svFloor1 : PAL.svFloor2;
      else base = noise > 0.5 ? PAL.svFloor3 : PAL.svFloor4;
      tileRect(c, r, 1, 1, base);
    }
  ctx.save(); ctx.scale(SCALE, SCALE);
  const W = COLS * TILE, H = ROWS * TILE;
  const WALL_H = TILE * 2;
  // Per-row depth gradient ‚Äî darker at edges, lighter center (floor rows only)
  for (let r = 2; r < ROWS; r++) {
    const ry = r * TILE;
    const grad = ctx.createLinearGradient(0, ry, W, ry);
    const edgeA = (0.06 + r * 0.004).toFixed(3);
    const midA = '0.000';
    grad.addColorStop(0, 'rgba(0,0,0,' + edgeA + ')');
    grad.addColorStop(0.35, 'rgba(0,0,0,' + midA + ')');
    grad.addColorStop(0.65, 'rgba(0,0,0,' + midA + ')');
    grad.addColorStop(1, 'rgba(0,0,0,' + edgeA + ')');
    ctx.fillStyle = grad;
    ctx.fillRect(0, ry, W, TILE);
  }
  // Depth gradient below wall ‚Äî darker near wall base
  const ceilGrad = ctx.createLinearGradient(0, WALL_H, 0, WALL_H + TILE * 2);
  ceilGrad.addColorStop(0, 'rgba(0,0,20,0.08)');
  ceilGrad.addColorStop(1, 'rgba(0,0,20,0)');
  ctx.fillStyle = ceilGrad;
  ctx.fillRect(0, WALL_H, W, TILE * 2);
  // Warm ambient tint
  ctx.fillStyle = PAL.svFloorWarm;
  ctx.fillRect(0, WALL_H, W, H - WALL_H);
  // Concrete cracks
  ctx.fillStyle = '#2e2845';
  for (let i = 0; i < 18; i++) ctx.fillRect(30 + i * 2, 95 + (Math.sin(i * 1.3) * 2 | 0), 2, 1);
  for (let i = 0; i < 12; i++) ctx.fillRect(170 + i * 2, 140 + (i % 3 === 0 ? 1 : 0), 1, 1);
  for (let i = 0; i < 8; i++) ctx.fillRect(100 + i * 3, 60 + (Math.sin(i * 0.7) | 0), 2, 1);
  // Scuff marks ‚Äî occasional single dark pixels
  ctx.fillStyle = 'rgba(20,15,30,0.18)';
  for (let i = 0; i < 10; i++) {
    const sx = (i * 31 + 17) % W, sy = WALL_H + (i * 23 + 7) % (H - WALL_H);
    ctx.fillRect(sx, sy, 1, 1);
  }
  // Floor stains (spilled coffee, etc)
  ctx.fillStyle = 'rgba(60,40,20,0.12)';
  ctx.fillRect(85, 125, 6, 5);
  ctx.fillRect(195, 105, 5, 4);
  ctx.fillRect(145, 160, 4, 3);
  // Epoxy shine spots ‚Äî subtle specular highlights
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(50, 80, 20, 15);
  ctx.fillRect(150, 50, 15, 12);
  ctx.fillRect(240, 120, 18, 10);
  ctx.fillRect(100, 140, 12, 8);
  ctx.fillRect(200, 60, 16, 10);
  ctx.restore();
}

function drawWallsSV() {
  const WALL_H = TILE * 2; // 2-row wall (32px)
  // Base wall tiles for rows 0-1
  for (let c = 0; c < COLS; c++) {
    tileRect(c, 0, 1, 1, PAL.wall);
    tileRect(c, 1, 1, 1, PAL.wall);
  }
  ctx.save(); ctx.scale(SCALE, SCALE);
  const W = COLS * TILE;
  // Wall corner darkening gradient
  const wallGrad = ctx.createLinearGradient(0, 0, W, 0);
  wallGrad.addColorStop(0, 'rgba(0,0,0,0.08)');
  wallGrad.addColorStop(0.15, 'rgba(0,0,0,0)');
  wallGrad.addColorStop(0.85, 'rgba(0,0,0,0)');
  wallGrad.addColorStop(1, 'rgba(0,0,0,0.08)');
  ctx.fillStyle = wallGrad;
  ctx.fillRect(0, 0, W, WALL_H);
  // Vertical gradient ‚Äî darker near ceiling
  const vGrad = ctx.createLinearGradient(0, 0, 0, WALL_H);
  vGrad.addColorStop(0, 'rgba(0,0,0,0.06)');
  vGrad.addColorStop(0.3, 'rgba(0,0,0,0)');
  vGrad.addColorStop(1, 'rgba(0,0,0,0.02)');
  ctx.fillStyle = vGrad;
  ctx.fillRect(0, 0, W, WALL_H);
  // Panel seams every 3-4 tiles with color variation
  for (let px = 0; px < W; px += TILE * 3) {
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(px, 4, 1, WALL_H - 6);
    if ((px / (TILE * 3)) % 2 === 1) {
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(px + 1, 4, TILE * 3 - 1, WALL_H - 6);
    }
  }
  // Exposed brick sections ‚Äî taller with more variation
  const brickW = 4, brickH = 2;
  for (let section = 0; section < 3; section++) {
    const sx = [8, 140, 260][section];
    const sw = [40, 50, 40][section];
    for (let by = 6; by < WALL_H - 3; by += brickH + 1) {
      const offset = (by % 4 === 0) ? 0 : 2;
      for (let bx = sx + offset; bx < sx + sw; bx += brickW + 1) {
        const shade = ((bx + by * 3) % 3);
        const bColor = shade === 0 ? PAL.svBrick : shade === 1 ? PAL.svBrickDark : '#7a4a3a';
        ctx.fillStyle = bColor;
        ctx.fillRect(bx, by, Math.min(brickW, sx + sw - bx), brickH);
        ctx.fillStyle = PAL.svBrickMortar;
        ctx.fillRect(bx + brickW, by, 1, brickH);
        ctx.fillRect(bx, by + brickH, brickW + 1, 1);
      }
    }
  }
  // Exposed ductwork/pipes near ceiling ‚Äî industrial loft feel
  ctx.fillStyle = '#666';
  ctx.fillRect(4, 2, W - 8, 2); // main horizontal duct
  ctx.fillStyle = '#555';
  ctx.fillRect(4, 2, W - 8, 1); // top highlight
  ctx.fillStyle = '#444';
  ctx.fillRect(4, 4, W - 8, 1); // shadow below duct
  // Vertical pipe drops
  [30, 100, 190, 280].forEach(function(px) {
    ctx.fillStyle = '#5a5a5a';
    ctx.fillRect(px, 4, 2, 6);
    ctx.fillStyle = '#666';
    ctx.fillRect(px, 4, 1, 6);
    ctx.fillStyle = '#777';
    ctx.fillRect(px - 1, 7, 4, 1); // pipe bracket
  });
  // Baseboard
  ctx.fillStyle = '#3a3028'; ctx.fillRect(0, WALL_H - 2, W, 2);
  ctx.fillStyle = '#4a4038'; ctx.fillRect(0, WALL_H - 2, W, 1);
  // Electrical conduit lines running along wall
  ctx.fillStyle = PAL.svConduit;
  ctx.fillRect(0, WALL_H - 4, W, 1);
  ctx.fillStyle = PAL.svConduitLight;
  for (let x = 0; x < W; x += 30) {
    ctx.fillRect(x, WALL_H - 5, 1, 3);
  }
  // Fluorescent light strips on ceiling ‚Äî brighter at night, with flicker
  const { nightFactor: wallNF } = getTimeOfDay();
  const flourGlowAlpha = (0.06 + wallNF * 0.12).toFixed(3);
  for (let i = 0; i < 4; i++) {
    const lx = 30 + i * 70, ly = 0;
    const flicker = 1.0 - ((frame + i * 37) % 120 < 3 ? 0.15 : 0);
    ctx.fillStyle = PAL.svFluor;
    ctx.fillRect(lx, ly, 30, 2);
    const tubeAlpha = wallNF > 0.3 ? (0.8 + wallNF * 0.2) * flicker : flicker;
    ctx.fillStyle = 'rgba(255,255,255,' + tubeAlpha.toFixed(2) + ')';
    ctx.fillRect(lx + 2, ly, 26, 1);
    ctx.fillStyle = 'rgba(200,232,255,' + (parseFloat(flourGlowAlpha) * flicker).toFixed(3) + ')';
    ctx.fillRect(lx - 4, ly + 2, 38, 8);
  }
  // EXIT sign above door area
  const exX = 6, exY = 6;
  R(exX, exY, 14, 6, '#1a4a1a');
  R(exX + 1, exY + 1, 12, 4, '#2a6a2a');
  ctx.fillStyle = '#4aff4a';
  ctx.font = '3px "Press Start 2P"';
  ctx.fillText('EXIT', exX + 2, exY + 4);
  if (wallNF > 0.2) {
    R(exX - 2, exY + 6, 18, 4, 'rgba(74,255,74,' + (wallNF * 0.08).toFixed(3) + ')');
  }
  // Fire extinguisher on wall
  const feX = 104, feY = 16;
  R(feX + 1, feY - 2, 3, 1, '#555'); // mounting bracket
  R(feX + 1, feY - 1, 3, 1, '#666');
  R(feX, feY, 5, 8, '#cc2222'); // body
  R(feX, feY, 5, 1, '#dd3333'); // top highlight
  R(feX + 1, feY + 1, 3, 1, '#ee4444');
  R(feX + 2, feY - 3, 1, 2, '#444'); // nozzle
  R(feX + 3, feY - 3, 2, 1, '#333'); // handle
  R(feX, feY + 6, 5, 1, '#aa1818'); // bottom shadow
  R(feX + 1, feY + 3, 3, 2, '#fff'); // label
  // Wall clock ‚Äî analog face synced to real time
  const clkX = 192, clkY = 8;
  R(clkX, clkY, 8, 8, '#ddd'); // clock body
  R(clkX + 1, clkY + 1, 6, 6, '#f8f8f0'); // face
  R(clkX, clkY, 8, 1, '#999'); R(clkX, clkY + 7, 8, 1, '#999');
  R(clkX, clkY, 1, 8, '#999'); R(clkX + 7, clkY, 1, 8, '#999');
  // Hour markers
  R(clkX + 3, clkY + 1, 2, 1, '#333'); R(clkX + 3, clkY + 6, 2, 1, '#333');
  R(clkX + 1, clkY + 3, 1, 2, '#333'); R(clkX + 6, clkY + 3, 1, 2, '#333');
  // Clock hands based on real time
  var clkH = new Date().getHours() % 12;
  var clkM = new Date().getMinutes();
  R(clkX + 3, clkY + 3, 2, 2, '#444'); // center
  var hourDirs = [[0,-1],[1,-1],[1,-1],[1,0],[1,1],[1,1],[0,1],[-1,1],[-1,1],[-1,0],[-1,-1],[-1,-1]];
  var hd = hourDirs[clkH];
  R(clkX + 3 + hd[0], clkY + 3 + hd[1], 1, 1, '#222');
  var minSlot = Math.floor(clkM / 5);
  var md = hourDirs[minSlot];
  R(clkX + 3 + md[0] * 2, clkY + 3 + md[1] * 2, 1, 1, '#666');
  // Easter egg: "Series A" funding check pinned to wall
  const chkX = 112, chkY = 8;
  R(chkX, chkY, 18, 8, '#f8f0e0'); // check paper
  R(chkX, chkY, 18, 1, '#ddd');
  R(chkX + 8, chkY, 1, 1, '#cc2222'); // pin
  ctx.fillStyle = '#888';
  ctx.font = '2px "Press Start 2P"';
  ctx.fillText('SERIES A', chkX + 1, chkY + 4);
  ctx.fillStyle = '#2a8a2a';
  ctx.fillText('$0.00', chkX + 3, chkY + 7);
  // Easter egg: tiny Octocat silhouette
  const ocX = 48, ocY = 22;
  R(ocX, ocY, 4, 3, '#333'); // body
  R(ocX + 1, ocY - 1, 2, 1, '#333'); // head
  R(ocX, ocY - 1, 1, 1, '#333'); R(ocX + 3, ocY - 1, 1, 1, '#333'); // ears
  R(ocX + 1, ocY + 3, 1, 1, '#333'); R(ocX + 2, ocY + 3, 1, 1, '#333'); // legs

  // --- SV wall decorations ---

  // Guitar hanging on wall
  const gX = 96, gY = 7;
  R(gX + 1, gY - 1, 2, 1, '#666'); // wall hook
  R(gX, gY, 4, 2, '#5a3a1a'); // headstock
  R(gX, gY, 1, 1, '#aaa'); R(gX + 3, gY + 1, 1, 1, '#aaa'); // tuning pegs
  R(gX + 1, gY + 2, 2, 5, '#8B5A2B'); // neck
  R(gX + 1, gY + 3, 2, 1, '#bbb'); R(gX + 1, gY + 5, 2, 1, '#bbb'); // frets
  R(gX - 1, gY + 7, 6, 5, '#C68642'); // body
  R(gX, gY + 7, 4, 1, '#daa060'); // body highlight
  R(gX + 1, gY + 9, 2, 2, '#3a2010'); // sound hole
  R(gX - 1, gY + 11, 6, 1, '#a07030'); // body shadow

  // Dart board
  const dbX = 60, dbY = 20;
  R(dbX + 1, dbY, 6, 1, '#1a5a1a'); // top edge
  R(dbX, dbY + 1, 8, 6, '#1a5a1a'); // outer ring
  R(dbX + 1, dbY + 7, 6, 1, '#1a5a1a'); // bottom edge
  R(dbX + 2, dbY + 1, 4, 1, '#cc2222'); // inner top
  R(dbX + 1, dbY + 2, 6, 4, '#cc2222'); // inner ring
  R(dbX + 2, dbY + 6, 4, 1, '#cc2222'); // inner bottom
  R(dbX + 2, dbY + 2, 4, 4, '#eee'); // white ring
  R(dbX + 3, dbY + 3, 2, 2, '#cc2222'); // bullseye
  R(dbX + 5, dbY + 2, 1, 1, '#ffcc00'); // dart tip
  R(dbX + 6, dbY + 1, 2, 1, '#888'); // dart shaft
  R(dbX + 7, dbY, 1, 1, '#ff4444'); R(dbX + 7, dbY + 2, 1, 1, '#ff4444'); // dart flights

  // Ping pong paddle + ball mounted on wall
  const ppX = 74, ppY = 20;
  R(ppX, ppY, 5, 6, '#cc3333'); // paddle face
  R(ppX, ppY, 5, 1, '#dd4444'); // paddle highlight
  R(ppX + 1, ppY + 1, 3, 4, '#ee4444'); // paddle center
  R(ppX + 2, ppY + 6, 1, 3, '#8B4513'); // handle
  R(ppX + 1, ppY + 6, 3, 1, '#7a3a0a'); // handle collar
  R(ppX + 7, ppY + 1, 2, 2, '#fff'); // ball
  R(ppX + 7, ppY + 1, 1, 1, '#ff8800'); // ball stripe

  ctx.restore();
}

function drawDeskSV(d, idx, agentType) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE, y = d.y * TILE + 8;
  const isCodex = (agentType || '').includes('codex');
  const isStanding = idx % 3 === 0;

  if (isStanding) {
    // Standing desk ‚Äî taller frame, adjustable legs
    R(x, y - 2, TILE, 2, PAL.svDeskSurface); R(x, y - 2, TILE, 1, PAL.svDeskFrameLight);
    for (let gx = x + 1; gx < x + TILE - 1; gx += 2) R(gx, y - 1, 1, 1, PAL.svDeskSurfaceDark);
    R(x, y, TILE, 1, PAL.svDeskSurfaceDark);
    R(x + 1, y + 1, 1, 10, PAL.svDeskFrame); R(x + 2, y + 1, 1, 10, PAL.svDeskFrameDark);
    R(x + TILE - 3, y + 1, 1, 10, PAL.svDeskFrame); R(x + TILE - 2, y + 1, 1, 10, PAL.svDeskFrameDark);
    R(x + 2, y + 6, TILE - 4, 1, PAL.svDeskFrameDark);
  } else {
    // Regular desk ‚Äî modern desk with wood grain
    R(x, y, TILE, 2, PAL.svDeskSurface); R(x, y, TILE, 1, '#d8ccb4');
    for (let gx = x + 1; gx < x + TILE - 1; gx += 2) R(gx, y + 1, 1, 1, PAL.svDeskSurfaceDark);
    for (let gx = x + 2; gx < x + TILE - 1; gx += 3) R(gx, y + 1, 2, 1, '#c4b898');
    R(x, y + 2, TILE, 3, PAL.svDeskFrame); R(x, y + 2, TILE, 1, PAL.svDeskFrameLight);
    R(x + 1, y + 5, 1, 7, PAL.svDeskFrameDark); R(x + TILE - 2, y + 5, 1, 7, PAL.svDeskFrameDark);
    R(x + 1, y + 11, 3, 1, PAL.svDeskFrame); R(x + TILE - 4, y + 11, 3, 1, PAL.svDeskFrame);
  }

  // Mechanical keyboard with colored keycaps
  const ky = isStanding ? y - 1 : y + 1;
  R(x + 2, ky, 8, 3, PAL.svKeyboard);
  R(x + 2, ky, 8, 1, '#333');
  const keyCols = ['#4a4a4a', '#3a5a3a', '#3a3a5a', '#5a3a3a', '#4a4a3a'];
  for (let kx = 0; kx < 7; kx++) {
    R(x + 3 + kx, ky + 1, 1, 1, keyCols[kx % keyCols.length]);
  }
  for (let kx = 0; kx < 6; kx++) {
    R(x + 3 + kx, ky + 2, 1, 1, keyCols[(kx + 2) % keyCols.length]);
  }
  // Trackpad/Mouse
  R(x + 11, ky, 3, 2, PAL.svMouse);
  R(x + 11, ky, 3, 1, '#444');
  R(x + 12, ky + 1, 1, 1, '#3a3a3a');

  // Cable management tray under desk
  const cableY = isStanding ? y + 7 : y + 7;
  R(x + 2, cableY, TILE - 4, 1, '#3a3a3a');
  ctx.fillStyle = PAL.svCable;
  for (let i = 0; i < 5; i++) {
    const cx = x + 3 + i * 2;
    const cy = cableY + 1 + Math.sin(i * 1.8) * 1;
    ctx.fillRect(cx, cy, 1, 2);
  }

  // Power strip with LED
  R(x + 4, cableY + 3, 6, 2, '#2a2a2a');
  R(x + 4, cableY + 3, 6, 1, '#333');
  R(x + 9, cableY + 3, 1, 1, frame % 60 < 30 ? '#2f9a3d' : '#1a4a1a');

  // Backpack leaning against desk leg
  if (idx % 3 === 1) {
    const bx = x + TILE - 2, by = isStanding ? y + 8 : y + 9;
    R(bx, by, 3, 4, '#3a4a6a');
    R(bx, by, 3, 1, '#4a5a7a');
    R(bx + 1, by + 1, 1, 1, '#555');
  }
  ctx.restore();
}

function drawMonitorSV(d, state, monitorText, idx, agentType) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 1, y = d.y * TILE;
  const isCodex = (agentType || '').includes('codex');

  // Primary monitor ‚Äî thin bezel with visible stand
  R(x, y, 12, 8, PAL.monitorBezel); R(x + 1, y, 10, 1, PAL.monitor);
  const sc = state === 'ci_failed' ? '#3a0808' : (state === 'coding' ? '#0a200a' : '#0a0a0a');
  R(x + 1, y + 1, 10, 6, sc);
  // Thin bezel highlight
  R(x, y, 12, 1, '#333');
  // Monitor stand ‚Äî visible arm + base
  R(x + 5, y + 8, 2, 1, '#444');
  R(x + 4, y + 9, 4, 1, '#333');
  R(x + 3, y + 9, 6, 1, '#2a2a2a');

  // Sticky notes on monitor bezel
  const stickyColors = PAL.svSticky;
  R(x, y + 7, 2, 1, stickyColors[idx % stickyColors.length]);
  if (idx % 2 === 0) R(x + 10, y + 7, 2, 1, stickyColors[(idx + 2) % stickyColors.length]);

  if (isCodex) {
    // Codex: dual monitor + tower PC (power user)
    // Second monitor (same size, slightly offset)
    R(x + 13, y, 3, 6, PAL.svMonitor2Bezel);
    R(x + 13, y, 3, 1, PAL.svMonitor2);
    R(x + 13, y + 1, 3, 4, sc === '#0a0a0a' ? '#0c0c0c' : sc);
    R(x + 14, y + 6, 1, 1, '#333');
    // Tower PC under desk ‚Äî tall case with LED
    R(x + 14, y + 8, 2, 4, '#1a1a1a');
    R(x + 14, y + 8, 2, 1, '#2a2a2a');
    R(x + 14, y + 9, 1, 1, frame % 40 < 20 ? '#2f9a3d' : '#1a3a1a');
    R(x + 14, y + 10, 1, 1, '#00e5ff33');
  } else {
    // Claude: laptop + external monitor (creative/portable)
    // Laptop ‚Äî open with screen glow + keyboard area + trackpad
    R(x + 13, y + 4, 4, 1, PAL.svLaptop); // lid/hinge
    R(x + 13, y + 5, 4, 3, PAL.svLaptop);
    R(x + 13, y + 5, 4, 2, PAL.svLaptopScreen);
    // Laptop screen glow
    if (state === 'coding') R(x + 14, y + 5, 2, 1, '#0a200a');
    // Laptop keyboard area
    R(x + 13, y + 7, 4, 1, '#222');
    for (let lk = 0; lk < 3; lk++) R(x + 14 + lk, y + 7, 1, 1, '#2a2a2a');
  }

  // Screen content on primary monitor
  if (state === 'coding') {
    const colors = ['#4ae04a', '#2a8a2a', '#6af06a', '#3aaa3a', '#2f9a3d'];
    const indents = [0, 1, 2, 2, 1, 0, 1, 3, 0, 2];
    const lengths = [6, 4, 3, 5, 7, 2, 4, 3, 5, 6];
    const scrollOff = Math.floor(frame / 14) % 10;
    for (let line = 0; line < 5; line++) {
      const li = (line + scrollOff) % 10;
      const indent = indents[li];
      const len = lengths[li];
      R(x + 2 + indent, y + 1 + line, Math.min(len, 8 - indent), 1, colors[li % colors.length]);
    }
    // Blinking cursor
    if (frame % 16 < 8) R(x + 9, y + 5, 1, 1, '#4ae04a');
    // Occasional compile flash ‚Äî brief white flicker
    if (frame % 300 < 2) R(x + 1, y + 1, 10, 6, 'rgba(200,255,200,0.2)');
  } else if (state === 'ci_failed') {
    const bright = Math.sin(frame * 0.1) > 0;
    const c = bright ? '#ff3b3b' : '#aa2222';
    R(x + 3, y + 1, 1, 1, c); R(x + 7, y + 1, 1, 1, c);
    R(x + 4, y + 2, 1, 1, c); R(x + 6, y + 2, 1, 1, c); R(x + 5, y + 3, 1, 1, c);
    R(x + 4, y + 4, 1, 1, c); R(x + 6, y + 4, 1, 1, c);
    R(x + 3, y + 5, 1, 1, c); R(x + 7, y + 5, 1, 1, c);
  } else if (state === 'merged') {
    R(x + 5, y + 1, 2, 1, '#f0c040'); R(x + 4, y + 2, 4, 1, '#f0c040');
    R(x + 3, y + 3, 6, 1, '#d8a820'); R(x + 4, y + 4, 4, 1, '#f0c040');
  } else {
    R(x + 4, y + 3, 1, 1, '#4ae04a'); R(x + 5, y + 4, 1, 1, '#4ae04a');
    R(x + 6, y + 3, 1, 1, '#4ae04a'); R(x + 7, y + 2, 1, 1, '#4ae04a');
  }

  // Scrolling issue title text on monitor screen
  if (monitorText) {
    ctx.restore();
    const sx = (x + 1) * SCALE, sy = (y + 1) * SCALE, sw = 10 * SCALE, sh = 6 * SCALE;
    ctx.save();
    ctx.beginPath(); ctx.rect(sx, sy, sw, sh); ctx.clip();
    ctx.fillStyle = state === 'ci_failed' ? '#ff6666' : (state === 'coding' ? '#4ae04a' : '#8888ff');
    ctx.font = '10px "Press Start 2P", monospace';
    ctx.textBaseline = 'middle';
    const textWidth = ctx.measureText(monitorText).width;
    const totalScroll = textWidth + sw + 8;
    const scroll = (frame * 0.6) % totalScroll;
    ctx.fillText(monitorText, sx + sw - scroll, sy + sh / 2);
    ctx.restore();
    ctx.save(); ctx.scale(SCALE, SCALE);
  }

  // Monitor glow on desk/floor ‚Äî radial gradient for light pool
  if (state === 'coding' || state === 'ci_failed') {
    const gcx = x + 6, gcy = y + 10;
    const gr = state === 'ci_failed' ? 'rgba(255,59,59,' : 'rgba(74,224,74,';
    const glow = ctx.createRadialGradient(gcx, gcy, 1, gcx, gcy + 3, 10);
    glow.addColorStop(0, gr + '0.12)');
    glow.addColorStop(1, gr + '0)');
    ctx.fillStyle = glow;
    ctx.fillRect(x - 4, y + 6, 20, 12);
  }
  ctx.restore();
}

function drawChairSV(d, idx) {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const x = d.x * TILE + 3, y = d.y * TILE + 10;
  const chairColor = PAL.svChairColors[idx % PAL.svChairColors.length];
  const chairDark = '#1a1a1a';

  // Seat (mesh texture ‚Äî grid of small dots)
  R(x, y, 10, 2, chairColor);
  for (let mx = x; mx < x + 10; mx += 2)
    for (let my = y; my < y + 2; my++) R(mx, my, 1, 1, chairDark + '44');
  R(x, y, 10, 1, chairColor);

  // Backrest (mesh pattern ‚Äî grid of dots)
  R(x, y - 7, 10, 4, chairColor);
  for (let mx = x + 1; mx < x + 9; mx += 2)
    for (let my = y - 6; my < y - 3; my += 2) R(mx, my, 1, 1, chairDark + '44');
  R(x, y - 7, 10, 1, PAL.svChairFrame);
  R(x, y - 3, 10, 1, PAL.svChairFrame);
  // Lumbar support ridge
  R(x + 1, y - 4, 8, 1, chairDark + '33');

  // Armrests ‚Äî padded tops
  R(x - 1, y - 2, 3, 1, PAL.svChairFrame);
  R(x - 1, y - 2, 3, 1, '#666');
  R(x + 8, y - 2, 3, 1, PAL.svChairFrame);
  R(x + 8, y - 2, 3, 1, '#666');
  // Side supports
  R(x, y - 3, 1, 4, chairDark);
  R(x + 9, y - 3, 1, 4, chairDark);

  // Center post ‚Äî hydraulic cylinder
  R(x + 4, y + 2, 2, 2, PAL.svChairFrame);
  R(x + 4, y + 2, 1, 1, '#666');
  // 5-star castor base
  R(x + 1, y + 4, 8, 1, PAL.svChairFrame);
  R(x + 4, y + 4, 2, 1, '#666');
  // 5 wheels at star tips
  R(x - 1, y + 5, 2, 1, PAL.svChairWheel);
  R(x + 2, y + 5, 2, 1, PAL.svChairWheel);
  R(x + 4, y + 5, 2, 1, PAL.svChairWheel);
  R(x + 6, y + 5, 2, 1, PAL.svChairWheel);
  R(x + 9, y + 5, 2, 1, PAL.svChairWheel);
  ctx.restore();
}

function drawPropsSV() {
  ctx.save(); ctx.scale(SCALE, SCALE);

  // 1. Pizza boxes ‚Äî stacked near bottom-left corner
  const pzX = 22, pzY = TILE * (ROWS - 2) + 4;
  for (let i = 0; i < 3; i++) {
    R(pzX, pzY - i * 3, 12, 3, PAL.svPizzaBox);
    R(pzX, pzY - i * 3, 12, 1, PAL.svPizzaBoxDark);
    R(pzX + 1, pzY - i * 3 + 1, 10, 1, '#c89838'); // lid line
  }
  // Top box slightly open
  R(pzX + 1, pzY - 8, 10, 1, '#d8a848');

  // 2. Floor cable runs ‚Äî ethernet/power cables across walkways (SV garage vibe)
  ctx.fillStyle = '#2a2a3a';
  // Horizontal cable run between row 1 and 2
  for (let cx = 3 * TILE; cx < 17 * TILE; cx += 2) {
    const wobble = Math.sin(cx * 0.3) * 0.8;
    R(cx, 3 * TILE + 6 + Math.round(wobble), 2, 1, '#2a2a3a');
  }
  // Cable tie-downs (small squares along cable)
  [5, 9, 13].forEach(col => {
    R(col * TILE, 3 * TILE + 6, 2, 2, '#444');
  });

  // 3. Whiteboard markers ‚Äî on floor near whiteboard
  const mkX = 17 * TILE + 2, mkY = 2 * TILE + 10;
  [['#e04040', 0], ['#4040e0', 3], ['#40a040', 6]].forEach(([color, offset]) => {
    R(mkX + offset, mkY, 6, 2, color);
    R(mkX + offset, mkY, 1, 2, '#ddd'); // cap
  });

  // 4. Laptop stickers on wall ‚Äî YC, GitHub octocat, etc (colored squares = stickers)
  const stX = 8 * TILE, stY = 12;
  [['#f06529', 'YC'], ['#333', '‚óÜ'], ['#6e5494', '‚ö°']].forEach(([bg, _label], i) => {
    R(stX + i * 8, stY, 6, 6, bg);
    R(stX + i * 8 + 1, stY + 1, 4, 4, bg);
    // Slight highlight
    R(stX + i * 8, stY, 6, 1, 'rgba(255,255,255,0.15)');
  });

  // 3. Sticky notes ‚Äî colored squares on wall near whiteboard
  const stickyX = 270, stickyY = 18;
  PAL.svSticky.forEach((color, i) => {
    const sx = stickyX + (i % 2) * 6;
    const sy = stickyY + Math.floor(i / 2) * 6;
    R(sx, sy, 5, 5, color);
    // Tiny scribble lines
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(sx + 1, sy + 1, 3, 1);
    ctx.fillRect(sx + 1, sy + 3, 2, 1);
  });

  // 4. "MOVE FAST" poster on wall
  const postX = 200, postY = 10;
  R(postX, postY, 16, 10, PAL.svPoster);
  R(postX, postY, 16, 1, '#ccc');
  ctx.fillStyle = PAL.svPosterText;
  ctx.font = '2px "Press Start 2P"';
  ctx.fillText('MOVE', postX + 2, postY + 5);
  ctx.fillText('FAST', postX + 3, postY + 8);

  // 5. Skateboard ‚Äî leaning against wall near door
  const skX = 22, skY = TILE * 2 - 1;
  R(skX, skY, 10, 2, PAL.svSkateDeck);
  R(skX + 1, skY + 2, 2, 1, PAL.svSkateTruck);
  R(skX + 7, skY + 2, 2, 1, PAL.svSkateTruck);
  R(skX, skY + 3, 2, 1, PAL.svSkateWheel);
  R(skX + 8, skY + 3, 2, 1, PAL.svSkateWheel);

  // 6. Cardboard boxes ‚Äî stacked near entrance
  const bxX = 28, bxY = TILE * 2 + 6;
  R(bxX, bxY, 10, 8, PAL.svCardboard);
  R(bxX, bxY, 10, 1, PAL.svCardboardDark);
  R(bxX + 1, bxY + 3, 8, 1, PAL.svCardboardDark); // tape
  // Second box on top, slightly offset
  R(bxX + 2, bxY - 6, 8, 6, PAL.svCardboard);
  R(bxX + 2, bxY - 6, 8, 1, PAL.svCardboardDark);
  R(bxX + 3, bxY - 3, 6, 1, PAL.svCardboardDark);
  // Arrow marking
  ctx.fillStyle = '#666';
  ctx.fillRect(bxX + 4, bxY + 4, 2, 3);
  ctx.fillRect(bxX + 3, bxY + 4, 4, 1);

  // 7. Bean bag ‚Äî bottom-right corner area
  const bbX = (COLS - 2) * TILE + 2, bbY = (ROWS - 2) * TILE + 2;
  R(bbX + 1, bbY + 2, 10, 6, PAL.svBeanBag);
  R(bbX, bbY + 4, 12, 4, PAL.svBeanBag);
  R(bbX + 2, bbY + 1, 8, 2, PAL.svBeanBag);
  R(bbX + 2, bbY + 2, 6, 1, PAL.svBeanBagDark);
  R(bbX + 1, bbY + 6, 10, 2, PAL.svBeanBagDark);
  // Highlight
  R(bbX + 3, bbY + 2, 3, 1, '#dd5577');

  // 8. Mini fridge ‚Äî near server rack
  const frX = (COLS - 1) * TILE - 14, frY = 6 * TILE + 2;
  R(frX, frY, 8, 12, PAL.svFridge);
  R(frX, frY, 8, 1, PAL.svFridgeDark);
  R(frX, frY + 11, 8, 1, PAL.svFridgeDark);
  R(frX + 7, frY + 3, 1, 4, PAL.svFridgeHandle);
  // Magnetic sticker
  R(frX + 2, frY + 2, 3, 3, '#ff5566');
  R(frX + 2, frY + 6, 3, 3, '#55aaff');

  ctx.restore();
}

function drawLightingSV() {
  const { nightFactor, warmFactor, hour } = getTimeOfDay();
  // Neon sign extended glow on nearby walls/floor ‚Äî larger radius, stronger at night
  const neonCX = (55 + 19) * SCALE;
  const neonCY = 12 * SCALE;
  const neonAlpha1 = (0.09 + nightFactor * 0.10).toFixed(3);
  const neonAlpha2 = (0.04 + nightFactor * 0.06).toFixed(3);
  const neonGrad = ctx.createRadialGradient(neonCX, neonCY, 16, neonCX, neonCY + 180, 320);
  neonGrad.addColorStop(0, 'rgba(255,45,123,' + neonAlpha1 + ')');
  neonGrad.addColorStop(0.4, 'rgba(0,229,255,' + neonAlpha2 + ')');
  neonGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = neonGrad;
  ctx.fillRect(neonCX - 320, neonCY - 40, 640, 420);
  // Neon color bleed onto nearby wall tiles (cyan/pink tint)
  ctx.save(); ctx.scale(SCALE, SCALE);
  const wallBleedAlpha = (0.04 + nightFactor * 0.06).toFixed(3);
  ctx.fillStyle = 'rgba(255,45,123,' + wallBleedAlpha + ')';
  ctx.fillRect(50, 0, 18, TILE * 2);
  ctx.fillStyle = 'rgba(0,229,255,' + wallBleedAlpha + ')';
  ctx.fillRect(68, 0, 30, TILE * 2);
  ctx.fillStyle = 'rgba(255,45,123,' + (parseFloat(wallBleedAlpha) * 0.5).toFixed(3) + ')';
  ctx.fillRect(85, 0, 15, TILE * 2);
  ctx.restore();

  // Fluorescent ceiling light glow pools on floor ‚Äî brighter at night, with flicker
  const ceilAlpha = (0.04 + nightFactor * 0.08).toFixed(3);
  for (let i = 0; i < 4; i++) {
    const lx = (30 + i * 70 + 15) * SCALE;
    const ly = 4 * S;
    const flicker = 1.0 - ((frame + i * 37) % 120 < 3 ? 0.15 : 0);
    const flGrad = ctx.createRadialGradient(lx, ly, 10, lx, ly + 80, 160);
    flGrad.addColorStop(0, 'rgba(200,232,255,' + (parseFloat(ceilAlpha) * flicker).toFixed(3) + ')');
    flGrad.addColorStop(1, 'rgba(200,232,255,0)');
    ctx.fillStyle = flGrad;
    ctx.fillRect(lx - 160, ly, 320, 200);
  }

  // Night: draw visible ceiling light rectangles
  if (nightFactor > 0.2) {
    ctx.save(); ctx.scale(SCALE, SCALE);
    const lightAlpha = (nightFactor * 0.6).toFixed(3);
    ctx.fillStyle = 'rgba(220,240,255,' + lightAlpha + ')';
    for (let i = 0; i < 4; i++) {
      const lx = 30 + i * 70;
      ctx.fillRect(lx + 4, 0, 22, 2);
    }
    ctx.restore();
  }

  // Night: monitor screens cast visible light pools on nearby floor
  if (nightFactor > 0.2) {
    const monGlowAlpha = (nightFactor * 0.05).toFixed(3);
    DESKS.forEach(d => {
      const mx = (d.x * TILE + 6) * SCALE;
      const my = (d.y * TILE + 10) * SCALE;
      const mGrad = ctx.createRadialGradient(mx, my, 4, mx, my + 40, 80);
      mGrad.addColorStop(0, 'rgba(74,224,74,' + monGlowAlpha + ')');
      mGrad.addColorStop(1, 'rgba(74,224,74,0)');
      ctx.fillStyle = mGrad;
      ctx.fillRect(mx - 80, my - 10, 160, 100);
    });
  }

  // Daytime: window light beam ‚Äî warm yellow trapezoid on floor
  if (nightFactor < 0.5) {
    const beamAlpha = (0.03 * (1 - nightFactor)).toFixed(3);
    ctx.save(); ctx.scale(SCALE, SCALE);
    // Window is at x=120, y=4, w=64 ‚Äî light falls onto floor below
    const wx = 130, wy = TILE * 2 + 4;
    const beamGrad = ctx.createLinearGradient(wx, wy, wx, wy + TILE * 4);
    beamGrad.addColorStop(0, 'rgba(255,240,180,' + beamAlpha + ')');
    beamGrad.addColorStop(1, 'rgba(255,240,180,0)');
    ctx.fillStyle = beamGrad;
    ctx.beginPath();
    ctx.moveTo(wx, wy); ctx.lineTo(wx + 50, wy);
    ctx.lineTo(wx + 60, wy + TILE * 4); ctx.lineTo(wx - 10, wy + TILE * 4);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

function drawParticles() {
  const W = COLS * TILE, H = ROWS * TILE;
  ctx.save(); ctx.scale(SCALE, SCALE);
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    if (p.type === 'dust') {
      // Update position ‚Äî slow upward drift with horizontal wobble
      p.x += p.vx + Math.sin(frame * 0.02 + i) * 0.05;
      p.y += p.vy;
      // Reset when exiting top
      if (p.y < 0) { p.y = H; p.x = Math.random() * W; }
      if (p.x < 0) p.x = W; if (p.x > W) p.x = 0;
      ctx.fillStyle = 'rgba(200,200,220,' + p.alpha.toFixed(2) + ')';
      ctx.fillRect(p.x | 0, p.y | 0, p.size, p.size);
    } else if (p.type === 'sparkle') {
      p.life++;
      if (p.life >= p.maxLife) {
        // Respawn at random position near neon sign
        p.x = 55 + Math.random() * 38;
        p.y = 8 + Math.random() * 14;
        p.life = 0;
        p.maxLife = 40 + Math.random() * 40;
      }
      // Fade in then out
      const t = p.life / p.maxLife;
      p.alpha = t < 0.3 ? t / 0.3 : (1 - t) / 0.7;
      if (p.alpha > 0.02) {
        ctx.fillStyle = 'rgba(255,220,255,' + (p.alpha * 0.6).toFixed(2) + ')';
        ctx.fillRect(p.x | 0, p.y | 0, 1, 1);
      }
    }
  }
  ctx.restore();
}

// Map live agents to desk positions for canvas rendering
function buildCanvasAgents() {
  return agents.slice(0, 12).map((agent, idx) => {
    const state = mapState(agent);
    const canvasState = state === 'waiting' || state === 'reading' ? 'reading' :
                        state === 'review_waiting' ? 'reading' :
                        state === 'dead' ? 'exited' :
                        state === 'pr_closed' ? 'sleeping' :
                        state;
    return {
      desk: idx,
      ci: idx % CHARS.length,
      state: canvasState,
      pr: getPrNumber(agent),
      tokens: Math.min(100, Math.max(0, getTokens(agent) / 2000 * 100)),
      dead: state === 'dead' || state === 'exited',
      label: getRepoName(agent) + (getIssueId(agent) ? '#' + getIssueId(agent) : ''),
      monitorText: (function() {
        const title = (agent.issueTitle || '').toString().trim();
        const repo = getRepoName(agent);
        const id = getIssueId(agent);
        const prefix = repo && id ? repo + '#' + id : (repo || '');
        return title && prefix ? prefix + ' ‚Äî ' + title : (title || prefix || '');
      })(),
      failing: isCiFailing(agent),
      coffees: coffeeCount(agent),
      agentType: resolveAgentType(agent),
    };
  });
}

function drawUsageBars() {
  ctx.save(); ctx.scale(SCALE, SCALE);
  const W = COLS * TILE; // 320 unscaled
  const bgY = ROWS * TILE - 12, bgH = 11;
  // Semi-transparent background strip
  ctx.fillStyle = 'rgba(10,10,30,0.75)';
  ctx.fillRect(0, bgY, W, bgH);
  // Bottom border
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fillRect(0, bgY + bgH, W, 1);

  const barY = bgY + 3, barH = 5, barW = 88;
  const entries = [
    { key: 'claude', label: 'CLAUDE', iconColor: '#f0c040', x: 4 },
    { key: 'codex', label: 'CODEX', iconColor: '#3adf7a', x: 160 },
  ];

  entries.forEach(e => {
    const data = canvasUsage[e.key];
    const labelX = e.x + 8;
    const barX = e.x + 42;

    // Icon: star for Claude, coin for Codex
    if (e.key === 'claude') {
      // Small star icon
      ctx.fillStyle = e.iconColor;
      ctx.fillRect(e.x + 2, barY - 1, 1, 3);
      ctx.fillRect(e.x, barY, 5, 1);
      ctx.fillRect(e.x + 1, barY + 1, 3, 1);
      ctx.fillRect(e.x + 1, barY - 2, 3, 1);
    } else {
      // Small coin icon
      ctx.fillStyle = e.iconColor;
      ctx.fillRect(e.x + 1, barY - 1, 3, 3);
      ctx.fillRect(e.x, barY, 5, 1);
      ctx.fillStyle = '#2a8a5a';
      ctx.fillRect(e.x + 2, barY, 1, 1);
    }

    // Label
    ctx.font = '3px "Press Start 2P"';
    ctx.fillStyle = '#c0c0d0';
    ctx.fillText(e.label, labelX, barY + 3);

    // Bar background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(barX, barY, barW, barH);
    // Bar border
    ctx.fillStyle = '#3a3a5e';
    ctx.fillRect(barX, barY, barW, 1);
    ctx.fillRect(barX, barY + barH - 1, barW, 1);
    ctx.fillRect(barX, barY, 1, barH);
    ctx.fillRect(barX + barW - 1, barY, 1, barH);

    if (!data) {
      // Loading state
      ctx.fillStyle = '#555';
      ctx.fillRect(barX + 1, barY + 1, barW - 2, barH - 2);
      ctx.fillStyle = '#888';
      ctx.font = '3px "Press Start 2P"';
      ctx.fillText('...', barX + barW / 2 - 5, barY + 4);
    } else if (data.error) {
      // Error state
      ctx.fillStyle = '#444';
      ctx.fillRect(barX + 1, barY + 1, barW - 2, barH - 2);
      ctx.fillStyle = '#ff5c5c';
      ctx.font = '3px "Press Start 2P"';
      ctx.fillText('ERR', barX + barW / 2 - 6, barY + 4);
    } else if (data.exhausted) {
      // Exhausted: full red, flashing label
      ctx.fillStyle = '#ff5c5c';
      ctx.fillRect(barX + 1, barY + 1, barW - 2, barH - 2);
      // Flashing EXHAUSTED text
      if (Math.floor(frame / 30) % 2 === 0) {
        ctx.fillStyle = '#fff';
        ctx.font = '3px "Press Start 2P"';
        ctx.fillText('EXHAUSTED', barX + 4, barY + 4);
      }
      ctx.fillStyle = '#ff5c5c';
      ctx.font = '3px "Press Start 2P"';
      ctx.fillText('0%', barX + barW + 3, barY + 4);
    } else if (data.pct !== null) {
      // Normal bar
      const pct = Math.max(0, Math.min(100, data.pct));
      const fillW = Math.floor((barW - 2) * pct / 100);
      const fillColor = pct > 50 ? '#3adf7a' : pct >= 20 ? '#f0c040' : '#ff5c5c';
      ctx.fillStyle = fillColor;
      ctx.fillRect(barX + 1, barY + 1, fillW, barH - 2);
      // Percentage text
      ctx.fillStyle = '#c0c0d0';
      ctx.font = '3px "Press Start 2P"';
      ctx.fillText(pct + '%', barX + barW + 3, barY + 4);
    } else {
      // Unknown: gray
      ctx.fillStyle = '#444';
      ctx.fillRect(barX + 1, barY + 1, barW - 2, barH - 2);
      ctx.fillStyle = '#888';
      ctx.font = '3px "Press Start 2P"';
      ctx.fillText('...', barX + barW / 2 - 5, barY + 4);
    }
  });
  ctx.restore();
}

function render() {
  frame++;
  ctx.clearRect(0, 0, 1280, 768);

  drawFloorSV(); drawWallsSV(); drawGarageFrame(); drawWindow(); drawDoor();
  drawNeonSign(); drawWhiteboard();
  drawLightingSV();
  drawLampGlow(5, 0); drawLampGlow(15, 0);
  drawDivider(2); drawDivider(3);
  drawPropsSV();
  drawUsageBars();

  // Update walking transitions
  updateTransitions();
  const walkingDesks = new Set(transitions.map(t => t.deskIdx));

  const canvasAgents = buildCanvasAgents();
  DESKS.forEach((d, idx) => {
    const agent = canvasAgents.find(a => a.desk === idx);
    const agentType = agent ? agent.agentType : '';
    drawDeskSV(d, idx, agentType);
    drawChairSV(d, idx);
  });

  canvasAgents.forEach(a => {
    const d = DESKS[a.desk];
    if (!d) return;
    const isWalking = walkingDesks.has(a.desk);
    const screenState = isWalking ? 'pr_open' :
      a.failing ? 'ci_failed' :
      a.state === 'coding' ? 'coding' :
      a.state === 'merged' ? 'merged' : 'pr_open';
    drawMonitorSV(d, screenState, a.monitorText, a.desk, a.agentType);

    if (isWalking) return;

    if (a.dead) { drawTombstone(d); drawCharacterSV(d, a.ci, 'exited', a.agentType); }
    else drawCharacterSV(d, a.ci, a.state, a.agentType);

    drawTokenBar(d, a.tokens);
    // Headphone stand on desk edge for coding agents
    if (a.state === 'coding') {
      ctx.save(); ctx.scale(SCALE, SCALE);
      const hx = d.x * TILE + TILE - 1, hy = d.y * TILE + 6;
      R(hx, hy, 1, 3, '#555'); // stand pole
      R(hx - 1, hy, 3, 1, '#666'); // top bar
      R(hx - 2, hy, 1, 2, '#444'); R(hx + 2, hy, 1, 2, '#444'); // headphone cups
      ctx.restore();
      drawKeyboardGlowSV(d, a.desk);
      drawThoughtBubbleSV(d, a.desk);
    }
    if (a.coffees > 0) drawCoffeeCups(d, a.coffees);
    if (a.failing) drawFire(d);
    if (a.pr) drawPrBadge(d, a.pr, a.state === 'merged');
    if (a.label) {
      const bc = a.failing ? '#f66' : (a.state === 'merged' ? '#f0c040' : '#fff');
      drawBubble(d, a.label, bc);
    }
    if (a.state === 'merged') drawConfetti(d);
  });

  // Draw walking agents at interpolated positions
  transitions.forEach(t => {
    const now = Date.now();
    if (now < t.startTime) return;
    const pos = positionAlongPath(t.path, t.progress);
    drawCharacterSV(pos, t.colorIdx, 'walking', t.agentType);
  });

  // Click glow feedback
  if (clickedDesk >= 0 && Date.now() - clickedAt < 300) {
    const gd = DESKS[clickedDesk];
    if (gd) {
      const alpha = 0.3 * (1 - (Date.now() - clickedAt) / 300);
      ctx.fillStyle = 'rgba(240, 192, 64, ' + alpha + ')';
      ctx.fillRect(gd.x * S - 4, gd.y * S - 8, S + 8, S * 2 + 16);
    }
  }

  drawTumbleweed();
  drawPlant(0, 2); drawPlant(0, 9); drawPlant(COLS - 1, 4);
  drawServerRack((COLS - 1) * TILE - 4, 6 * TILE);
  drawParticles();

  // Day/night overlay ‚Äî applied last, over entire scene
  drawDayNightOverlay();

  requestAnimationFrame(render);
}

// === SIDEBAR RESIZE ===
(function() {
  const sidebar = document.getElementById('sidebar');
  const handle = document.getElementById('resizeHandle');
  let dragging = false, startX, startW;
  handle.addEventListener('mousedown', (e) => {
    e.preventDefault(); dragging = true; startX = e.clientX; startW = sidebar.offsetWidth;
    handle.classList.add('dragging'); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    sidebar.style.width = Math.max(200, Math.min(600, startW + (e.clientX - startX))) + 'px';
  });
  document.addEventListener('mouseup', () => {
    if (!dragging) return; dragging = false;
    handle.classList.remove('dragging'); document.body.style.cursor = ''; document.body.style.userSelect = '';
    try { localStorage.setItem('corral-sidebar-w', sidebar.offsetWidth); } catch {}
  });
  try { const saved = localStorage.getItem('corral-sidebar-w'); if (saved) sidebar.style.width = saved + 'px'; } catch {}
})();

// === MOBILE SIDEBAR TOGGLE ===
function toggleMobileSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('mobileOverlay');
  const isOpen = sidebar.classList.contains('mobile-open');
  if (isOpen) {
    sidebar.classList.remove('mobile-open');
    overlay.classList.remove('visible');
  } else {
    sidebar.classList.add('mobile-open');
    overlay.classList.add('visible');
  }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const sidebar = document.getElementById('sidebar');
    if (sidebar.classList.contains('mobile-open')) toggleMobileSidebar();
  }
  if ((e.key === 's' || e.key === 'S') && !e.ctrlKey && !e.metaKey && !e.altKey) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    toggleSound();
  }
});

// Agent card tap-to-expand on mobile (touch devices)
document.addEventListener('click', (e) => {
  if (window.innerWidth >= 768) return;
  const card = e.target.closest('.agent-card');
  if (!card) return;
  // Toggle expanded state
  const wasExpanded = card.classList.contains('mobile-expanded');
  // Collapse all other cards first
  document.querySelectorAll('.agent-card.mobile-expanded').forEach(c => c.classList.remove('mobile-expanded'));
  if (!wasExpanded) card.classList.add('mobile-expanded');
});

// === CANVAS CLICK ‚Äî open agent URL ===
let clickedDesk = -1, clickedAt = 0;

function getAgentUrl(agent) {
  if (!agent) return null;
  if (agent.prUrl) return agent.prUrl;
  const prNum = getPrNumber(agent);
  if (prNum && agent.repo) return 'https://github.com/' + agent.repo + '/pull/' + prNum;
  const issueId = getIssueId(agent);
  if (agent.repo && issueId) return 'https://github.com/' + agent.repo + '/issues/' + issueId;
  return null;
}

function hitTestAgent(cx, cy) {
  const canvasAgents = buildCanvasAgents();
  for (const a of canvasAgents) {
    const desk = DESKS[a.desk];
    if (!desk) continue;
    // Hit region centered on desk+character area
    const dx = desk.x * S + S / 2;
    const dy = (desk.y + 1) * S;
    if (Math.abs(cx - dx) < S * 0.7 && Math.abs(cy - dy) < S) {
      return a.desk;
    }
  }
  return -1;
}

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  const idx = hitTestAgent(cx, cy);
  if (idx >= 0 && idx < agents.length) {
    const url = getAgentUrl(agents[idx]);
    if (url) {
      clickedDesk = idx;
      clickedAt = Date.now();
      window.open(url, '_blank', 'noopener');
    }
  }
});

// === CANVAS HOVER TOOLTIP ===
const canvasTooltip = document.getElementById('canvasTooltip');
let hoveredDeskIdx = -1;
const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

function buildCanvasTooltip(agent) {
  if (!agent) return '';
  const repoName = getRepoName(agent);
  const issueId = getIssueId(agent);
  const label = repoName && issueId ? escapeHtml(repoName + '#' + issueId) : escapeHtml(repoName || agent.id || 'agent');
  const state = mapState(agent);
  const statusText = escapeHtml(stateLabel(state));
  const pulseClass = stateToPulseClass(state);
  const agentType = escapeHtml(resolveAgentType(agent) || 'unknown');
  const created = getCreatedAt(agent);
  const uptime = created ? escapeHtml(formatDuration(Date.now() - created)) : '‚Äî';
  const prNum = getPrNumber(agent);
  const prUrl = agent.prUrl || '';
  const prDisplay = prNum ? `PR #${escapeHtml(prNum)}` : '‚Äî';
  const prLink = prUrl && prNum ? `<a href="${escapeHtml(prUrl)}" target="_blank" rel="noopener" style="color:#88aaff;pointer-events:auto">${prDisplay}</a>` : prDisplay;
  const issueTitle = agent.issueTitle ? escapeHtml(agent.issueTitle) : '';
  const titleRow = issueTitle ? `<div class="tt-row"><span class="tt-lbl">Issue</span><span style="color:#999">${issueTitle}</span></div>` : '';
  return `
    <div class="tt-title"><span class="ac-pulse ${pulseClass}"></span><span>${label}</span></div>
    <div class="tt-row"><span class="tt-lbl">Status</span><span class="${stateToColorClass(state)}">${statusText}</span></div>
    <div class="tt-row"><span class="tt-lbl">Type</span><span>${agentType}</span></div>
    <div class="tt-row"><span class="tt-lbl">Uptime</span><span>${uptime}</span></div>
    <div class="tt-row"><span class="tt-lbl">PR</span><span>${prLink}</span></div>
    ${titleRow}
  `;
}

function positionCanvasTooltip(clientX, clientY) {
  const pad = 14;
  let left = clientX + pad;
  let top = clientY + pad;
  const { offsetWidth: w, offsetHeight: h } = canvasTooltip;
  if (left + w > window.innerWidth - 8) left = clientX - w - pad;
  if (top + h > window.innerHeight - 8) top = clientY - h - pad;
  canvasTooltip.style.left = Math.max(8, left) + 'px';
  canvasTooltip.style.top = Math.max(8, top) + 'px';
}

function showCanvasTooltip(agent, clientX, clientY) {
  canvasTooltip.innerHTML = buildCanvasTooltip(agent);
  canvasTooltip.style.display = 'block';
  canvasTooltip.setAttribute('aria-hidden', 'false');
  positionCanvasTooltip(clientX, clientY);
}

function hideCanvasTooltip() {
  hoveredDeskIdx = -1;
  canvasTooltip.style.display = 'none';
  canvasTooltip.setAttribute('aria-hidden', 'true');
}

canvas.addEventListener('mousemove', (e) => {
  if (isTouchDevice) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;
  const idx = hitTestAgent(cx, cy);
  if (idx >= 0 && idx < agents.length) {
    canvas.style.cursor = 'pointer';
    if (idx !== hoveredDeskIdx) {
      hoveredDeskIdx = idx;
      showCanvasTooltip(agents[idx], e.clientX, e.clientY);
    } else {
      positionCanvasTooltip(e.clientX, e.clientY);
    }
  } else {
    canvas.style.cursor = '';
    if (hoveredDeskIdx >= 0) hideCanvasTooltip();
  }
});

canvas.addEventListener('mouseleave', () => {
  if (hoveredDeskIdx >= 0) hideCanvasTooltip();
});

// === START ===
try { soundEnabled = localStorage.getItem('corral-sound') === '1'; } catch {}
updateSoundButton();
requestAnimationFrame(render);
startPolling();
</script>
</body>
</html>
